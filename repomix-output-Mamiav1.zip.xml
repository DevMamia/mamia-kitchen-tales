This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.bolt/
  config.json/
    config.json
.expo/
  devices.json/
    devices.json
  README.md/
    README.md
  types/
    router.d.ts/
      router.d.ts
.gitattributes/
  .gitattributes
.gitignore/
  .gitignore
.npmrc/
  .npmrc
.prettierrc/
  .prettierrc
app/
  _layout.tsx/
    _layout.tsx
  (tabs)/
    _layout.tsx/
      _layout.tsx
    cooking.tsx/
      cooking.tsx
    favourites.tsx/
      favourites.tsx
    index.tsx/
      index.tsx
    profile.tsx/
      profile.tsx
    recipes.tsx/
      recipes.tsx
  +not-found.tsx/
    +not-found.tsx
  api/
    upload-photo+api.ts/
      upload-photo+api.ts
  index.tsx/
    index.tsx
  mama-selection.tsx/
    mama-selection.tsx
  recipe-detail.tsx/
    recipe-detail.tsx
  search.tsx/
    search.tsx
app.json/
  app.json
components/
  AdaptiveUI.tsx/
    AdaptiveUI.tsx
  ContextAwareVoiceInterface.tsx/
    ContextAwareVoiceInterface.tsx
  ContextualPrompt.tsx/
    ContextualPrompt.tsx
  VoiceCommandInterface.tsx/
    VoiceCommandInterface.tsx
  VoiceStatusIndicator.tsx/
    VoiceStatusIndicator.tsx
eas.json/
  eas.json
expo-env.d.ts/
  expo-env.d.ts
hooks/
  useCookingContext.ts/
    useCookingContext.ts
  useCookingMode.ts/
    useCookingMode.ts
  useFrameworkReady.ts/
    useFrameworkReady.ts
  useUnifiedChat.ts/
    useUnifiedChat.ts
package.json/
  package.json
README.md/
  README.md
services/
  ContextAwareVoiceService.ts/
    ContextAwareVoiceService.ts
  ConversationService.ts/
    ConversationService.ts
  OptimizedVoiceService.ts/
    OptimizedVoiceService.ts
  ResponseCacheService.ts/
    ResponseCacheService.ts
  UnifiedConversationService.ts/
    UnifiedConversationService.ts
  VoiceCacheService.ts/
    VoiceCacheService.ts
  VoiceCommandService.ts/
    VoiceCommandService.ts
tsconfig.json/
  tsconfig.json
types/
  env.d.ts/
    env.d.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".bolt/config.json/config.json">
{
  "template": "bolt-expo"
}
</file>

<file path=".expo/devices.json/devices.json">
{
  "devices": []
}
</file>

<file path=".expo/README.md/README.md">
> Why do I have a folder named ".expo" in my project?
The ".expo" folder is created when an Expo project is started using "expo start" command.
> What do the files contain?
- "devices.json": contains information about devices that have recently opened this project. This is used to populate the "Development sessions" list in your development builds.
- "settings.json": contains the server configuration that is used to serve the application manifest.
> Should I commit the ".expo" folder?
No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.
Upon project creation, the ".expo" folder is already added to your ".gitignore" file.
</file>

<file path=".expo/types/router.d.ts/router.d.ts">
/* eslint-disable */
import * as Router from 'expo-router';

export * from 'expo-router';

declare module 'expo-router' {
  export namespace ExpoRouter {
    export interface __routes<T extends string | object = string> {
      hrefInputParams: { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/mama-selection`; params?: Router.UnknownInputParams; } | { pathname: `/recipe-detail`; params?: Router.UnknownInputParams; } | { pathname: `/search`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/cooking` | `/cooking`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/favourites` | `/favourites`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}` | `/`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/profile` | `/profile`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/recipes` | `/recipes`; params?: Router.UnknownInputParams; } | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
      hrefOutputParams: { pathname: Router.RelativePathString, params?: Router.UnknownOutputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownOutputParams } | { pathname: `/`; params?: Router.UnknownOutputParams; } | { pathname: `/mama-selection`; params?: Router.UnknownOutputParams; } | { pathname: `/recipe-detail`; params?: Router.UnknownOutputParams; } | { pathname: `/search`; params?: Router.UnknownOutputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownOutputParams; } | { pathname: `${'/(tabs)'}/cooking` | `/cooking`; params?: Router.UnknownOutputParams; } | { pathname: `${'/(tabs)'}/favourites` | `/favourites`; params?: Router.UnknownOutputParams; } | { pathname: `${'/(tabs)'}` | `/`; params?: Router.UnknownOutputParams; } | { pathname: `${'/(tabs)'}/profile` | `/profile`; params?: Router.UnknownOutputParams; } | { pathname: `${'/(tabs)'}/recipes` | `/recipes`; params?: Router.UnknownOutputParams; } | { pathname: `/+not-found`, params: Router.UnknownOutputParams & {  } };
      href: Router.RelativePathString | Router.ExternalPathString | `/${`?${string}` | `#${string}` | ''}` | `/mama-selection${`?${string}` | `#${string}` | ''}` | `/recipe-detail${`?${string}` | `#${string}` | ''}` | `/search${`?${string}` | `#${string}` | ''}` | `/_sitemap${`?${string}` | `#${string}` | ''}` | `${'/(tabs)'}/cooking${`?${string}` | `#${string}` | ''}` | `/cooking${`?${string}` | `#${string}` | ''}` | `${'/(tabs)'}/favourites${`?${string}` | `#${string}` | ''}` | `/favourites${`?${string}` | `#${string}` | ''}` | `${'/(tabs)'}${`?${string}` | `#${string}` | ''}` | `/${`?${string}` | `#${string}` | ''}` | `${'/(tabs)'}/profile${`?${string}` | `#${string}` | ''}` | `/profile${`?${string}` | `#${string}` | ''}` | `${'/(tabs)'}/recipes${`?${string}` | `#${string}` | ''}` | `/recipes${`?${string}` | `#${string}` | ''}` | { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/mama-selection`; params?: Router.UnknownInputParams; } | { pathname: `/recipe-detail`; params?: Router.UnknownInputParams; } | { pathname: `/search`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/cooking` | `/cooking`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/favourites` | `/favourites`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}` | `/`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/profile` | `/profile`; params?: Router.UnknownInputParams; } | { pathname: `${'/(tabs)'}/recipes` | `/recipes`; params?: Router.UnknownInputParams; } | `/+not-found` | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
    }
  }
}
</file>

<file path=".gitattributes/.gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore/.gitignore">
# dependencies
node_modules/

# expo
.expo/
dist/
web-build/
expo-env.d.ts

# native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macos
.DS_Store
*.pem

# local env files
.env*.local
.env

# typescript
*.tsbuildinfo
</file>

<file path=".npmrc/.npmrc">
legacy-peer-deps=true
</file>

<file path=".prettierrc/.prettierrc">
{
  "useTabs": false,
  "bracketSpacing": true,
  "singleQuote": true,
  "tabWidth": 2
}
</file>

<file path="app/_layout.tsx/_layout.tsx">
import { useEffect } from 'react';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import { useFrameworkReady } from '@/hooks/useFrameworkReady';

export default function RootLayout() {
  useFrameworkReady();

  return (
    <>
      <Stack screenOptions={{ headerShown: false }}>
        <Stack.Screen name="index" />
        <Stack.Screen name="mama-selection" />
        <Stack.Screen name="search" />
        <Stack.Screen name="recipe-detail" />
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="+not-found" />
      </Stack>
      <StatusBar style="auto" />
    </>
  );
}
</file>

<file path="app/(tabs)/_layout.tsx/_layout.tsx">
import { Tabs } from 'expo-router';
import { ChefHat, Book, Utensils, Heart, User } from 'lucide-react-native';

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarStyle: {
          backgroundColor: '#F5E6D3',
          borderTopColor: '#8B4513',
          borderTopWidth: 1,
          height: 88,
          paddingBottom: 12,
          paddingTop: 6,
        },
        tabBarActiveTintColor: '#8B4513',
        tabBarInactiveTintColor: '#A0522D',
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
          marginBottom: 10,
          marginTop: 0,
        },
        tabBarIconStyle: {
          marginBottom: 0,
          marginTop: 2,
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: 'Mama',
          tabBarIcon: ({ size, color }) => (
            <ChefHat size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="recipes"
        options={{
          title: 'Recipes',
          tabBarIcon: ({ size, color }) => (
            <Book size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="cooking"
        options={{
          title: 'Cook',
          tabBarIcon: ({ size, color }) => (
            <Utensils size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="favourites"
        options={{
          title: 'Favourites',
          tabBarIcon: ({ size, color }) => (
            <Heart size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: 'Profile',
          tabBarIcon: ({ size, color }) => (
            <User size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
</file>

<file path="app/(tabs)/cooking.tsx/cooking.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, Image, Animated, Dimensions, TextInput, KeyboardAvoidingView, Platform } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { ArrowLeft, Clock, ChefHat, Star, Users, Play, Pause, SkipForward, SkipBack, Timer, Camera, Heart, Volume2, VolumeX, Settings, CircleCheck as CheckCircle, Circle, Mic, Send, MessageCircle, ToggleLeft, ToggleRight, CircleHelp as HelpCircle, Square, Upload, ChevronDown, ChevronUp, RotateCcw } from 'lucide-react-native';
import { useCookingMode } from '@/hooks/useCookingMode';
import { useCookingContext } from '@/hooks/useCookingContext';
import ContextualPrompt from '@/components/ContextualPrompt';
import AdaptiveUI from '@/components/AdaptiveUI';
import OptimizedVoiceService, { OptimizedVoiceStatus } from '@/services/OptimizedVoiceService';
import { useUnifiedChat } from '@/hooks/useUnifiedChat';

const { width: screenWidth } = Dimensions.get('window');

// COMPLETE Recipe data with all recipes and culture mapping
const recipeData = {
  1: {
    id: 1,
    name: 'Classic Carbonara',
    chef: 'Nonna Lucia',
    chefAvatar: 'üëµüèª',
    culture: 'italian',
    image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=800',
    difficulty: 2,
    time: '25 min',
    servings: 4,
    description: 'Authentic Roman pasta with eggs, cheese, and pancetta',
    
    ingredients: [
      { item: 'Spaghetti', amount: '400g', prepared: false },
      { item: 'Pancetta or Guanciale', amount: '150g', prepared: false },
      { item: 'Large Eggs', amount: '4', prepared: false },
      { item: 'Pecorino Romano', amount: '100g', prepared: false },
      { item: 'Black Pepper', amount: '1 tsp', prepared: false },
      { item: 'Salt', amount: 'to taste', prepared: false },
    ],
    
    equipment: [
      'Large pot for pasta',
      'Large pan or skillet',
      'Mixing bowl',
      'Cheese grater',
      'Tongs or pasta fork'
    ],
    
    steps: [
      {
        id: 1,
        title: 'Prepare Ingredients',
        instruction: 'Grate the Pecorino Romano cheese and crack eggs into a large mixing bowl. Cut pancetta into small cubes.',
        duration: 300,
        tips: ['Use room temperature eggs for better mixing', 'Cut pancetta into uniform pieces'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 2,
        title: 'Boil Water',
        instruction: 'Fill a large pot with water, add generous salt, and bring to a rolling boil.',
        duration: 480,
        tips: ['Water should taste like sea water', 'Use plenty of water for pasta'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 3,
        title: 'Cook Pancetta',
        instruction: 'Heat a large pan over medium heat. Add pancetta and cook until crispy and golden, about 5-7 minutes.',
        duration: 420,
        tips: ['No oil needed - pancetta has its own fat', 'Save the rendered fat'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 4,
        title: 'Prepare Egg Mixture',
        instruction: 'Whisk eggs with grated Pecorino Romano and freshly ground black pepper until well combined.',
        duration: 180,
        tips: ['Mix thoroughly to avoid lumps', 'Add plenty of black pepper'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 5,
        title: 'Cook Pasta',
        instruction: 'Add spaghetti to boiling water and cook until al dente according to package directions.',
        duration: 600,
        tips: ['Stir occasionally to prevent sticking', 'Taste test for doneness'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 6,
        title: 'Combine Everything',
        instruction: 'Reserve 1 cup pasta water, then drain pasta. Add hot pasta to pancetta pan, remove from heat, and quickly mix in egg mixture.',
        duration: 240,
        tips: ['Work quickly to prevent eggs from scrambling', 'Add pasta water gradually'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 7,
        title: 'Final Touch',
        instruction: 'Toss everything together, adding pasta water as needed to create a creamy sauce. Serve immediately with extra cheese and pepper.',
        duration: 120,
        tips: ['The sauce should coat the pasta', 'Serve in warmed bowls'],
        image: 'https://images.pexels.com/photos/4518843/pexels-photo-4518843.jpeg?auto=compress&cs=tinysrgb&w=400'
      }
    ]
  },
  2: {
    id: 2,
    name: 'Nonna\'s Minestrone',
    chef: 'Nonna Lucia',
    chefAvatar: 'üëµüèª',
    culture: 'italian',
    image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=800',
    difficulty: 1,
    time: '45 min',
    servings: 6,
    description: 'Hearty Italian vegetable soup with seasonal ingredients',
    
    ingredients: [
      { item: 'Olive Oil', amount: '3 tbsp', prepared: false },
      { item: 'Onion, diced', amount: '1 large', prepared: false },
      { item: 'Carrots, diced', amount: '2', prepared: false },
      { item: 'Celery, diced', amount: '2 stalks', prepared: false },
      { item: 'Garlic, minced', amount: '3 cloves', prepared: false },
      { item: 'Canned Tomatoes', amount: '400g', prepared: false },
      { item: 'Vegetable Broth', amount: '1.5L', prepared: false },
      { item: 'Cannellini Beans', amount: '400g', prepared: false },
      { item: 'Small Pasta', amount: '100g', prepared: false },
      { item: 'Fresh Basil', amount: '1/4 cup', prepared: false },
      { item: 'Parmesan Cheese', amount: '50g', prepared: false }
    ],
    
    equipment: [
      'Large soup pot',
      'Wooden spoon',
      'Ladle',
      'Cutting board',
      'Sharp knife'
    ],
    
    steps: [
      {
        id: 1,
        title: 'Prepare Vegetables',
        instruction: 'Heat olive oil in a large pot over medium heat. Add onion, carrots, and celery.',
        duration: 480,
        tips: ['Dice vegetables uniformly for even cooking', 'Cook until softened, about 8 minutes'],
        image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 2,
        title: 'Add Aromatics',
        instruction: 'Add garlic and cook for another minute until fragrant.',
        duration: 60,
        tips: ['Don\'t let garlic burn', 'Stir constantly'],
        image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 3,
        title: 'Add Tomatoes',
        instruction: 'Add tomatoes, breaking them up with a spoon. Cook for 5 minutes.',
        duration: 300,
        tips: ['Break up tomatoes well', 'Let them cook down'],
        image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 4,
        title: 'Add Broth and Beans',
        instruction: 'Pour in broth and bring to a boil. Add beans and simmer for 15 minutes.',
        duration: 900,
        tips: ['Rinse beans if using canned', 'Simmer gently'],
        image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 5,
        title: 'Cook Pasta',
        instruction: 'Add pasta and cook until al dente, about 10 minutes.',
        duration: 600,
        tips: ['Stir occasionally', 'Don\'t overcook pasta'],
        image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 6,
        title: 'Finish and Serve',
        instruction: 'Stir in fresh basil and season with salt and pepper. Serve hot with grated Parmesan cheese.',
        duration: 120,
        tips: ['Add basil at the end', 'Taste and adjust seasoning'],
        image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400'
      }
    ]
  },
  3: {
    id: 3,
    name: 'Tacos al Pastor',
    chef: 'Abuela Rosa',
    chefAvatar: 'üëµüèΩ',
    culture: 'mexican',
    image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=800',
    difficulty: 3,
    time: '2 hours',
    servings: 8,
    description: 'Traditional Mexican tacos with marinated pork and pineapple',
    
    ingredients: [
      { item: 'Pork Shoulder', amount: '1 kg', prepared: false },
      { item: 'Pineapple', amount: '1/2 fresh', prepared: false },
      { item: 'Corn Tortillas', amount: '12', prepared: false },
      { item: 'White Onion', amount: '1 medium', prepared: false },
      { item: 'Fresh Cilantro', amount: '1/2 cup', prepared: false },
      { item: 'Lime', amount: '2 limes', prepared: false },
      { item: 'Achiote Paste', amount: '2 tbsp', prepared: false },
      { item: 'Orange Juice', amount: '1/4 cup', prepared: false },
      { item: 'Garlic', amount: '3 cloves', prepared: false },
      { item: 'Chipotle Peppers', amount: '2', prepared: false },
      { item: 'Salt', amount: 'to taste', prepared: false }
    ],
    
    equipment: [
      'Large skillet or comal',
      'Blender',
      'Sharp knife',
      'Cutting board',
      'Large bowl for marinating'
    ],
    
    steps: [
      {
        id: 1,
        title: 'Make Marinade',
        instruction: 'Blend achiote paste, orange juice, garlic, chipotle peppers, and salt to make marinade.',
        duration: 300,
        tips: ['Blend until smooth', 'Taste and adjust spice level'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 2,
        title: 'Marinate Pork',
        instruction: 'Cut pork into thin slices and marinate for at least 2 hours or overnight.',
        duration: 7200,
        tips: ['Slice pork thinly for faster cooking', 'Longer marination = better flavor'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 3,
        title: 'Cook Pork',
        instruction: 'Cook marinated pork in a hot skillet until edges are crispy, about 8-10 minutes.',
        duration: 600,
        tips: ['Don\'t overcrowd the pan', 'Get crispy edges for authentic texture'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 4,
        title: 'Prepare Pineapple',
        instruction: 'Grill pineapple slices until caramelized, then dice into small pieces.',
        duration: 480,
        tips: ['Caramelize for sweetness', 'Dice small for easy eating'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 5,
        title: 'Warm Tortillas',
        instruction: 'Warm tortillas on a comal or dry skillet until pliable.',
        duration: 300,
        tips: ['Don\'t overheat tortillas', 'Keep warm in a towel'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 6,
        title: 'Prepare Garnishes',
        instruction: 'Dice onion finely and chop cilantro.',
        duration: 240,
        tips: ['Fine dice for onion', 'Fresh cilantro is essential'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 7,
        title: 'Assemble Tacos',
        instruction: 'Assemble tacos with pork, pineapple, onion, and cilantro. Serve with lime wedges.',
        duration: 300,
        tips: ['Don\'t overfill tacos', 'Squeeze lime just before eating'],
        image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400'
      }
    ]
  },
  4: {
    id: 4,
    name: 'Green Curry',
    chef: 'Mae Malai',
    chefAvatar: 'üëµüèª',
    culture: 'thai',
    image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=800',
    difficulty: 2,
    time: '35 min',
    servings: 4,
    description: 'Aromatic Thai curry with coconut milk and fresh herbs',
    
    ingredients: [
      { item: 'Chicken Breast', amount: '500g', prepared: false },
      { item: 'Coconut Milk', amount: '400ml', prepared: false },
      { item: 'Green Curry Paste', amount: '3 tbsp', prepared: false },
      { item: 'Thai Eggplant', amount: '200g', prepared: false },
      { item: 'Thai Basil', amount: '1/2 cup', prepared: false },
      { item: 'Fish Sauce', amount: '2 tbsp', prepared: false },
      { item: 'Palm Sugar', amount: '1 tbsp', prepared: false },
      { item: 'Kaffir Lime Leaves', amount: '4 leaves', prepared: false },
      { item: 'Thai Chilies', amount: '2-3', prepared: false },
      { item: 'Jasmine Rice', amount: '2 cups cooked', prepared: false }
    ],
    
    equipment: [
      'Wok or large pan',
      'Wooden spoon',
      'Sharp knife',
      'Cutting board',
      'Rice cooker or pot'
    ],
    
    steps: [
      {
        id: 1,
        title: 'Prepare Ingredients',
        instruction: 'Cut chicken into bite-sized pieces and slice eggplant. Tear lime leaves and slice chilies.',
        duration: 480,
        tips: ['Remove stems from lime leaves', 'Slice chilies for heat control'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 2,
        title: 'Fry Curry Paste',
        instruction: 'Heat thick coconut cream in wok. Add curry paste and fry until fragrant, about 3 minutes.',
        duration: 180,
        tips: ['Use thick cream from top of can', 'Fry until oil separates'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 3,
        title: 'Cook Chicken',
        instruction: 'Add chicken pieces and cook until no longer pink, about 5 minutes.',
        duration: 300,
        tips: ['Stir frequently', 'Cook until chicken changes color'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 4,
        title: 'Add Coconut Milk',
        instruction: 'Pour in remaining coconut milk and bring to a gentle simmer.',
        duration: 240,
        tips: ['Don\'t boil vigorously', 'Gentle simmer prevents curdling'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 5,
        title: 'Add Vegetables',
        instruction: 'Add eggplant, lime leaves, and chilies. Simmer for 8-10 minutes until eggplant is tender.',
        duration: 600,
        tips: ['Eggplant should be soft but not mushy', 'Adjust chilies for heat'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 6,
        title: 'Season and Finish',
        instruction: 'Add fish sauce and palm sugar. Taste and adjust. Stir in Thai basil just before serving.',
        duration: 180,
        tips: ['Balance sweet, salty, and spicy', 'Add basil at the very end'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 7,
        title: 'Serve',
        instruction: 'Serve hot over jasmine rice with extra Thai basil leaves.',
        duration: 120,
        tips: ['Serve immediately', 'Garnish with fresh basil'],
        image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400'
      }
    ]
  },
  5: {
    id: 5,
    name: 'Traditional Green Curry',
    chef: 'Mae Malai',
    chefAvatar: 'üëµüèª',
    culture: 'thai',
    image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',
    difficulty: 2,
    time: '45 min',
    servings: 4,
    description: 'Authentic Thai green curry with coconut milk, fresh herbs, and your choice of protein. A perfect balance of spicy, sweet, and aromatic flavors.',
    
    ingredients: [
      { item: 'Coconut Milk', amount: '400ml', prepared: false },
      { item: 'Green Curry Paste', amount: '2-3 tbsp', prepared: false },
      { item: 'Chicken Thigh (or Tofu)', amount: '300g', prepared: false },
      { item: 'Thai Eggplant, sliced', amount: '1 medium', prepared: false },
      { item: 'Green Beans, trimmed', amount: '100g', prepared: false },
      { item: 'Kaffir Lime Leaves', amount: '2 leaves', prepared: false },
      { item: 'Fish Sauce', amount: '1 tbsp', prepared: false },
      { item: 'Palm Sugar', amount: '1 tbsp', prepared: false },
      { item: 'Thai Basil Leaves', amount: '1/4 cup', prepared: false },
      { item: 'Red Chili, sliced', amount: '1 piece', prepared: false },
      { item: 'Jasmine Rice', amount: 'for serving', prepared: false }
    ],
    
    equipment: [
      'Wok or large pan',
      'Wooden spoon',
      'Sharp knife',
      'Cutting board',
      'Rice cooker or pot'
    ],
    
    steps: [
      {
        id: 1,
        title: 'Prepare Ingredients',
        instruction: 'Cut chicken into bite-sized pieces, slice eggplant and green beans. Tear lime leaves and slice chili.',
        duration: 480,
        tips: ['Remove stems from lime leaves', 'Cut vegetables uniformly for even cooking'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 2,
        title: 'Heat Coconut Cream',
        instruction: 'Heat 1/3 of coconut milk in wok over medium heat until oil separates, about 3-4 minutes.',
        duration: 240,
        tips: ['Use thick cream from top of can', 'Let it separate naturally for rich flavor'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 3,
        title: 'Fry Curry Paste',
        instruction: 'Add green curry paste and fry until fragrant and aromatic, about 2 minutes.',
        duration: 120,
        tips: ['Fresh curry paste makes all the difference', 'Fry until very fragrant'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 4,
        title: 'Cook Chicken',
        instruction: 'Add chicken pieces and cook until just done and coated with paste, about 5 minutes.',
        duration: 300,
        tips: ['Stir frequently to coat with paste', 'Cook until chicken changes color'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 5,
        title: 'Add Remaining Coconut Milk',
        instruction: 'Pour in remaining coconut milk and bring to gentle simmer.',
        duration: 180,
        tips: ['Don\'t rush - let it separate naturally', 'Gentle simmer prevents curdling'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 6,
        title: 'Add Vegetables',
        instruction: 'Add eggplant and green beans, cook for 8-10 minutes until vegetables are tender.',
        duration: 600,
        tips: ['Thai eggplant has the best texture', 'Vegetables should be tender but not mushy'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 7,
        title: 'Season and Balance',
        instruction: 'Season with fish sauce and palm sugar, taste and adjust for perfect balance.',
        duration: 120,
        tips: ['Balance is key: sweet, salty, spicy, and aromatic', 'Taste and adjust seasoning'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      },
      {
        id: 8,
        title: 'Finish and Serve',
        instruction: 'Add kaffir lime leaves and simmer 2 more minutes. Garnish with Thai basil and sliced chili, serve with jasmine rice.',
        duration: 180,
        tips: ['Add basil at the very end', 'Serve immediately with jasmine rice'],
        image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=400'
      }
    ]
  }
};

// FIXED: Culture to Mama personality mapping
const getCultureMamaPersonality = (culture: string) => {
  console.log('üé≠ Getting mama personality for culture:', culture);
  
  switch (culture) {
    case 'italian':
      console.log('üáÆüáπ Selected: nonna_lucia');
      return 'nonna_lucia';
    case 'mexican':
      console.log('üá≤üáΩ Selected: abuela_rosa');
      return 'abuela_rosa';
    case 'thai':
      console.log('üáπüá≠ Selected: mae_malai');
      return 'mae_malai';
    default:
      console.log('‚ùì Unknown culture, defaulting to: nonna_lucia');
      return 'nonna_lucia'; // Default fallback
  }
};

// Voice command suggestions for cooking mode
const voiceCommandSuggestions = [
  "Hey Nonna, next step",
  "Hey Nonna, repeat that",
  "Hey Nonna, go back",
  "Hey Nonna, set timer 5 minutes",
  "Hey Nonna, how much salt?",
  "Hey Nonna, what's next?",
  "Hey Nonna, help me",
  "Hey Nonna, ingredients",
  "Hey Nonna, is this done?",
  "Hey Nonna, what temperature?",
  "Hey Nonna, how long to cook?",
  "Hey Nonna, can I substitute?",
  "Hey Nonna, I'm stuck",
  "Hey Nonna, looks good?",
  "Hey Nonna, pause cooking"
];

interface ChatMessage {
  id: string;
  text: string;
  sender: 'user' | 'mama';
  timestamp: Date;
}

export default function CookingScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const recipeId = parseInt(params.recipeId as string);
  const recipe = recipeData[recipeId as keyof typeof recipeData];

  // FIXED: Get the correct mama personality from recipe culture
  const currentMama = recipe ? getCultureMamaPersonality(recipe.culture) : 'nonna_lucia';
  
  console.log('üé≠ Cooking screen initialized with:', {
    recipeId,
    recipeName: recipe?.name,
    culture: recipe?.culture,
    currentMama,
    chef: recipe?.chef
  });

  // Page state management
  const [cookingStarted, setCookingStarted] = useState(false);
  const [userName] = useState('Maria'); // This would come from user profile
  const [fullCookMode, setFullCookMode] = useState(true); // Toggle for extended conversation vs basic instructions

  // TRACK SPOKEN STEPS - Only speak each step once unless explicitly requested
  const [spokenSteps, setSpokenSteps] = useState<Set<number>>(new Set());

  // SIMPLIFIED AUDIO STATE MANAGEMENT - REMOVED PAUSE BETWEEN INTRO AND FIRST STEP
  const [audioSequenceState, setAudioSequenceState] = useState<'none' | 'welcome_playing' | 'welcome_done' | 'cooking_and_first_step_playing' | 'ready'>('none');

  // Waiting room state
  const [currentMessage, setCurrentMessage] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [showChat, setShowChat] = useState(false);
  const [chatHeight] = useState(new Animated.Value(0));

  // Cooking state management
  const [currentStep, setCurrentStep] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [completedSteps, setCompletedSteps] = useState<number[]>([]);
  const [activeTimers, setActiveTimers] = useState<Array<{id: string, name: string, duration: number, remaining: number}>>([]);
  const [voiceEnabled, setVoiceEnabled] = useState(true);
  const [showIngredients, setShowIngredients] = useState(false);
  const [voiceStatus, setVoiceStatus] = useState<OptimizedVoiceStatus>({
    state: 'idle',
    message: "üé§ Ready for voice commands",
    isPlaying: false
  });

  // Hooks
  const { cookingMode, startCookingMode, exitCookingMode } = useCookingMode();
  const { context, currentPrompt, recordActivity, dismissPrompt } = useCookingContext(
    currentStep, 
    recipe?.steps.length || 0, 
    activeTimers.length
  );

  // FIXED: Unified Chat Integration with culture-based mama selection
  const { 
    chatState, 
    sendMessage, 
    initializeChat, 
    switchContext, 
    updateRecipeProgress,
    isAvailable: isChatAvailable 
  } = useUnifiedChat(currentMama);

  // Animations
  const slideAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(1)).current;

  // SIMPLIFIED: Initialize with welcome message and audio ONLY
  useEffect(() => {
    if (recipe && !cookingStarted && chatState.messages.length === 0 && audioSequenceState === 'none') {
      console.log('üé¨ STARTING WELCOME SEQUENCE for', recipe.culture, 'recipe with', currentMama);

      // Initialize unified chat for pre-cooking
      initializeChat('pre_cooking', recipe);

      // Start welcome audio
      setAudioSequenceState('welcome_playing');
      const welcomeAudioText = `Welcome ${userName}! Today we cook my ${recipe.name}. I can't wait, tell me when you're ready.`;
      
      OptimizedVoiceService.processVoiceCommand(welcomeAudioText, {
        isWelcome: true,
        isDirectMessage: true,
        recipeName: recipe.name,
        chef: recipe.chef,
        userName: userName,
        priority: 'conversation',
        maxWords: 25,
        useExactText: true,
        currentMama: currentMama // FIXED: Pass correct mama personality
      });
    }
  }, [recipe, cookingStarted, chatState.messages.length, userName, audioSequenceState, initializeChat, currentMama]);

  // Monitor voice status to track audio sequence
  useEffect(() => {
    console.log('üéµ Voice status changed:', voiceStatus.state, 'Audio sequence:', audioSequenceState);

    // Track welcome audio completion
    if (audioSequenceState === 'welcome_playing' && voiceStatus.state === 'idle' && !voiceStatus.isPlaying) {
      console.log('‚úÖ Welcome audio finished');
      setAudioSequenceState('welcome_done');
    }

    // Track combined cooking intro + first step completion
    if (audioSequenceState === 'cooking_and_first_step_playing' && voiceStatus.state === 'idle' && !voiceStatus.isPlaying) {
      console.log('‚úÖ Combined cooking intro + first step finished');
      setAudioSequenceState('ready');
      // Mark first step as spoken
      setSpokenSteps(prev => new Set(prev).add(0));
    }
  }, [voiceStatus.state, voiceStatus.isPlaying, audioSequenceState]);

  // Set up voice status callback
  useEffect(() => {
    OptimizedVoiceService.setStatusCallback(setVoiceStatus);
    return () => {
      OptimizedVoiceService.setStatusCallback(() => {});
    };
  }, []);

  // Animate chat dropdown
  useEffect(() => {
    Animated.timing(chatHeight, {
      toValue: showChat ? 300 : 0,
      duration: 300,
      useNativeDriver: false,
    }).start();
  }, [showChat, chatHeight]);

  // Handle sending chat messages (UNIFIED)
  const sendChatMessage = async () => {
    if (!currentMessage.trim()) return;

    // Use unified chat system
    await sendMessage(currentMessage);
    setCurrentMessage('');
  };

  // Handle suggested prompts (UNIFIED)
  const handleSuggestedPrompt = async (prompt: string) => {
    await sendMessage(prompt);
  };

  // Handle voice messages (UNIFIED)
  const sendVoiceMessage = async (message: string) => {
    await sendMessage(message, { isVoice: true, maxWords: 15 });
  };

  // Toggle cook mode
  const toggleCookMode = () => {
    setFullCookMode(!fullCookMode);
  };

  // Toggle chat dropdown
  const toggleChat = () => {
    setShowChat(!showChat);
  };

  // UPDATED: Start cooking mode with COMBINED intro + first step (NO PAUSE)
  const handleStartCooking = () => {
    console.log('üî• STARTING COOKING MODE WITH COMBINED AUDIO for', recipe.culture, 'recipe with', currentMama);

    setCookingStarted(true);
    startCookingMode(true);
    
    // Switch unified chat to cooking context
    switchContext('cooking', recipe);
    
    // COMBINED AUDIO: Start cooking intro + first step in ONE audio sequence
    setAudioSequenceState('cooking_and_first_step_playing');
    
    // UPDATED: Combine intro and first step into ONE seamless audio
    const firstStep = recipe.steps[0];
    let combinedAudioText = `Ok let's start cooking! Step 1: ${firstStep.instruction}`;
    
    // Add Nonna's tips to the spoken audio (with emphasis) but don't show in UI
    if (fullCookMode && firstStep.tips && firstStep.tips.length > 0) {
      combinedAudioText += ` And here's my special tip: ${firstStep.tips[0]}`;
    }
    
    console.log('üé§ Triggering COMBINED cooking intro + first step with', currentMama, ':', combinedAudioText);
    
    OptimizedVoiceService.processVoiceCommand(combinedAudioText, {
      isCombinedCookingStart: true,
      isDirectMessage: true,
      recipeName: recipe.name,
      chef: recipe.chef,
      userName: userName,
      currentStep: 1,
      totalSteps: recipe.steps.length,
      currentInstruction: firstStep.instruction,
      cookMode: fullCookMode ? 'extended' : 'basic',
      priority: 'cooking',
      maxWords: 60, // Allow more words for combined message
      useExactText: true,
      currentMama: currentMama // FIXED: Pass correct mama personality
    });
  };

  // Update recipe progress in unified chat
  useEffect(() => {
    if (cookingStarted && recipe) {
      updateRecipeProgress(currentStep + 1, recipe.steps.length);
    }
  }, [currentStep, cookingStarted, recipe, updateRecipeProgress]);

  // FIXED: Handle step transitions with smart audio (only speak if not spoken before)
  const goToStep = (stepIndex: number, forceSpeak: boolean = false) => {
    if (stepIndex < 0 || stepIndex >= recipe.steps.length) return;
    
    recordActivity();
    
    Animated.sequence([
      Animated.timing(fadeAnim, {
        toValue: 0.3,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: stepIndex > currentStep ? -screenWidth : screenWidth,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start(() => {
      setCurrentStep(stepIndex);
      slideAnim.setValue(stepIndex > currentStep ? screenWidth : -screenWidth);
      
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    });

    // FIXED: Always speak step instructions for better cooking experience with correct mama
    if (voiceEnabled && (forceSpeak || !spokenSteps.has(stepIndex))) {
      const step = recipe.steps[stepIndex];
      
      // ENHANCED: Create better spoken instruction
      let spokenText = step.instruction;
      
      // Add tips to the spoken audio for full cook mode
      if (fullCookMode && step.tips && step.tips.length > 0) {
        spokenText += ` Here's my tip: ${step.tips[0]}`;
      }
      
      console.log('üé§ Speaking step', stepIndex + 1, 'with', currentMama, '- First time:', !spokenSteps.has(stepIndex), 'Forced:', forceSpeak);
      console.log('üé§ Full spoken text:', spokenText);
      
      // FIXED: Pass the correct mama personality to speakCookingInstruction
      OptimizedVoiceService.speakCookingInstruction(
        spokenText, 
        stepIndex + 1, 
        recipe.steps.length,
        currentMama // FIXED: Pass the correct mama personality
      );

      // Mark this step as spoken
      setSpokenSteps(prev => new Set(prev).add(stepIndex));
    } else if (voiceEnabled && spokenSteps.has(stepIndex) && !forceSpeak) {
      // Give subtle feedback that step was already spoken
      console.log('üîá Step', stepIndex + 1, 'already spoken - skipping audio');
    }
  };

  const nextStep = () => {
    if (currentStep < recipe.steps.length - 1) {
      goToStep(currentStep + 1, false); // Don't force speak - only speak if new
    }
  };

  const previousStep = () => {
    if (currentStep > 0) {
      goToStep(currentStep - 1, false); // Don't force speak - only speak if new
    }
  };

  // FIXED: Repeat current step audio with correct mama
  const repeatCurrentStep = () => {
    if (voiceEnabled) {
      const step = recipe.steps[currentStep];
      
      // ENHANCED: Create better repeat instruction
      let spokenText = `Let me repeat step ${currentStep + 1}: ${step.instruction}`;
      
      // Add tips for full cook mode
      if (fullCookMode && step.tips && step.tips.length > 0) {
        spokenText += ` Remember my tip: ${step.tips[0]}`;
      }
      
      console.log('üîÑ Repeating current step audio with', currentMama, ':', currentStep + 1);
      console.log('üîÑ Full repeat text:', spokenText);
      
      // FIXED: Pass the correct mama personality to speakCookingInstruction
      OptimizedVoiceService.speakCookingInstruction(
        spokenText, 
        currentStep + 1, 
        recipe.steps.length,
        currentMama // FIXED: Pass the correct mama personality
      );
    }
  };

  const toggleStepComplete = () => {
    const stepId = currentStep;
    const wasCompleted = completedSteps.includes(stepId);
    
    setCompletedSteps(prev => 
      prev.includes(stepId) 
        ? prev.filter(id => id !== stepId)
        : [...prev, stepId]
    );
    
    recordActivity();
    
    // If step was just completed (not uncompleted), auto-advance to next step
    if (!wasCompleted && currentStep < recipe.steps.length - 1) {
      console.log('‚úÖ Step completed, auto-advancing to next step');
      setTimeout(() => {
        nextStep();
      }, 1000); // 1 second delay for visual feedback
    }
  };

  // Timer management
  const startTimer = (name: string, duration: number) => {
    const timerId = Date.now().toString();
    const newTimer = {
      id: timerId,
      name,
      duration,
      remaining: duration
    };
    
    setActiveTimers(prev => [...prev, newTimer]);
    recordActivity();

    // Start countdown
    const interval = setInterval(() => {
      setActiveTimers(prev => {
        const updated = prev.map(timer => 
          timer.id === timerId 
            ? { ...timer, remaining: timer.remaining - 1 }
            : timer
        );
        
        const currentTimer = updated.find(t => t.id === timerId);
        if (currentTimer && currentTimer.remaining <= 0) {
          clearInterval(interval);
          
          // Timer finished - speak alert
          if (voiceEnabled) {
            OptimizedVoiceService.speakTimerAlert(name);
          }
          
          // Remove timer after alert
          setTimeout(() => {
            setActiveTimers(prev => prev.filter(t => t.id !== timerId));
          }, 3000);
        }
        
        return updated;
      });
    }, 1000);
  };

  const stopTimer = (timerId: string) => {
    setActiveTimers(prev => prev.filter(t => t.id !== timerId));
  };

  const stopAllTimers = () => {
    setActiveTimers([]);
  };

  // Voice command handling
  const handleVoiceCommand = (command: string, type: string) => {
    recordActivity();
    
    switch (type) {
      case 'navigation_next':
        nextStep();
        break;
      case 'navigation_previous':
        previousStep();
        break;
      case 'navigation_repeat':
        repeatCurrentStep();
        break;
      case 'timer':
        if (command.includes('timer')) {
          const timeMatch = command.match(/(\d+)/);
          const minutes = timeMatch ? parseInt(timeMatch[1]) : 5;
          startTimer(`Step ${currentStep + 1} Timer`, minutes * 60);
        }
        break;
      case 'control_help':
        if (voiceEnabled) {
          OptimizedVoiceService.handleEmergencyCommand('help me with cooking');
        }
        break;
    }
  };

  // FIXED: Handle photo upload with correct mama personality
  const handlePhotoUpload = () => {
    console.log('üì∏ Photo upload requested for', recipe.culture, 'recipe with', currentMama);
    
    // Mama says "ok ok, show me a photo" when user taps (ONLY this, no follow-up)
    if (voiceEnabled) {
      OptimizedVoiceService.processVoiceCommand("Ok ok, show me a photo!", {
        isPhotoRequest: true,
        isDirectMessage: true,
        priority: 'conversation',
        maxWords: 8,
        useExactText: true,
        currentMama: currentMama // FIXED: Pass correct mama personality
      });
    }
    
    // NO automatic follow-up response - just the initial acknowledgment
  };

  // Get voice status display
  const getVoiceStatusDisplay = () => {
    if (voiceStatus.isPlaying) {
      return {
        color: '#27AE60',
        icon: 'üîä',
        text: `${recipe?.chef.split(' ')[0]} speaking`,
        subtext: 'Tap to interrupt',
        showSoundBars: true
      };
    }
    
    if (voiceStatus.state === 'listening') {
      return {
        color: '#E67E22',
        icon: 'üé§',
        text: `${recipe?.chef.split(' ')[0]} listening`,
        subtext: 'Say your command',
        showPulse: true
      };
    }
    
    if (voiceStatus.state === 'processing') {
      return {
        color: '#F39C12',
        icon: 'ü§î',
        text: `${recipe?.chef.split(' ')[0]} thinking`,
        subtext: 'Processing request',
        showSpinner: true
      };
    }
    
    return {
      color: '#3498DB',
      icon: 'üí¨',
      text: `Say 'Hey ${recipe?.chef.split(' ')[0]}' or tap to speak`,
      subtext: 'Ready for your next question',
      showPulse: false
    };
  };

  // Handle voice toggle
  const handleVoiceToggle = () => {
    if (!voiceEnabled) return;

    // If audio is playing, stop it
    if (voiceStatus.isPlaying) {
      OptimizedVoiceService.interruptCurrentAudio();
      return;
    }

    // Otherwise, trigger a simple voice command with correct mama
    OptimizedVoiceService.processVoiceCommand(`Hey ${recipe?.chef.split(' ')[0]}, help me`, {
      priority: 'conversation',
      maxWords: 15,
      currentMama: currentMama // FIXED: Pass correct mama personality
    });
  };

  if (!recipe) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Recipe not found</Text>
        <TouchableOpacity onPress={() => router.back()}>
          <Text style={styles.backText}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Waiting Room Page (NOW WITH COMPACT WIREFRAME CHAT DESIGN + DROPDOWN)
  if (!cookingStarted) {
    return (
      <LinearGradient
        colors={['#F5E6D3', '#E8D5C4']}
        style={styles.container}
      >
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity 
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <ArrowLeft size={24} color="#8B4513" />
          </TouchableOpacity>
          
          <View style={styles.headerCenter}>
            <Text style={styles.headerTitle}>Mamia</Text>
          </View>

          <TouchableOpacity style={styles.settingsButton}>
            <Settings size={24} color="#8B4513" />
          </TouchableOpacity>
        </View>

        <ScrollView style={styles.waitingContent} showsVerticalScrollIndicator={false}>
          {/* Recipe Header */}
          <View style={styles.waitingRecipeHeader}>
            <View style={styles.recipeHeaderContent}>
              <View style={styles.recipeHeaderLeft}>
                <Text style={styles.waitingRecipeName}>{recipe.name}</Text>
                <View style={styles.chefInfo}>
                  <Text style={styles.chefAvatar}>{recipe.chefAvatar}</Text>
                  <Text style={styles.chefName}>{recipe.chef}</Text>
                </View>
              </View>
            </View>
          </View>

          {/* Recipe Image */}
          <View style={styles.recipeImageContainer}>
            <Image source={{ uri: recipe.image }} style={styles.waitingRecipeImage} />
            <LinearGradient
              colors={['transparent', 'rgba(0,0,0,0.3)']}
              style={styles.imageOverlay}
            >
              <Text style={styles.imageOverlayText}>Image of Food being made</Text>
            </LinearGradient>
          </View>

          {/* Start Cooking Button */}
          <TouchableOpacity 
            style={styles.startCookingButton}
            onPress={handleStartCooking}
          >
            <LinearGradient
              colors={['#E67E22', '#D35400']}
              style={styles.startCookingGradient}
            >
              <Play size={20} color="white" />
              <Text style={styles.startCookingText}>Start Cooking</Text>
            </LinearGradient>
          </TouchableOpacity>

          {/* Full Cook Mode Toggle */}
          <TouchableOpacity 
            style={styles.cookModeContainer}
            onPress={toggleCookMode}
          >
            <View style={styles.cookModeHeader}>
              <Text style={styles.cookModeLabel}>Full Cook Mode:</Text>
              <View style={styles.toggleContainer}>
                {fullCookMode ? (
                  <ToggleRight size={24} color="#27AE60" />
                ) : (
                  <ToggleLeft size={24} color="#8B4513" />
                )}
              </View>
            </View>
            <Text style={styles.cookModeDescription}>
              {fullCookMode 
                ? `Extended conversation and detailed tips from ${recipe.chef.split(' ')[0]}` 
                : "Basic instructions only"
              }
            </Text>
            <Text style={styles.cookModeHint}>Tap to toggle</Text>
          </TouchableOpacity>

          {/* COMPACT WIREFRAME-STYLE CHAT SECTION - Pre-Cooking Troubleshooting Specialty */}
          <View style={styles.chatSection}>
            <TouchableOpacity 
              style={styles.compactChatCard}
              onPress={toggleChat}
            >
              <LinearGradient
                colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.85)']}
                style={styles.compactChatGradient}
              >
                <View style={styles.compactChatContent}>
                  <View style={styles.compactChatIcons}>
                    <View style={styles.compactPhoneEmoji}>
                      <Text style={styles.compactEmojiText}>üì±</Text>
                    </View>
                    <View style={styles.compactMamaEmoji}>
                      <Text style={styles.compactEmojiText}>{recipe.chefAvatar}</Text>
                    </View>
                  </View>
                  <View style={styles.compactChatText}>
                    <Text style={styles.compactChatTitle}>Text {recipe.chef.split(' ')[0]}!</Text>
                    <Text style={styles.compactChatSubtitle}>{recipe.chef.split(' ')[0]} is here to help</Text>
                  </View>
                  <View style={styles.chatToggleIcon}>
                    {showChat ? (
                      <ChevronUp size={20} color="#8B4513" />
                    ) : (
                      <ChevronDown size={20} color="#8B4513" />
                    )}
                  </View>
                </View>
              </LinearGradient>
            </TouchableOpacity>

            <Animated.View style={[styles.chatDropdown, { height: chatHeight }]}>
              <View style={styles.chatContainer}>
                <ScrollView style={styles.chatMessages} showsVerticalScrollIndicator={false}>
                  {/* Show unified chat messages */}
                  {chatState.messages.map((message) => (
                    <View 
                      key={message.id} 
                      style={[
                        styles.messageContainer,
                        message.sender === 'user' ? styles.userMessage : styles.mamaMessage
                      ]}
                    >
                      {message.sender === 'mama' && (
                        <Text style={styles.messageAvatar}>{recipe.chefAvatar}</Text>
                      )}
                      <View style={[
                        styles.messageBubble,
                        message.sender === 'user' ? styles.userBubble : styles.mamaBubble
                      ]}>
                        <Text style={[
                          styles.messageText,
                          message.sender === 'user' ? styles.userMessageText : styles.mamaMessageText
                        ]}>
                          {message.text}
                        </Text>
                        {message.responseTime && (
                          <Text style={styles.responseTime}>
                            {message.source === 'template' ? '‚ö°' : 'ü§ñ'} {message.responseTime}ms
                          </Text>
                        )}
                      </View>
                    </View>
                  ))}
                  
                  {chatState.isTyping && (
                    <View style={[styles.messageContainer, styles.mamaMessage]}>
                      <Text style={styles.messageAvatar}>{recipe.chefAvatar}</Text>
                      <View style={[styles.messageBubble, styles.mamaBubble]}>
                        <Text style={styles.typingIndicator}>...</Text>
                      </View>
                    </View>
                  )}
                </ScrollView>
                
                <KeyboardAvoidingView 
                  behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                  style={styles.chatInputContainer}
                >
                  <TextInput
                    style={styles.chatInput}
                    value={currentMessage}
                    onChangeText={setCurrentMessage}
                    placeholder="Do you need help substituting an ingredient?"
                    placeholderTextColor="#A0522D"
                    multiline
                    maxLength={200}
                  />
                  <TouchableOpacity 
                    style={styles.sendButton}
                    onPress={sendChatMessage}
                    disabled={!currentMessage.trim()}
                  >
                    <Send size={20} color={currentMessage.trim() ? "#8B4513" : "#CCC"} />
                  </TouchableOpacity>
                </KeyboardAvoidingView>
              </View>
            </Animated.View>
          </View>
        </ScrollView>
      </LinearGradient>
    );
  }

  // COOKING MODE PAGE - Clean Kitchen-Friendly UX
  const currentStepData = recipe.steps[currentStep];
  const progress = ((currentStep + 1) / recipe.steps.length) * 100;
  const voiceDisplay = getVoiceStatusDisplay();

  return (
    <LinearGradient
      colors={['#F5E6D3', '#E8D5C4']}
      style={styles.container}
    >
      {/* Contextual Prompts */}
      {currentPrompt && (
        <ContextualPrompt
          prompt={currentPrompt}
          onDismiss={dismissPrompt}
        />
      )}

      {/* CLEAN HEADER SECTION */}
      <View style={styles.cleanHeader}>
        <TouchableOpacity 
          style={styles.cleanBackButton}
          onPress={() => router.back()}
        >
          <ArrowLeft size={24} color="#8B4513" />
        </TouchableOpacity>
        
        <Text style={styles.cleanHeaderTitle}>Cooking Mode</Text>

        <TouchableOpacity style={styles.cleanSettingsButton}>
          <Settings size={24} color="#8B4513" />
        </TouchableOpacity>
      </View>

      {/* CLEAN PROGRESS BAR - Single Line */}
      <View style={styles.cleanProgressContainer}>
        <View style={styles.cleanProgressBar}>
          <View style={[styles.cleanProgressFill, { width: `${progress}%` }]} />
        </View>
        <Text style={styles.cleanProgressText}>
          Step {currentStep + 1} of {recipe.steps.length}
        </Text>
      </View>

      <ScrollView style={styles.cleanContent} showsVerticalScrollIndicator={false}>
        {/* 1. CURRENT STEP CARD - Top Priority (NO STEP COUNTER, MOVED COMPLETE BUTTON) */}
        <Animated.View 
          style={[
            styles.cleanStepCard,
            {
              transform: [{ translateX: slideAnim }],
              opacity: fadeAnim,
            }
          ]}
        >
          {/* ONLY show the basic instruction - NO TIPS in UI, NO STEP COUNTER */}
          <Text style={styles.cleanStepInstruction}>{currentStepData.instruction}</Text>
          
          {/* MOVED: Complete button to bottom right */}
          <TouchableOpacity 
            style={styles.cleanCompleteButtonBottomRight}
            onPress={toggleStepComplete}
          >
            {completedSteps.includes(currentStep) ? (
              <CheckCircle size={28} color="#27AE60" />
            ) : (
              <Circle size={28} color="#8B4513" />
            )}
          </TouchableOpacity>
          
          {/* Tips are ONLY spoken by Mama, never displayed in UI for authenticity */}
        </Animated.View>

        {/* RESTORED: Voice Command Suggestions */}
        <View style={styles.voiceCommandSuggestions}>
          <Text style={styles.suggestionsTitle}>Voice Commands</Text>
          <ScrollView horizontal showsHorizontalScrollIndicator={false}>
            <View style={styles.suggestionsList}>
              {voiceCommandSuggestions.slice(0, 12).map((suggestion, index) => (
                <TouchableOpacity
                  key={index}
                  style={styles.suggestionChip}
                  onPress={() => sendVoiceMessage(suggestion)}
                >
                  <Text style={styles.suggestionText}>
                    {suggestion.replace('Hey Nonna, ', '')}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </ScrollView>
        </View>

        {/* 3. UPDATED QUICK ACTIONS - Previous, Repeat, Next */}
        <View style={styles.cleanQuickActions}>
          <TouchableOpacity 
            style={[styles.cleanActionButton, currentStep === 0 && styles.cleanActionButtonDisabled]}
            onPress={previousStep}
            disabled={currentStep === 0}
          >
            <SkipBack size={20} color={currentStep === 0 ? "#CCC" : "#8B4513"} />
            <Text style={[styles.cleanActionText, currentStep === 0 && styles.cleanActionTextDisabled]}>
              Previous
            </Text>
          </TouchableOpacity>

          {/* CHANGED: Repeat button instead of "What's next" */}
          <TouchableOpacity 
            style={styles.cleanRepeatButton}
            onPress={repeatCurrentStep}
          >
            <RotateCcw size={20} color="white" />
            <Text style={styles.cleanRepeatText}>Repeat</Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[styles.cleanActionButton, currentStep === recipe.steps.length - 1 && styles.cleanActionButtonDisabled]}
            onPress={nextStep}
            disabled={currentStep === recipe.steps.length - 1}
          >
            <SkipForward size={20} color={currentStep === recipe.steps.length - 1 ? "#CCC" : "#8B4513"} />
            <Text style={[styles.cleanActionText, currentStep === recipe.steps.length - 1 && styles.cleanActionTextDisabled]}>
              Next
            </Text>
          </TouchableOpacity>
        </View>

        {/* 4. ACTIVE TIMERS - Only when running */}
        {activeTimers.length > 0 && (
          <View style={styles.cleanTimersContainer}>
            <View style={styles.cleanTimersHeader}>
              <Text style={styles.cleanTimersTitle}>Active Timers</Text>
              <TouchableOpacity 
                style={styles.cleanStopAllButton}
                onPress={stopAllTimers}
              >
                <Square size={16} color="#E74C3C" />
                <Text style={styles.cleanStopAllText}>Stop All</Text>
              </TouchableOpacity>
            </View>
            
            {activeTimers.map(timer => (
              <View key={timer.id} style={styles.cleanTimerCard}>
                <Timer size={20} color="#E67E22" />
                <Text style={styles.cleanTimerName}>{timer.name}</Text>
                <Text style={styles.cleanTimerTime}>
                  {Math.floor(timer.remaining / 60)}:{(timer.remaining % 60).toString().padStart(2, '0')}
                </Text>
                <TouchableOpacity 
                  style={styles.cleanTimerStop}
                  onPress={() => stopTimer(timer.id)}
                >
                  <Square size={16} color="#E74C3C" />
                </TouchableOpacity>
              </View>
            ))}
          </View>
        )}

        {/* PHOTO UPLOAD - Show Mama Your Progress */}
        <TouchableOpacity 
          style={styles.photoUploadContainer}
          onPress={handlePhotoUpload}
        >
          <LinearGradient
            colors={['#E67E22', '#D35400']}
            style={styles.photoUploadGradient}
          >
            <View style={styles.photoUploadContent}>
              <Camera size={28} color="white" />
              <View style={styles.photoUploadTextContainer}>
                <Text style={styles.photoUploadTitle}>Show {recipe.chef.split(' ')[0]} your progress</Text>
                <Text style={styles.photoUploadSubtitle}>
                  Upload a photo if you're stuck on a step or want to show {recipe.chef.split(' ')[0]} your finished dish
                </Text>
              </View>
            </View>
          </LinearGradient>
        </TouchableOpacity>

        {/* ADDED: Chat Dropdown in Cooking Mode */}
        <View style={styles.cookingChatSection}>
          <TouchableOpacity 
            style={styles.compactChatCard}
            onPress={toggleChat}
          >
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.85)']}
              style={styles.compactChatGradient}
            >
              <View style={styles.compactChatContent}>
                <View style={styles.compactChatIcons}>
                  <View style={styles.compactPhoneEmoji}>
                    <Text style={styles.compactEmojiText}>üì±</Text>
                  </View>
                  <View style={styles.compactMamaEmoji}>
                    <Text style={styles.compactEmojiText}>{recipe.chefAvatar}</Text>
                  </View>
                </View>
                <View style={styles.compactChatText}>
                  <Text style={styles.compactChatTitle}>Text {recipe.chef.split(' ')[0]}!</Text>
                  <Text style={styles.compactChatSubtitle}>{recipe.chef.split(' ')[0]} is here to help</Text>
                </View>
                <View style={styles.chatToggleIcon}>
                  {showChat ? (
                    <ChevronUp size={20} color="#8B4513" />
                  ) : (
                    <ChevronDown size={20} color="#8B4513" />
                  )}
                </View>
              </View>
            </LinearGradient>
          </TouchableOpacity>

          <Animated.View style={[styles.chatDropdown, { height: chatHeight }]}>
            <View style={styles.chatContainer}>
              <ScrollView style={styles.chatMessages} showsVerticalScrollIndicator={false}>
                {/* Show unified chat messages */}
                {chatState.messages.map((message) => (
                  <View 
                    key={message.id} 
                    style={[
                      styles.messageContainer,
                      message.sender === 'user' ? styles.userMessage : styles.mamaMessage
                    ]}
                  >
                    {message.sender === 'mama' && (
                      <Text style={styles.messageAvatar}>{recipe.chefAvatar}</Text>
                    )}
                    <View style={[
                      styles.messageBubble,
                      message.sender === 'user' ? styles.userBubble : styles.mamaBubble
                    ]}>
                      <Text style={[
                        styles.messageText,
                        message.sender === 'user' ? styles.userMessageText : styles.mamaMessageText
                      ]}>
                        {message.text}
                      </Text>
                      {message.responseTime && (
                        <Text style={styles.responseTime}>
                          {message.source === 'template' ? '‚ö°' : 'ü§ñ'} {message.responseTime}ms
                        </Text>
                      )}
                    </View>
                  </View>
                ))}
                
                {chatState.isTyping && (
                  <View style={[styles.messageContainer, styles.mamaMessage]}>
                    <Text style={styles.messageAvatar}>{recipe.chefAvatar}</Text>
                    <View style={[styles.messageBubble, styles.mamaBubble]}>
                      <Text style={styles.typingIndicator}>...</Text>
                    </View>
                  </View>
                )}
              </ScrollView>
              
              <KeyboardAvoidingView 
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                style={styles.chatInputContainer}
              >
                <TextInput
                  style={styles.chatInput}
                  value={currentMessage}
                  onChangeText={setCurrentMessage}
                  placeholder={`Ask ${recipe.chef.split(' ')[0]} about this step...`}
                  placeholderTextColor="#A0522D"
                  multiline
                  maxLength={200}
                />
                <TouchableOpacity 
                  style={styles.sendButton}
                  onPress={sendChatMessage}
                  disabled={!currentMessage.trim()}
                >
                  <Send size={20} color={currentMessage.trim() ? "#8B4513" : "#CCC"} />
                </TouchableOpacity>
              </KeyboardAvoidingView>
            </View>
          </Animated.View>
        </View>
      </ScrollView>

      {/* RESTORED BETTER VOICE TAB DESIGN - Fixed at Bottom */}
      <View style={styles.voiceInterfaceContainer}>
        <TouchableOpacity 
          style={styles.voiceTab}
          onPress={handleVoiceToggle}
        >
          <LinearGradient
            colors={['#3498DB', '#2980B9']}
            style={styles.voiceTabGradient}
          >
            <View style={styles.voiceTabContent}>
              <Text style={styles.voiceTabMainText}>{voiceDisplay.text}</Text>
              <Text style={styles.voiceTabSubText}>{voiceDisplay.subtext}</Text>
            </View>
          </LinearGradient>
        </TouchableOpacity>
      </View>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    fontSize: 18,
    color: '#E74C3C',
    marginBottom: 20,
  },
  backText: {
    fontSize: 16,
    color: '#3498DB',
    textDecorationLine: 'underline',
  },

  // WAITING ROOM STYLES (UPDATED WITH COMPACT WIREFRAME CHAT)
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  backButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255,255,255,0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerCenter: {
    flex: 1,
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#8B4513',
  },
  settingsButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255,255,255,0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  waitingContent: {
    flex: 1,
    paddingHorizontal: 20,
  },
  waitingRecipeHeader: {
    backgroundColor: 'rgba(255,255,255,0.9)',
    borderRadius: 15,
    padding: 15,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.1)',
  },
  recipeHeaderContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  recipeHeaderLeft: {
    flex: 1,
  },
  waitingRecipeName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#8B4513',
    marginBottom: 8,
  },
  chefInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  chefAvatar: {
    fontSize: 20,
  },
  chefName: {
    fontSize: 14,
    color: '#8B4513',
    fontWeight: '500',
  },
  recipeImageContainer: {
    height: 200,
    borderRadius: 15,
    overflow: 'hidden',
    marginBottom: 20,
    position: 'relative',
  },
  waitingRecipeImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  imageOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 60,
    justifyContent: 'flex-end',
    padding: 15,
  },
  imageOverlayText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '500',
  },
  startCookingButton: {
    borderRadius: 25,
    overflow: 'hidden',
    marginBottom: 20,
    elevation: 4,
    shadowColor: '#E67E22',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
  },
  startCookingGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 15,
    gap: 10,
  },
  startCookingText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  cookModeContainer: {
    backgroundColor: 'rgba(255,255,255,0.9)',
    borderRadius: 15,
    padding: 15,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.1)',
  },
  cookModeHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  cookModeLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#8B4513',
  },
  toggleContainer: {
    padding: 2,
  },
  cookModeDescription: {
    fontSize: 14,
    color: '#6B3410',
    marginBottom: 5,
  },
  cookModeHint: {
    fontSize: 12,
    color: '#A0522D',
    fontStyle: 'italic',
  },

  // COMPACT WIREFRAME-STYLE CHAT SECTION - MATCHES WIREFRAME EXACTLY
  chatSection: {
    marginBottom: 20,
  },
  cookingChatSection: {
    marginBottom: 25,
  },
  compactChatCard: {
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.3)',
  },
  compactChatGradient: {
    paddingVertical: 16,
    paddingHorizontal: 20,
  },
  compactChatContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 15,
  },
  compactChatIcons: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  compactPhoneEmoji: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'rgba(139, 69, 19, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.25)',
  },
  compactMamaEmoji: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'rgba(139, 69, 19, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.25)',
  },
  compactEmojiText: {
    fontSize: 24,
  },
  compactChatText: {
    flex: 1,
  },
  compactChatTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#8B4513',
    marginBottom: 2,
    letterSpacing: 0.3,
  },
  compactChatSubtitle: {
    fontSize: 14,
    color: '#6B3410',
    fontWeight: '500',
  },
  chatToggleIcon: {
    padding: 4,
  },

  // Chat Dropdown Animation
  chatDropdown: {
    overflow: 'hidden',
    marginTop: 12,
  },
  chatContainer: {
    backgroundColor: 'rgba(255,255,255,0.95)',
    borderRadius: 18,
    height: 300,
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.2)',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
  },
  chatMessages: {
    flex: 1,
    padding: 16,
  },
  messageContainer: {
    flexDirection: 'row',
    marginBottom: 12,
    alignItems: 'flex-end',
  },
  userMessage: {
    justifyContent: 'flex-end',
  },
  mamaMessage: {
    justifyContent: 'flex-start',
  },
  messageAvatar: {
    fontSize: 16,
    marginRight: 8,
    marginBottom: 2,
  },
  messageBubble: {
    maxWidth: '80%',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
  },
  userBubble: {
    backgroundColor: '#8B4513',
    borderBottomRightRadius: 4,
  },
  mamaBubble: {
    backgroundColor: '#F5F5F5',
    borderBottomLeftRadius: 4,
  },
  messageText: {
    fontSize: 14,
    lineHeight: 18,
  },
  userMessageText: {
    color: 'white',
  },
  mamaMessageText: {
    color: '#333',
  },
  responseTime: {
    fontSize: 10,
    color: '#666',
    marginTop: 3,
    fontStyle: 'italic',
  },
  typingIndicator: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  chatInputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(139, 69, 19, 0.1)',
    gap: 10,
  },
  chatInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
    borderRadius: 20,
    paddingHorizontal: 15,
    paddingVertical: 10,
    fontSize: 14,
    color: '#333',
    maxHeight: 70,
    backgroundColor: 'white',
  },
  sendButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(139, 69, 19, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
  },

  // CLEAN COOKING MODE STYLES
  cleanHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 15,
  },
  cleanBackButton: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: 'rgba(255,255,255,0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  cleanHeaderTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#8B4513',
  },
  cleanSettingsButton: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: 'rgba(255,255,255,0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },

  // Clean Progress Bar - Single Line
  cleanProgressContainer: {
    paddingHorizontal: 20,
    marginBottom: 25,
  },
  cleanProgressBar: {
    height: 8,
    backgroundColor: 'rgba(139, 69, 19, 0.2)',
    borderRadius: 4,
    marginBottom: 10,
  },
  cleanProgressFill: {
    height: '100%',
    backgroundColor: '#E67E22',
    borderRadius: 4,
  },
  cleanProgressText: {
    fontSize: 16,
    color: '#8B4513',
    textAlign: 'center',
    fontWeight: '600',
  },

  cleanContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingBottom: 100, // Space for voice interface
  },

  // 1. Current Step Card - UPDATED: No step counter, moved complete button
  cleanStepCard: {
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 25,
    marginBottom: 25,
    elevation: 4,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    borderLeftWidth: 6,
    borderLeftColor: '#E67E22',
    position: 'relative',
  },
  cleanStepInstruction: {
    fontSize: 20,
    color: '#2C3E50',
    lineHeight: 28,
    fontWeight: '500',
    paddingRight: 50, // Space for complete button
  },
  // MOVED: Complete button to bottom right
  cleanCompleteButtonBottomRight: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    padding: 8,
  },

  // RESTORED: Voice Command Suggestions
  voiceCommandSuggestions: {
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 15,
    marginBottom: 25,
    elevation: 2,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  suggestionsTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#8B4513',
    marginBottom: 12,
  },
  suggestionsList: {
    flexDirection: 'row',
    gap: 10,
  },
  suggestionChip: {
    backgroundColor: 'rgba(139, 69, 19, 0.1)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
  },
  suggestionText: {
    fontSize: 12,
    color: '#8B4513',
    fontWeight: '500',
  },

  // 3. UPDATED QUICK ACTIONS - Previous, Repeat, Next
  cleanQuickActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 25,
    gap: 15,
  },
  cleanActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    paddingHorizontal: 20,
    paddingVertical: 15,
    borderRadius: 25,
    gap: 8,
    elevation: 2,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    minHeight: 60,
  },
  cleanActionButtonDisabled: {
    backgroundColor: '#F5F5F5',
    elevation: 1,
  },
  cleanActionText: {
    fontSize: 16,
    color: '#8B4513',
    fontWeight: '600',
  },
  cleanActionTextDisabled: {
    color: '#CCC',
  },
  // NEW: Repeat button styling
  cleanRepeatButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#E67E22',
    paddingHorizontal: 20,
    paddingVertical: 15,
    borderRadius: 25,
    gap: 8,
    elevation: 3,
    shadowColor: '#E67E22',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    minHeight: 60,
    justifyContent: 'center',
  },
  cleanRepeatText: {
    fontSize: 16,
    color: 'white',
    fontWeight: '600',
  },

  // 4. ACTIVE TIMERS - Only when running
  cleanTimersContainer: {
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 20,
    marginBottom: 25,
    elevation: 3,
    shadowColor: '#E67E22',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 6,
    borderLeftWidth: 4,
    borderLeftColor: '#E67E22',
  },
  cleanTimersHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  cleanTimersTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#E67E22',
  },
  cleanStopAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(231, 76, 60, 0.1)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 15,
    gap: 6,
  },
  cleanStopAllText: {
    fontSize: 12,
    color: '#E74C3C',
    fontWeight: '600',
  },
  cleanTimerCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(230, 126, 34, 0.08)',
    padding: 15,
    borderRadius: 12,
    marginBottom: 10,
    gap: 12,
  },
  cleanTimerName: {
    flex: 1,
    fontSize: 16,
    color: '#2C3E50',
    fontWeight: '500',
  },
  cleanTimerTime: {
    fontSize: 20,
    color: '#E67E22',
    fontWeight: 'bold',
    fontFamily: 'monospace',
  },
  cleanTimerStop: {
    padding: 8,
    backgroundColor: 'rgba(231, 76, 60, 0.1)',
    borderRadius: 8,
  },

  // Photo Upload - Show Mama Your Progress
  photoUploadContainer: {
    borderRadius: 20,
    overflow: 'hidden',
    marginBottom: 25,
    elevation: 4,
    shadowColor: '#E67E22',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
  },
  photoUploadGradient: {
    padding: 20,
  },
  photoUploadContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 15,
  },
  photoUploadTextContainer: {
    flex: 1,
  },
  photoUploadTitle: {
    fontSize: 18,
    color: 'white',
    fontWeight: 'bold',
    marginBottom: 8,
  },
  photoUploadSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
    lineHeight: 20,
  },

  // RESTORED BETTER VOICE TAB DESIGN - Fixed at Bottom
  voiceInterfaceContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    paddingHorizontal: 20,
    paddingVertical: 15,
    backgroundColor: 'rgba(245, 230, 211, 0.95)',
    borderTopWidth: 1,
    borderTopColor: 'rgba(139, 69, 19, 0.1)',
  },
  voiceTab: {
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
  },
  voiceTabGradient: {
    paddingVertical: 18,
    paddingHorizontal: 25,
  },
  voiceTabContent: {
    alignItems: 'center',
    gap: 4,
  },
  voiceTabMainText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: 'white',
    textAlign: 'center',
  },
  voiceTabSubText: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
    textAlign: 'center',
    fontStyle: 'italic',
  },
});
</file>

<file path="app/(tabs)/favourites.tsx/favourites.tsx">
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, Image } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import { 
  Heart, 
  Clock, 
  Star, 
  ChefHat, 
  Search,
  Filter,
  Users
} from 'lucide-react-native';

const favouriteRecipes = {
  italian: [
    {
      id: 1,
      name: 'Classic Carbonara',
      image: 'https://i.imgur.com/UWR05kt.jpg',
      time: '25 min',
      rating: 4.8,
      difficulty: 2,
      servings: 4,
      chef: 'Nonna Lucia',
      description: 'Authentic Roman pasta with eggs, cheese, and pancetta',
      dateAdded: '2024-01-15',
    },
    {
      id: 2,
      name: 'Nonna\'s Minestrone',
      image: 'https://i.imgur.com/zj23RzP.jpg',
      time: '45 min',
      rating: 4.9,
      difficulty: 1,
      servings: 6,
      chef: 'Nonna Lucia',
      description: 'Hearty Italian vegetable soup with seasonal ingredients',
      dateAdded: '2024-01-12',
    },
    {
      id: 7,
      name: 'Risotto alla Milanese',
      image: 'https://images.pexels.com/photos/1586942/pexels-photo-1586942.jpeg?auto=compress&cs=tinysrgb&w=600',
      time: '40 min',
      rating: 4.7,
      difficulty: 3,
      servings: 4,
      chef: 'Nonna Lucia',
      description: 'Creamy saffron risotto from Northern Italy',
      dateAdded: '2024-01-10',
    },
  ],
  mexican: [
    {
      id: 3,
      name: 'Tacos al Pastor',
      image: 'https://i.imgur.com/5M5owi4.jpg',
      time: '2 hours',
      rating: 4.7,
      difficulty: 3,
      servings: 8,
      chef: 'Abuela Rosa',
      description: 'Traditional Mexican tacos with marinated pork and pineapple',
      dateAdded: '2024-01-14',
    },
    {
      id: 5,
      name: 'Mole Poblano',
      image: 'https://i.imgur.com/lomAygP.jpg',
      time: '3 hours',
      rating: 4.9,
      difficulty: 3,
      servings: 6,
      chef: 'Abuela Rosa',
      description: 'Complex sauce with chocolate and chilies',
      dateAdded: '2024-01-08',
    },
  ],
  thai: [
    {
      id: 4,
      name: 'Green Curry',
      image: 'https://i.imgur.com/ORMJpqJ.jpg',
      time: '35 min',
      rating: 4.6,
      difficulty: 2,
      servings: 4,
      chef: 'Mae Malai',
      description: 'Aromatic Thai curry with coconut milk and fresh herbs',
      dateAdded: '2024-01-11',
    },
    {
      id: 6,
      name: 'Pad Thai',
      image: 'https://i.imgur.com/QguqAzq.jpg',
      time: '20 min',
      rating: 4.5,
      difficulty: 2,
      servings: 2,
      chef: 'Mae Malai',
      description: 'Classic Thai stir-fried noodles with tamarind and fish sauce',
      dateAdded: '2024-01-09',
    },
  ],
};

const cuisineThemes = {
  italian: {
    colors: ['#E67E22', '#D35400'],
    bgColors: ['#FFF8E1', '#FFE0B2'],
    accentColor: '#C0392B',
    flag: 'üáÆüáπ',
    pattern: 'üçÖüåø',
  },
  mexican: {
    colors: ['#27AE60', '#229954'],
    bgColors: ['#E8F8F5', '#D5F4E6'],
    accentColor: '#E74C3C',
    flag: 'üá≤üáΩ',
    pattern: 'üå∂Ô∏èüíÄ',
  },
  thai: {
    colors: ['#F39C12', '#E67E22'],
    bgColors: ['#FEF9E7', '#FCF3CF'],
    accentColor: '#D68910',
    flag: 'üáπüá≠',
    pattern: 'üå∏üçÉ',
  },
};

const sortOptions = ['Recently Added', 'Rating', 'Cooking Time', 'Alphabetical'];

export default function FavouritesScreen() {
  const router = useRouter();
  const [selectedCuisine, setSelectedCuisine] = useState<string | null>(null);
  const [sortBy, setSortBy] = useState('Recently Added');
  const [showSortOptions, setShowSortOptions] = useState(false);

  const getDifficultyHats = (difficulty: number) => {
    return Array(3).fill(0).map((_, index) => (
      <ChefHat 
        key={index} 
        size={14} 
        color={index < difficulty ? '#8B4513' : '#DDD'} 
      />
    ));
  };

  const sortRecipes = (recipes: any[]) => {
    switch (sortBy) {
      case 'Rating':
        return [...recipes].sort((a, b) => b.rating - a.rating);
      case 'Cooking Time':
        return [...recipes].sort((a, b) => parseInt(a.time) - parseInt(b.time));
      case 'Alphabetical':
        return [...recipes].sort((a, b) => a.name.localeCompare(b.name));
      case 'Recently Added':
      default:
        return [...recipes].sort((a, b) => new Date(b.dateAdded).getTime() - new Date(a.dateAdded).getTime());
    }
  };

  const getAllFavourites = () => {
    const allRecipes = [
      ...favouriteRecipes.italian.map(r => ({ ...r, cuisine: 'italian' })),
      ...favouriteRecipes.mexican.map(r => ({ ...r, cuisine: 'mexican' })),
      ...favouriteRecipes.thai.map(r => ({ ...r, cuisine: 'thai' })),
    ];
    return sortRecipes(allRecipes);
  };

  const getFilteredRecipes = () => {
    if (selectedCuisine) {
      return sortRecipes(favouriteRecipes[selectedCuisine as keyof typeof favouriteRecipes]);
    }
    return getAllFavourites();
  };

  const totalFavourites = Object.values(favouriteRecipes).flat().length;

  return (
    <LinearGradient
      colors={['#F5E6D3', '#E8D5C4']}
      style={styles.container}
    >
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.headerTop}>
            <Text style={styles.headerTitle}>My Favourites</Text>
            <TouchableOpacity style={styles.searchButton}>
              <Search size={24} color="#8B4513" />
            </TouchableOpacity>
          </View>
          <Text style={styles.headerSubtitle}>
            {totalFavourites} saved recipe{totalFavourites !== 1 ? 's' : ''} from around the world
          </Text>
        </View>

        {/* Cuisine Filter Tabs */}
        <View style={styles.cuisineFilters}>
          <ScrollView horizontal showsHorizontalScrollIndicator={false}>
            <View style={styles.filterTabs}>
              <TouchableOpacity
                style={[
                  styles.filterTab,
                  !selectedCuisine && styles.activeFilterTab
                ]}
                onPress={() => setSelectedCuisine(null)}
              >
                <Text style={styles.filterTabIcon}>üåç</Text>
                <Text style={[
                  styles.filterTabText,
                  !selectedCuisine && styles.activeFilterTabText
                ]}>
                  All
                </Text>
              </TouchableOpacity>

              {Object.entries(cuisineThemes).map(([cuisine, theme]) => (
                <TouchableOpacity
                  key={cuisine}
                  style={[
                    styles.filterTab,
                    selectedCuisine === cuisine && styles.activeFilterTab
                  ]}
                  onPress={() => setSelectedCuisine(cuisine)}
                >
                  <Text style={styles.filterTabIcon}>{theme.flag}</Text>
                  <Text style={[
                    styles.filterTabText,
                    selectedCuisine === cuisine && styles.activeFilterTabText
                  ]}>
                    {cuisine.charAt(0).toUpperCase() + cuisine.slice(1)}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </ScrollView>
        </View>

        {/* Sort and Filter Controls */}
        <View style={styles.controlsContainer}>
          <TouchableOpacity 
            style={styles.sortButton}
            onPress={() => setShowSortOptions(!showSortOptions)}
          >
            <Filter size={16} color="#8B4513" />
            <Text style={styles.sortButtonText}>Sort: {sortBy}</Text>
          </TouchableOpacity>
        </View>

        {showSortOptions && (
          <View style={styles.sortOptionsContainer}>
            {sortOptions.map((option) => (
              <TouchableOpacity
                key={option}
                style={[
                  styles.sortOption,
                  sortBy === option && styles.activeSortOption
                ]}
                onPress={() => {
                  setSortBy(option);
                  setShowSortOptions(false);
                }}
              >
                <Text style={[
                  styles.sortOptionText,
                  sortBy === option && styles.activeSortOptionText
                ]}>
                  {option}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        )}

        {/* Recipes Grid */}
        {selectedCuisine ? (
          // Single cuisine view
          <View style={styles.cuisineSection}>
            <View style={styles.cuisineSectionHeader}>
              <Text style={styles.cuisineSectionTitle}>
                {cuisineThemes[selectedCuisine as keyof typeof cuisineThemes].flag} {' '}
                {selectedCuisine.charAt(0).toUpperCase() + selectedCuisine.slice(1)} Favourites
              </Text>
              <Text style={styles.cuisineSectionCount}>
                {favouriteRecipes[selectedCuisine as keyof typeof favouriteRecipes].length} recipes
              </Text>
            </View>
            
            <View style={styles.recipesGrid}>
              {getFilteredRecipes().map((recipe) => {
                const theme = cuisineThemes[selectedCuisine as keyof typeof cuisineThemes];
                return (
                  <TouchableOpacity
                    key={recipe.id}
                    style={styles.recipeCard}
                    onPress={() => router.push(`/recipe-detail?id=${recipe.id}`)}
                  >
                    <Image source={{ uri: recipe.image }} style={styles.recipeImage} />
                    <LinearGradient
                      colors={['transparent', 'rgba(0,0,0,0.8)']}
                      style={styles.recipeOverlay}
                    >
                      <TouchableOpacity style={styles.favouriteHeart}>
                        <Heart size={20} color="#E74C3C" fill="#E74C3C" />
                      </TouchableOpacity>
                      
                      <View style={styles.recipeInfo}>
                        <Text style={styles.recipeName}>{recipe.name}</Text>
                        <Text style={styles.recipeChef}>by {recipe.chef}</Text>
                        
                        <View style={styles.recipeStats}>
                          <View style={styles.recipeStat}>
                            <Clock size={12} color="white" />
                            <Text style={styles.recipeStatText}>{recipe.time}</Text>
                          </View>
                          <View style={styles.recipeStat}>
                            <Star size={12} color="#FFD700" fill="#FFD700" />
                            <Text style={styles.recipeStatText}>{recipe.rating}</Text>
                          </View>
                          <View style={styles.recipeStat}>
                            {getDifficultyHats(recipe.difficulty)}
                          </View>
                        </View>
                      </View>
                    </LinearGradient>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>
        ) : (
          // All cuisines view
          Object.entries(cuisineThemes).map(([cuisine, theme]) => {
            const recipes = sortRecipes(favouriteRecipes[cuisine as keyof typeof favouriteRecipes]);
            if (recipes.length === 0) return null;

            return (
              <View key={cuisine} style={styles.cuisineSection}>
                <TouchableOpacity 
                  style={styles.cuisineSectionHeader}
                  onPress={() => setSelectedCuisine(cuisine)}
                >
                  <Text style={styles.cuisineSectionTitle}>
                    {theme.flag} {cuisine.charAt(0).toUpperCase() + cuisine.slice(1)} Favourites
                  </Text>
                  <View style={styles.cuisineSectionRight}>
                    <Text style={styles.cuisineSectionCount}>{recipes.length} recipes</Text>
                    <Text style={styles.viewAllText}>View All ‚Üí</Text>
                  </View>
                </TouchableOpacity>
                
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                  <View style={styles.horizontalRecipesList}>
                    {recipes.slice(0, 3).map((recipe) => (
                      <TouchableOpacity
                        key={recipe.id}
                        style={styles.horizontalRecipeCard}
                        onPress={() => router.push(`/recipe-detail?id=${recipe.id}`)}
                      >
                        <Image source={{ uri: recipe.image }} style={styles.horizontalRecipeImage} />
                        <LinearGradient
                          colors={['transparent', ...theme.colors.map(color => color + 'E6')]}
                          style={styles.horizontalRecipeOverlay}
                        >
                          <TouchableOpacity style={styles.horizontalFavouriteHeart}>
                            <Heart size={16} color="#E74C3C" fill="#E74C3C" />
                          </TouchableOpacity>
                          
                          <View style={styles.horizontalRecipeInfo}>
                            <Text style={styles.horizontalRecipeName}>{recipe.name}</Text>
                            <View style={styles.horizontalRecipeStats}>
                              <Clock size={10} color="white" />
                              <Text style={styles.horizontalRecipeStatText}>{recipe.time}</Text>
                              <Star size={10} color="#FFD700" fill="#FFD700" />
                              <Text style={styles.horizontalRecipeStatText}>{recipe.rating}</Text>
                            </View>
                          </View>
                        </LinearGradient>
                      </TouchableOpacity>
                    ))}
                  </View>
                </ScrollView>
              </View>
            );
          })
        )}

        {/* Empty State */}
        {totalFavourites === 0 && (
          <View style={styles.emptyState}>
            <Text style={styles.emptyStateIcon}>üíù</Text>
            <Text style={styles.emptyStateTitle}>No Favourites Yet</Text>
            <Text style={styles.emptyStateText}>
              Start exploring recipes and tap the heart icon to save your favourites here!
            </Text>
            <TouchableOpacity 
              style={styles.exploreButton}
              onPress={() => router.push('/recipes')}
            >
              <LinearGradient
                colors={['#8B4513', '#6B3410']}
                style={styles.exploreButtonGradient}
              >
                <Text style={styles.exploreButtonText}>Explore Recipes</Text>
              </LinearGradient>
            </TouchableOpacity>
          </View>
        )}
      </ScrollView>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingTop: 60,
  },
  header: {
    paddingHorizontal: 20,
    marginBottom: 25,
  },
  headerTop: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  headerTitle: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#8B4513',
  },
  searchButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerSubtitle: {
    fontSize: 16,
    color: '#6B3410',
    fontWeight: '500',
  },
  cuisineFilters: {
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  filterTabs: {
    flexDirection: 'row',
    gap: 12,
  },
  filterTab: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 25,
    backgroundColor: 'rgba(255, 255, 255, 0.7)',
    gap: 8,
  },
  activeFilterTab: {
    backgroundColor: '#8B4513',
  },
  filterTabIcon: {
    fontSize: 16,
  },
  filterTabText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#8B4513',
  },
  activeFilterTabText: {
    color: 'white',
  },
  controlsContainer: {
    paddingHorizontal: 20,
    marginBottom: 15,
  },
  sortButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingHorizontal: 16,
    paddingVertical: 10,
    backgroundColor: 'rgba(255, 255, 255, 0.7)',
    borderRadius: 20,
    alignSelf: 'flex-start',
  },
  sortButtonText: {
    fontSize: 14,
    color: '#8B4513',
    fontWeight: '500',
  },
  sortOptionsContainer: {
    marginHorizontal: 20,
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 10,
    marginBottom: 20,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  sortOption: {
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderRadius: 10,
  },
  activeSortOption: {
    backgroundColor: '#8B4513',
  },
  sortOptionText: {
    fontSize: 14,
    color: '#5D4037',
    fontWeight: '500',
  },
  activeSortOptionText: {
    color: 'white',
  },
  cuisineSection: {
    marginBottom: 30,
  },
  cuisineSectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    marginBottom: 15,
  },
  cuisineSectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#8B4513',
  },
  cuisineSectionRight: {
    alignItems: 'flex-end',
  },
  cuisineSectionCount: {
    fontSize: 12,
    color: '#6B3410',
    marginBottom: 2,
  },
  viewAllText: {
    fontSize: 14,
    color: '#8B4513',
    fontWeight: '600',
  },
  recipesGrid: {
    paddingHorizontal: 20,
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 15,
    justifyContent: 'space-between',
  },
  recipeCard: {
    width: '47%',
    height: 200,
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    marginBottom: 15,
  },
  recipeImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  recipeOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    top: 0,
    justifyContent: 'space-between',
    padding: 15,
  },
  favouriteHeart: {
    alignSelf: 'flex-end',
  },
  recipeInfo: {
    gap: 5,
  },
  recipeName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: 'white',
  },
  recipeChef: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.8)',
    fontStyle: 'italic',
  },
  recipeStats: {
    flexDirection: 'row',
    gap: 10,
    marginTop: 5,
  },
  recipeStat: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 3,
  },
  recipeStatText: {
    fontSize: 11,
    color: 'white',
    fontWeight: '500',
  },
  horizontalRecipesList: {
    flexDirection: 'row',
    gap: 15,
    paddingHorizontal: 20,
  },
  horizontalRecipeCard: {
    width: 160,
    height: 140,
    borderRadius: 15,
    overflow: 'hidden',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  horizontalRecipeImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  horizontalRecipeOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    top: 0,
    justifyContent: 'space-between',
    padding: 12,
  },
  horizontalFavouriteHeart: {
    alignSelf: 'flex-end',
  },
  horizontalRecipeInfo: {
    gap: 4,
  },
  horizontalRecipeName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: 'white',
  },
  horizontalRecipeStats: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  horizontalRecipeStatText: {
    fontSize: 10,
    color: 'white',
    marginRight: 6,
  },
  emptyState: {
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 40,
  },
  emptyStateIcon: {
    fontSize: 64,
    marginBottom: 20,
  },
  emptyStateTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#8B4513',
    marginBottom: 15,
    textAlign: 'center',
  },
  emptyStateText: {
    fontSize: 16,
    color: '#6B3410',
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 30,
  },
  exploreButton: {
    borderRadius: 25,
    overflow: 'hidden',
  },
  exploreButtonGradient: {
    paddingHorizontal: 30,
    paddingVertical: 15,
  },
  exploreButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
</file>

<file path="app/(tabs)/index.tsx/index.tsx">
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, TextInput, Image, KeyboardAvoidingView, Platform, Animated } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { ChefHat, Clock, Search, Star, Heart, X, Send, Mic, ChevronDown, ChevronUp } from 'lucide-react-native';
import { useUnifiedChat, ChatMessage } from '@/hooks/useUnifiedChat';

const mamaData = {
  italian: {
    name: 'Nonna Lucia',
    greeting: 'Benvenuti alla famiglia!',
    welcomeText: 'Welcome to Nonna\'s Italian Cookbook',
    colors: ['#E67E22', '#D35400'],
    bgColors: ['#FFF8E1', '#FFE0B2'],
    icon: 'üçù',
    accentColor: '#C0392B',
    personality: 'nonna_lucia' as const,
  },
  mexican: {
    name: 'Abuela Rosa',
    greeting: '¬°Bienvenidos a mi cocina!',
    welcomeText: 'Welcome to Abuela\'s Mexican Cookbook',
    colors: ['#27AE60', '#229954'],
    bgColors: ['#E8F8F5', '#D5F4E6'],
    icon: 'üåÆ',
    accentColor: '#E74C3C',
    personality: 'abuela_rosa' as const,
  },
  thai: {
    name: 'Mae Malai',
    greeting: '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö!',
    welcomeText: 'Welcome to Mae\'s Thai Cookbook',
    colors: ['#F39C12', '#E67E22'],
    bgColors: ['#FEF9E7', '#FCF3CF'],
    icon: 'üçõ',
    accentColor: '#D68910',
    personality: 'mae_malai' as const,
  },
};

// Mapping from personality IDs to cuisine IDs
const personalityToCuisineMap = {
  'nonna_lucia': 'italian',
  'abuela_rosa': 'mexican',
  'mae_malai': 'thai',
} as const;

const categoryData = {
  italian: [
    { 
      name: 'Meat', 
      icon: 'ü•©', 
      image: 'https://images.pexels.com/photos/361184/asparagus-steak-veal-chop-veal-361184.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#8B4513', '#A0522D'],
      description: 'Hearty meat dishes'
    },
    { 
      name: 'Fish', 
      icon: 'üêü', 
      image: 'https://images.pexels.com/photos/725991/pexels-photo-725991.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#4682B4', '#5F9EA0'],
      description: 'Fresh seafood recipes'
    },
    { 
      name: 'Pasta', 
      icon: 'üçù', 
      image: 'https://images.pexels.com/photos/1279330/pexels-photo-1279330.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#DAA520', '#B8860B'],
      description: 'Traditional pasta dishes'
    },
    { 
      name: 'Vegetarian', 
      icon: 'ü•¨', 
      image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#228B22', '#32CD32'],
      description: 'Garden-fresh vegetables'
    },
    { 
      name: 'Rice', 
      icon: 'üçö', 
      image: 'https://images.pexels.com/photos/1586942/pexels-photo-1586942.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#F5DEB3', '#DEB887'],
      description: 'Creamy risottos'
    },
    { 
      name: 'Dessert', 
      icon: 'üç∞', 
      image: 'https://images.pexels.com/photos/291528/pexels-photo-291528.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#FF69B4', '#FFB6C1'],
      description: 'Sweet Italian treats'
    },
  ],
  mexican: [
    { 
      name: 'Meat', 
      icon: 'ü•©', 
      image: 'https://images.pexels.com/photos/2338407/pexels-photo-2338407.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#8B4513', '#A0522D'],
      description: 'Grilled & braised meats'
    },
    { 
      name: 'Fish', 
      icon: 'üêü', 
      image: 'https://images.pexels.com/photos/725991/pexels-photo-725991.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#4682B4', '#5F9EA0'],
      description: 'Coastal seafood'
    },
    { 
      name: 'Tacos', 
      icon: 'üåÆ', 
      image: 'https://images.pexels.com/photos/2087748/pexels-photo-2087748.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#FF6347', '#FF4500'],
      description: 'Street-style tacos'
    },
    { 
      name: 'Vegetarian', 
      icon: 'ü•¨', 
      image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#228B22', '#32CD32'],
      description: 'Plant-based Mexican'
    },
    { 
      name: 'Rice', 
      icon: 'üçö', 
      image: 'https://images.pexels.com/photos/5737241/pexels-photo-5737241.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#F5DEB3', '#DEB887'],
      description: 'Arroz & grain dishes'
    },
    { 
      name: 'Dessert', 
      icon: 'üç∞', 
      image: 'https://images.pexels.com/photos/291528/pexels-photo-291528.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#FF69B4', '#FFB6C1'],
      description: 'Mexican sweets'
    },
  ],
  thai: [
    { 
      name: 'Meat', 
      icon: 'ü•©', 
      image: 'https://images.pexels.com/photos/2338407/pexels-photo-2338407.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#8B4513', '#A0522D'],
      description: 'Thai-style meats'
    },
    { 
      name: 'Fish', 
      icon: 'üêü', 
      image: 'https://images.pexels.com/photos/725991/pexels-photo-725991.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#4682B4', '#5F9EA0'],
      description: 'Fresh fish & prawns'
    },
    { 
      name: 'Curries', 
      icon: 'üçõ', 
      image: 'https://images.pexels.com/photos/2347311/pexels-photo-2347311.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#FF8C00', '#FF7F50'],
      description: 'Aromatic Thai curries'
    },
    { 
      name: 'Vegetarian', 
      icon: 'ü•¨', 
      image: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#228B22', '#32CD32'],
      description: 'Buddhist-inspired dishes'
    },
    { 
      name: 'Rice', 
      icon: 'üçö', 
      image: 'https://images.pexels.com/photos/1586942/pexels-photo-1586942.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#F5DEB3', '#DEB887'],
      description: 'Jasmine rice dishes'
    },
    { 
      name: 'Dessert', 
      icon: 'üç∞', 
      image: 'https://images.pexels.com/photos/291528/pexels-photo-291528.jpeg?auto=compress&cs=tinysrgb&w=400',
      gradient: ['#FF69B4', '#FFB6C1'],
      description: 'Thai desserts'
    },
  ],
};

const favoriteRecipes = {
  italian: [
    { 
      id: 1, 
      name: 'Classic Carbonara', 
      image: 'https://i.imgur.com/UWR05kt.jpg', 
      time: '25 min', 
      rating: 4.8,
      description: 'Nonna\'s secret family recipe passed down for generations',
      mama: 'nonna_lucia'
    },
    { 
      id: 2, 
      name: 'Osso Buco', 
      image: 'https://i.imgur.com/2k4bzJe.jpg', 
      time: '3 hours', 
      rating: 4.9,
      description: 'Slow-braised veal shanks in rich tomato sauce',
      mama: 'nonna_lucia'
    },
    { 
      id: 7, 
      name: 'Nonna\'s Minestrone', 
      image: 'https://i.imgur.com/zj23RzP.jpg', 
      time: '45 min', 
      rating: 4.7,
      description: 'Hearty vegetable soup made with love and tradition',
      mama: 'nonna_lucia'
    },
  ],
  mexican: [
    { 
      id: 3, 
      name: 'Tacos al Pastor', 
      image: 'https://i.imgur.com/5M5owi4.jpg', 
      time: '2 hours', 
      rating: 4.7,
      description: 'Street-style tacos with marinated pork and pineapple',
      mama: 'abuela_rosa'
    },
    { 
      id: 4, 
      name: 'Mole Poblano', 
      image: 'https://i.imgur.com/lomAygP.jpg', 
      time: '4 hours', 
      rating: 4.9,
      description: 'Complex sauce with chocolate and 20+ ingredients',
      mama: 'abuela_rosa'
    },
    { 
      id: 8, 
      name: 'Pozole Rojo', 
      image: 'https://i.imgur.com/yCR4wf6.jpg', 
      time: '2.5 hours', 
      rating: 4.6,
      description: 'Traditional hominy soup for celebrations',
      mama: 'abuela_rosa'
    },
  ],
  thai: [
    { 
      id: 5, 
      name: 'Traditional Green Curry', 
      image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', 
      time: '45 min', 
      rating: 4.8,
      description: 'Authentic Thai curry with perfect balance of flavors',
      mama: 'mae_malai'
    },
    { 
      id: 6, 
      name: 'Pad Thai', 
      image: 'https://i.imgur.com/QguqAzq.jpg', 
      time: '20 min', 
      rating: 4.4,
      description: 'Sweet and tangy stir-fried noodles',
      mama: 'mae_malai'
    },
    { 
      id: 9, 
      name: 'Tom Yum Goong', 
      image: 'https://i.imgur.com/2pB8HIc.jpg', 
      time: '30 min', 
      rating: 4.8,
      description: 'Spicy and sour shrimp soup with lemongrass',
      mama: 'mae_malai'
    },
  ],
};

export default function MamaCookbookScreen() {
  const params = useLocalSearchParams();
  const router = useRouter();
  const [selectedMama, setSelectedMama] = useState('italian');
  const [searchQuery, setSearchQuery] = useState('');
  const [showChat, setShowChat] = useState(false);
  const [currentMessage, setCurrentMessage] = useState('');
  const [chatHeight] = useState(new Animated.Value(0));

  // Initialize unified chat
  const { 
    chatState, 
    sendMessage, 
    initializeChat, 
    isAvailable 
  } = useUnifiedChat(mamaData[selectedMama as keyof typeof mamaData].personality);

  useEffect(() => {
    if (params.mama && typeof params.mama === 'string') {
      console.log('üîÑ Setting mama from URL params:', params.mama);
      
      // Check if params.mama is a personality ID and map it to cuisine ID
      const cuisineId = personalityToCuisineMap[params.mama as keyof typeof personalityToCuisineMap];
      if (cuisineId) {
        console.log('üîÑ Mapped personality', params.mama, 'to cuisine', cuisineId);
        setSelectedMama(cuisineId);
      } else if (params.mama in mamaData) {
        // If it's already a cuisine ID, use it directly
        setSelectedMama(params.mama);
      } else {
        console.warn('‚ö†Ô∏è Unknown mama parameter:', params.mama, 'defaulting to italian');
        setSelectedMama('italian');
      }
    }
  }, [params.mama]);

  // Initialize chat when mama changes
  useEffect(() => {
    if (showChat) {
      initializeChat('pre_cooking');
    }
  }, [selectedMama, showChat, initializeChat]);

  // Animate chat dropdown
  useEffect(() => {
    Animated.timing(chatHeight, {
      toValue: showChat ? 300 : 0,
      duration: 300,
      useNativeDriver: false,
    }).start();
  }, [showChat, chatHeight]);

  const mama = mamaData[selectedMama as keyof typeof mamaData];
  const categories = categoryData[selectedMama as keyof typeof categoryData];
  const favorites = favoriteRecipes[selectedMama as keyof typeof favoriteRecipes];

  const handleCategorySelect = (categoryName: string) => {
    router.push(`/search?category=${encodeURIComponent(categoryName)}&mama=${selectedMama}`);
  };

  const handleRecipeSelect = (recipeId: number) => {
    // FIXED: Pass mama parameter when navigating to recipe detail
    const recipe = favorites.find(r => r.id === recipeId);
    if (recipe && recipe.mama) {
      console.log('üç≥ Navigating to recipe', recipeId, 'with mama', recipe.mama);
      router.push(`/recipe-detail?id=${recipeId}&mama=${recipe.mama}`);
    } else {
      // Fallback to current selected mama
      router.push(`/recipe-detail?id=${recipeId}&mama=${selectedMama}`);
    }
  };

  const handleSendMessage = async () => {
    if (!currentMessage.trim()) return;
    
    await sendMessage(currentMessage);
    setCurrentMessage('');
  };

  const handleSuggestedPrompt = async (prompt: string) => {
    setCurrentMessage(prompt);
  };

  const handleVoiceMessage = async () => {
    // For now, just send a sample voice message
    await sendMessage("Hey, can you help me with cooking?", { isVoice: true });
  };

  const toggleChat = () => {
    setShowChat(!showChat);
    if (!showChat) {
      initializeChat('pre_cooking');
    }
  };

  return (
    <LinearGradient
      colors={mama.colors}
      style={styles.container}
    >
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.headerTop}>
            <View style={styles.headerLeft}>
              <Text style={styles.traditionalGreeting}>{mama.greeting}</Text>
              <Text style={styles.welcomeText}>{mama.welcomeText}</Text>
            </View>
            <TouchableOpacity 
              style={styles.closeButton}
              onPress={() => router.push('/mama-selection')}
            >
              <X size={24} color="white" />
            </TouchableOpacity>
          </View>
        </View>

        {/* Enhanced Category Circles with Better Visual Design */}
        <View style={styles.categoriesSection}>
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.categoriesScrollContainer}
          >
            {categories.map((category, index) => (
              <TouchableOpacity
                key={index}
                style={styles.categoryCircle}
                onPress={() => handleCategorySelect(category.name)}
              >
                <View style={styles.categoryImageContainer}>
                  <Image source={{ uri: category.image }} style={styles.categoryCircleImage} />
                  <LinearGradient
                    colors={[...category.gradient, 'rgba(0,0,0,0.4)']}
                    style={styles.categoryOverlay}
                  >
                    <View style={styles.categoryContent}>
                      <Text style={styles.categoryEmoji}>{category.icon}</Text>
                      <View style={styles.categoryTextContainer}>
                        <Text style={styles.categoryName}>{category.name}</Text>
                        <Text style={styles.categoryDescription}>{category.description}</Text>
                      </View>
                    </View>
                  </LinearGradient>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>

        {/* Search Bar */}
        <View style={styles.searchContainer}>
          <View style={styles.searchBar}>
            <Search size={20} color="rgba(255,255,255,0.8)" />
            <TextInput
              style={styles.searchInput}
              placeholder="Search recipes..."
              placeholderTextColor="rgba(255,255,255,0.6)"
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
          </View>
        </View>

        {/* COMPACT WIREFRAME-STYLE CHAT SECTION - Recipe Selection Specialty */}
        <View style={styles.chatSection}>
          <TouchableOpacity 
            style={styles.compactChatCard}
            onPress={toggleChat}
          >
            <LinearGradient
              colors={['rgba(255,255,255,0.95)', 'rgba(255,255,255,0.85)']}
              style={styles.compactChatGradient}
            >
              <View style={styles.compactChatContent}>
                <View style={styles.compactChatIcons}>
                  <View style={styles.compactPhoneEmoji}>
                    <Text style={styles.compactEmojiText}>üì±</Text>
                  </View>
                  <View style={styles.compactMamaEmoji}>
                    <Text style={styles.compactEmojiText}>üëµüèª</Text>
                  </View>
                </View>
                <View style={styles.compactChatText}>
                  <Text style={styles.compactChatTitle}>Text {mama.name.split(' ')[0]}!</Text>
                  <Text style={styles.compactChatSubtitle}>{mama.name.split(' ')[0]} is here to help</Text>
                </View>
                <View style={styles.chatToggleIcon}>
                  {showChat ? (
                    <ChevronUp size={20} color="#8B4513" />
                  ) : (
                    <ChevronDown size={20} color="#8B4513" />
                  )}
                </View>
              </View>
            </LinearGradient>
          </TouchableOpacity>

          <Animated.View style={[styles.chatDropdown, { height: chatHeight }]}>
            <View style={styles.chatContainer}>
              <ScrollView style={styles.chatMessages} showsVerticalScrollIndicator={false}>
                {chatState.messages.map((message) => (
                  <View 
                    key={message.id} 
                    style={[
                      styles.messageContainer,
                      message.sender === 'user' ? styles.userMessage : styles.mamaMessage
                    ]}
                  >
                    {message.sender === 'mama' && (
                      <Text style={styles.messageAvatar}>üëµüèª</Text>
                    )}
                    <View style={[
                      styles.messageBubble,
                      message.sender === 'user' ? styles.userBubble : styles.mamaBubble
                    ]}>
                      <Text style={[
                        styles.messageText,
                        message.sender === 'user' ? styles.userMessageText : styles.mamaMessageText
                      ]}>
                        {message.text}
                      </Text>
                      {message.responseTime && (
                        <Text style={styles.responseTime}>
                          {message.source === 'template' ? '‚ö°' : 'ü§ñ'} {message.responseTime}ms
                        </Text>
                      )}
                    </View>
                  </View>
                ))}
                
                {chatState.isTyping && (
                  <View style={[styles.messageContainer, styles.mamaMessage]}>
                    <Text style={styles.messageAvatar}>üëµüèª</Text>
                    <View style={[styles.messageBubble, styles.mamaBubble]}>
                      <Text style={styles.typingIndicator}>...</Text>
                    </View>
                  </View>
                )}
              </ScrollView>
              
              <KeyboardAvoidingView 
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                style={styles.chatInputContainer}
              >
                <TextInput
                  style={styles.chatInput}
                  value={currentMessage}
                  onChangeText={setCurrentMessage}
                  placeholder="What ingredients do you have?"
                  placeholderTextColor="#A0522D"
                  multiline
                  maxLength={200}
                />
                <TouchableOpacity 
                  style={styles.voiceButton}
                  onPress={handleVoiceMessage}
                >
                  <Mic size={20} color="#8B4513" />
                </TouchableOpacity>
                <TouchableOpacity 
                  style={styles.sendButton}
                  onPress={handleSendMessage}
                  disabled={!currentMessage.trim()}
                >
                  <Send size={20} color={currentMessage.trim() ? "#8B4513" : "#CCC"} />
                </TouchableOpacity>
              </KeyboardAvoidingView>
            </View>
          </Animated.View>
        </View>

        {/* Favourites Section */}
        <View style={styles.favouritesSection}>
          <Text style={styles.sectionTitle}>Favourites</Text>
          <Text style={styles.sectionSubtitle}>Family recipes made with love</Text>
          
          <View style={styles.favouritesGrid}>
            {favorites.map((recipe) => (
              <TouchableOpacity
                key={recipe.id}
                style={styles.favouriteCard}
                onPress={() => handleRecipeSelect(recipe.id)}
              >
                <Image source={{ uri: recipe.image }} style={styles.favouriteImage} />
                <LinearGradient
                  colors={['transparent', 'rgba(0,0,0,0.8)']}
                  style={styles.favouriteOverlay}
                >
                  <TouchableOpacity style={styles.favouriteHeart}>
                    <Heart size={18} color="#E74C3C" fill="#E74C3C" />
                  </TouchableOpacity>
                  
                  <View style={styles.favouriteInfo}>
                    <Text style={styles.favouriteName}>{recipe.name}</Text>
                    <Text style={styles.favouriteDescription} numberOfLines={2}>
                      {recipe.description}
                    </Text>
                    <View style={styles.favouriteStats}>
                      <View style={styles.favouriteStat}>
                        <Clock size={12} color="white" />
                        <Text style={styles.favouriteTime}>{recipe.time}</Text>
                      </View>
                      <View style={styles.favouriteStat}>
                        <Star size={12} color="#FFD700" fill="#FFD700" />
                        <Text style={styles.favouriteRating}>{recipe.rating}</Text>
                      </View>
                    </View>
                  </View>
                </LinearGradient>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* View All Recipes Button */}
        <View style={styles.viewAllSection}>
          <TouchableOpacity 
            style={styles.viewAllButton}
            onPress={() => router.push('/recipes')}
          >
            <Text style={styles.viewAllText}>View All {mama.name.split(' ')[0]}'s Recipes</Text>
            <ChefHat size={20} color="white" />
          </TouchableOpacity>
        </View>
      </ScrollView>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingTop: 60,
  },
  header: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  headerTop: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  headerLeft: {
    flex: 1,
  },
  traditionalGreeting: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 5,
    fontStyle: 'italic',
  },
  welcomeText: {
    fontSize: 16,
    color: 'rgba(255,255,255,0.9)',
    fontWeight: '600',
  },
  closeButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,0,0,0.2)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  categoriesSection: {
    marginBottom: 30,
  },
  categoriesScrollContainer: {
    paddingHorizontal: 20,
    gap: 15,
  },
  categoryCircle: {
    alignItems: 'center',
    width: 120,
  },
  categoryImageContainer: {
    width: 110,
    height: 110,
    borderRadius: 20,
    overflow: 'hidden',
    marginBottom: 8,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  categoryCircleImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  categoryOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 12,
  },
  categoryContent: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
  },
  categoryEmoji: {
    fontSize: 32,
    marginBottom: 8,
    textShadowColor: 'rgba(0,0,0,0.5)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  categoryTextContainer: {
    alignItems: 'center',
  },
  categoryName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: 'white',
    textAlign: 'center',
    marginBottom: 2,
    textShadowColor: 'rgba(0,0,0,0.7)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 3,
  },
  categoryDescription: {
    fontSize: 10,
    color: 'rgba(255,255,255,0.9)',
    textAlign: 'center',
    fontStyle: 'italic',
    textShadowColor: 'rgba(0,0,0,0.5)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  searchContainer: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255,255,255,0.2)',
    borderRadius: 25,
    paddingHorizontal: 20,
    paddingVertical: 15,
    gap: 12,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: 'white',
  },

  // COMPACT WIREFRAME-STYLE CHAT SECTION - MATCHES WIREFRAME EXACTLY
  chatSection: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  compactChatCard: {
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    borderWidth: 2,
    borderColor: 'rgba(255,255,255,0.3)',
  },
  compactChatGradient: {
    paddingVertical: 16,
    paddingHorizontal: 20,
  },
  compactChatContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 15,
  },
  compactChatIcons: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  compactPhoneEmoji: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'rgba(139, 69, 19, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.25)',
  },
  compactMamaEmoji: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'rgba(139, 69, 19, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.25)',
  },
  compactEmojiText: {
    fontSize: 24,
  },
  compactChatText: {
    flex: 1,
  },
  compactChatTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#8B4513',
    marginBottom: 2,
    letterSpacing: 0.3,
  },
  compactChatSubtitle: {
    fontSize: 14,
    color: '#6B3410',
    fontWeight: '500',
  },
  chatToggleIcon: {
    padding: 4,
  },

  // Chat Dropdown Animation
  chatDropdown: {
    overflow: 'hidden',
    marginTop: 12,
  },
  chatContainer: {
    backgroundColor: 'rgba(255,255,255,0.95)',
    borderRadius: 18,
    height: 300,
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.2)',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
  },
  chatMessages: {
    flex: 1,
    padding: 16,
  },
  messageContainer: {
    flexDirection: 'row',
    marginBottom: 12,
    alignItems: 'flex-end',
  },
  userMessage: {
    justifyContent: 'flex-end',
  },
  mamaMessage: {
    justifyContent: 'flex-start',
  },
  messageAvatar: {
    fontSize: 16,
    marginRight: 8,
    marginBottom: 2,
  },
  messageBubble: {
    maxWidth: '80%',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
  },
  userBubble: {
    backgroundColor: '#8B4513',
    borderBottomRightRadius: 4,
  },
  mamaBubble: {
    backgroundColor: '#F5F5F5',
    borderBottomLeftRadius: 4,
  },
  messageText: {
    fontSize: 14,
    lineHeight: 18,
  },
  userMessageText: {
    color: 'white',
  },
  mamaMessageText: {
    color: '#333',
  },
  responseTime: {
    fontSize: 10,
    color: '#666',
    marginTop: 3,
    fontStyle: 'italic',
  },
  typingIndicator: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  chatInputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(139, 69, 19, 0.1)',
    gap: 10,
  },
  chatInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
    borderRadius: 20,
    paddingHorizontal: 15,
    paddingVertical: 10,
    fontSize: 14,
    color: '#333',
    maxHeight: 70,
    backgroundColor: 'white',
  },
  voiceButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(139, 69, 19, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
  },
  sendButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(139, 69, 19, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
  },

  favouritesSection: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 5,
  },
  sectionSubtitle: {
    fontSize: 14,
    color: 'rgba(255,255,255,0.8)',
    marginBottom: 20,
    fontStyle: 'italic',
  },
  favouritesGrid: {
    gap: 15,
  },
  favouriteCard: {
    height: 200,
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    marginBottom: 15,
  },
  favouriteImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  favouriteOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    top: 0,
    justifyContent: 'space-between',
    padding: 20,
  },
  favouriteHeart: {
    alignSelf: 'flex-end',
  },
  favouriteInfo: {
    gap: 8,
  },
  favouriteName: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'white',
  },
  favouriteDescription: {
    fontSize: 14,
    color: 'rgba(255,255,255,0.9)',
    lineHeight: 18,
  },
  favouriteStats: {
    flexDirection: 'row',
    gap: 15,
    marginTop: 5,
  },
  favouriteStat: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  favouriteTime: {
    fontSize: 12,
    color: 'white',
    fontWeight: '500',
  },
  favouriteRating: {
    fontSize: 12,
    color: 'white',
    fontWeight: '500',
  },
  viewAllSection: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  viewAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingVertical: 15,
    borderRadius: 25,
    borderWidth: 2,
    borderColor: 'rgba(255,255,255,0.3)',
  },
  viewAllText: {
    fontSize: 16,
    color: 'white',
    fontWeight: '600',
  },
});
</file>

<file path="app/(tabs)/profile.tsx/profile.tsx">
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, Switch } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import { 
  User, 
  ChefHat, 
  Award, 
  Heart, 
  Settings, 
  Volume2, 
  Bell, 
  Globe,
  Star,
  Clock,
  Camera,
  Zap,
  Moon
} from 'lucide-react-native';

const achievements = [
  { id: 1, name: 'First Pasta Perfect', icon: 'üçù', unlocked: true },
  { id: 2, name: 'Carbonara Master', icon: 'ü•ì', unlocked: true },
  { id: 3, name: 'Nonna\'s Favorite', icon: '‚ù§Ô∏è', unlocked: true },
  { id: 4, name: 'Timer Champion', icon: '‚è∞', unlocked: true },
  { id: 5, name: 'Photo Food Star', icon: 'üì∏', unlocked: false },
  { id: 6, name: 'Cultural Explorer', icon: 'üåç', unlocked: false },
];

const cookingStats = [
  { label: 'Recipes Completed', value: '12', icon: ChefHat },
  { label: 'Cooking Hours', value: '24.5', icon: Clock },
  { label: 'Photos Rated', value: '8', icon: Camera },
  { label: 'Average Rating', value: '8.2/10', icon: Star },
];

export default function ProfileScreen() {
  const router = useRouter();
  const [voiceEnabled, setVoiceEnabled] = useState(true);
  const [notifications, setNotifications] = useState(true);
  const [screenAwake, setScreenAwake] = useState(true);
  const [autoAdvance, setAutoAdvance] = useState(false);
  const [showSafetyReminders, setShowSafetyReminders] = useState(true);

  return (
    <LinearGradient
      colors={['#FFF8E1', '#FFE0B2']}
      style={styles.container}
    >
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        <View style={styles.header}>
          <View style={styles.avatarContainer}>
            <LinearGradient
              colors={['#E67E22', '#D35400']}
              style={styles.avatar}
            >
              <User size={40} color="white" />
            </LinearGradient>
          </View>
          <Text style={styles.userName}>Chef Maria</Text>
          <Text style={styles.userTitle}>Aspiring Cook</Text>
          <View style={styles.currentMama}>
            <Text style={styles.currentMamaText}>Currently learning with: </Text>
            <Text style={styles.mamaName}>Nonna Lucia üçù</Text>
          </View>
        </View>

        {/* Cooking Stats */}
        <View style={styles.statsContainer}>
          <Text style={styles.sectionTitle}>Your Cooking Journey</Text>
          <View style={styles.statsGrid}>
            {cookingStats.map((stat, index) => (
              <View key={index} style={styles.statCard}>
                <stat.icon size={24} color="#E67E22" />
                <Text style={styles.statValue}>{stat.value}</Text>
                <Text style={styles.statLabel}>{stat.label}</Text>
              </View>
            ))}
          </View>
        </View>

        {/* Achievements */}
        <View style={styles.achievementsContainer}>
          <Text style={styles.sectionTitle}>Achievements</Text>
          <View style={styles.achievementsGrid}>
            {achievements.map((achievement) => (
              <View 
                key={achievement.id} 
                style={[
                  styles.achievementCard,
                  !achievement.unlocked && styles.lockedAchievement
                ]}
              >
                <Text style={[
                  styles.achievementIcon,
                  !achievement.unlocked && styles.lockedIcon
                ]}>
                  {achievement.icon}
                </Text>
                <Text style={[
                  styles.achievementName,
                  !achievement.unlocked && styles.lockedText
                ]}>
                  {achievement.name}
                </Text>
              </View>
            ))}
          </View>
        </View>

        {/* Favorite Recipes */}
        <View style={styles.favoritesContainer}>
          <Text style={styles.sectionTitle}>Favorite Recipes</Text>
          <ScrollView horizontal showsHorizontalScrollIndicator={false}>
            <View style={styles.favoritesList}>
              {['üçù Carbonara', 'üç≤ Minestrone', 'üç∞ Tiramisu'].map((recipe, index) => (
                <TouchableOpacity key={index} style={styles.favoriteCard}>
                  <Text style={styles.favoriteIcon}>{recipe.split(' ')[0]}</Text>
                  <Text style={styles.favoriteName}>{recipe.split(' ').slice(1).join(' ')}</Text>
                </TouchableOpacity>
              ))}
            </View>
          </ScrollView>
        </View>

        {/* Smart Cooking Settings */}
        <View style={styles.settingsContainer}>
          <Text style={styles.sectionTitle}>Smart Cooking Settings</Text>
          
          <View style={styles.settingItem}>
            <View style={styles.settingInfo}>
              <Volume2 size={20} color="#E67E22" />
              <Text style={styles.settingLabel}>Voice Commands</Text>
            </View>
            <Switch
              value={voiceEnabled}
              onValueChange={setVoiceEnabled}
              trackColor={{ false: '#DDD', true: '#E67E22' }}
              thumbColor={voiceEnabled ? 'white' : '#FFF'}
            />
          </View>

          <View style={styles.settingItem}>
            <View style={styles.settingInfo}>
              <Bell size={20} color="#E67E22" />
              <Text style={styles.settingLabel}>Cooking Notifications</Text>
            </View>
            <Switch
              value={notifications}
              onValueChange={setNotifications}
              trackColor={{ false: '#DDD', true: '#E67E22' }}
              thumbColor={notifications ? 'white' : '#FFF'}
            />
          </View>

          <View style={styles.settingItem}>
            <View style={styles.settingInfo}>
              <Moon size={20} color="#E67E22" />
              <Text style={styles.settingLabel}>Keep Screen Awake</Text>
            </View>
            <Switch
              value={screenAwake}
              onValueChange={setScreenAwake}
              trackColor={{ false: '#DDD', true: '#E67E22' }}
              thumbColor={screenAwake ? 'white' : '#FFF'}
            />
          </View>

          <View style={styles.settingItem}>
            <View style={styles.settingInfo}>
              <Zap size={20} color="#E67E22" />
              <Text style={styles.settingLabel}>Auto-Advance Steps</Text>
            </View>
            <Switch
              value={autoAdvance}
              onValueChange={setAutoAdvance}
              trackColor={{ false: '#DDD', true: '#E67E22' }}
              thumbColor={autoAdvance ? 'white' : '#FFF'}
            />
          </View>

          <View style={styles.settingItem}>
            <View style={styles.settingInfo}>
              <Settings size={20} color="#E67E22" />
              <Text style={styles.settingLabel}>Safety Reminders</Text>
            </View>
            <Switch
              value={showSafetyReminders}
              onValueChange={setShowSafetyReminders}
              trackColor={{ false: '#DDD', true: '#E67E22' }}
              thumbColor={showSafetyReminders ? 'white' : '#FFF'}
            />
          </View>

          <TouchableOpacity style={styles.settingItem}>
            <View style={styles.settingInfo}>
              <Globe size={20} color="#E67E22" />
              <Text style={styles.settingLabel}>Language & Region</Text>
            </View>
            <Text style={styles.settingValue}>English (US)</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.changeMamaButton}
            onPress={() => router.push('/mama-selection')}
          >
            <LinearGradient
              colors={['#E67E22', '#D35400']}
              style={styles.buttonGradient}
            >
              <ChefHat size={20} color="white" />
              <Text style={styles.buttonText}>Switch Mama</Text>
            </LinearGradient>
          </TouchableOpacity>
        </View>

        {/* App Info */}
        <View style={styles.appInfoContainer}>
          <Text style={styles.appVersion}>Mamia v1.0.0</Text>
          <Text style={styles.appTagline}>Cook with Soul ‚ù§Ô∏è</Text>
        </View>
      </ScrollView>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingTop: 60,
  },
  header: {
    alignItems: 'center',
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  avatarContainer: {
    marginBottom: 15,
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  userName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#E67E22',
    marginBottom: 5,
  },
  userTitle: {
    fontSize: 16,
    color: '#8B4513',
    marginBottom: 10,
  },
  currentMama: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  currentMamaText: {
    fontSize: 14,
    color: '#5D4037',
  },
  mamaName: {
    fontSize: 14,
    fontWeight: '600',
    color: '#E67E22',
  },
  statsContainer: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#E67E22',
    marginBottom: 15,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
  },
  statCard: {
    flex: 1,
    minWidth: '47%',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 15,
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  statValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#E67E22',
    marginTop: 8,
  },
  statLabel: {
    fontSize: 12,
    color: '#5D4037',
    textAlign: 'center',
    marginTop: 4,
  },
  achievementsContainer: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  achievementsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
  },
  achievementCard: {
    width: '30%',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 12,
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  lockedAchievement: {
    backgroundColor: '#F5F5F5',
    opacity: 0.6,
  },
  achievementIcon: {
    fontSize: 24,
    marginBottom: 8,
  },
  lockedIcon: {
    opacity: 0.5,
  },
  achievementName: {
    fontSize: 10,
    color: '#5D4037',
    textAlign: 'center',
    fontWeight: '500',
  },
  lockedText: {
    color: '#999',
  },
  favoritesContainer: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  favoritesList: {
    flexDirection: 'row',
    gap: 15,
  },
  favoriteCard: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 15,
    alignItems: 'center',
    minWidth: 100,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  favoriteIcon: {
    fontSize: 30,
    marginBottom: 8,
  },
  favoriteName: {
    fontSize: 12,
    color: '#5D4037',
    textAlign: 'center',
    fontWeight: '500',
  },
  settingsContainer: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  settingItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 15,
    marginBottom: 10,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  settingInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  settingLabel: {
    fontSize: 16,
    color: '#5D4037',
    fontWeight: '500',
  },
  settingValue: {
    fontSize: 14,
    color: '#8B4513',
  },
  changeMamaButton: {
    marginTop: 10,
    borderRadius: 25,
    overflow: 'hidden',
  },
  buttonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 15,
    gap: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  appInfoContainer: {
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingBottom: 30,
  },
  appVersion: {
    fontSize: 12,
    color: '#8B4513',
    marginBottom: 5,
  },
  appTagline: {
    fontSize: 14,
    color: '#E67E22',
    fontStyle: 'italic',
  },
});
</file>

<file path="app/(tabs)/recipes.tsx/recipes.tsx">
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, TextInput, Image } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import { Search, Clock, ChefHat, Star, Mic, Heart } from 'lucide-react-native';

const recipes = [
  {
    id: 1,
    name: 'Classic Carbonara',
    category: 'Pasta & Noodles',
    difficulty: 2,
    time: '25 min',
    rating: 4.8,
    image: 'https://i.imgur.com/UWR05kt.jpg',
    culture: 'italian',
    description: 'Authentic Roman pasta with eggs, cheese, and pancetta',
    chef: 'Nonna Lucia',
    servings: 4,
    calories: 520,
  },
  {
    id: 2,
    name: 'Nonna\'s Minestrone',
    category: 'Soups',
    difficulty: 1,
    time: '45 min',
    rating: 4.9,
    image: 'https://i.imgur.com/zj23RzP.jpg',
    culture: 'italian',
    description: 'Hearty Italian vegetable soup with seasonal ingredients',
    chef: 'Nonna Lucia',
    servings: 6,
    calories: 280,
  },
  {
    id: 3,
    name: 'Tacos al Pastor',
    category: 'Mexican Street Food',
    difficulty: 3,
    time: '2 hours',
    rating: 4.7,
    image: 'https://i.imgur.com/5M5owi4.jpg',
    culture: 'mexican',
    description: 'Traditional Mexican tacos with marinated pork and pineapple',
    chef: 'Abuela Rosa',
    servings: 8,
    calories: 320,
  },
  {
    id: 4,
    name: 'Green Curry',
    category: 'Thai Curries',
    difficulty: 2,
    time: '35 min',
    rating: 4.6,
    image: 'https://i.imgur.com/ORMJpqJ.jpg',
    culture: 'thai',
    description: 'Aromatic Thai curry with coconut milk and fresh herbs',
    chef: 'Mae Malai',
    servings: 4,
    calories: 380,
  },
  {
    id: 5,
    name: 'Traditional Green Curry',
    category: 'Thai Curries',
    difficulty: 2,
    time: '45 min',
    rating: 4.8,
    image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',
    culture: 'thai',
    description: 'Authentic Thai green curry with perfect balance of flavors',
    chef: 'Mae Malai',
    servings: 4,
    calories: 420,
  },
];

const categories = [
  { 
    name: 'Rice', 
    image: 'https://images.pexels.com/photos/1586942/pexels-photo-1586942.jpeg?auto=compress&cs=tinysrgb&w=400',
    icon: 'üçö',
    culture: 'general'
  },
  { 
    name: 'Pasta & Noodles', 
    image: 'https://i.imgur.com/UWR05kt.jpg',
    icon: 'üçù',
    culture: 'italian'
  },
  { 
    name: 'Thai Curries', 
    image: 'https://i.imgur.com/ORMJpqJ.jpg',
    icon: 'üçõ',
    culture: 'thai'
  },
  { 
    name: 'Mexican Street Food', 
    image: 'https://i.imgur.com/5M5owi4.jpg',
    icon: 'üåÆ',
    culture: 'mexican'
  },
];

const popularRecipes = [
  {
    id: 1,
    name: 'Classic Carbonara',
    image: 'https://i.imgur.com/UWR05kt.jpg',
    time: '25 min',
    rating: 4.8,
    culture: 'italian',
  },
  {
    id: 5,
    name: 'Traditional Green Curry',
    image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',
    time: '45 min',
    rating: 4.8,
    culture: 'thai',
  },
  {
    id: 3,
    name: 'Tacos al Pastor',
    image: 'https://i.imgur.com/5M5owi4.jpg',
    time: '2 hours',
    rating: 4.7,
    culture: 'mexican',
  },
];

const culturalThemes = {
  italian: {
    colors: ['#E67E22', '#D35400'],
    bgColors: ['#FFF8E1', '#FFE0B2'],
    accentColor: '#C0392B',
    pattern: 'üçÖüåø',
    textColor: '#8B4513',
  },
  mexican: {
    colors: ['#27AE60', '#229954'],
    bgColors: ['#E8F8F5', '#D5F4E6'],
    accentColor: '#E74C3C',
    pattern: 'üå∂Ô∏èüíÄ',
    textColor: '#1B4F3C',
  },
  thai: {
    colors: ['#F39C12', '#E67E22'],
    bgColors: ['#FEF9E7', '#FCF3CF'],
    accentColor: '#D68910',
    pattern: 'üå∏üçÉ',
    textColor: '#B7950B',
  },
  general: {
    colors: ['#8B4513', '#6B3410'],
    bgColors: ['#F5E6D3', '#E8D5C4'],
    accentColor: '#A0522D',
    pattern: '‚ú®üçΩÔ∏è',
    textColor: '#8B4513',
  },
};

export default function RecipesScreen() {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [favorites, setFavorites] = useState<number[]>([]);

  const getDifficultyHats = (difficulty: number) => {
    return Array(3).fill(0).map((_, index) => (
      <ChefHat 
        key={index} 
        size={14} 
        color={index < difficulty ? '#8B4513' : '#DDD'} 
      />
    ));
  };

  const toggleFavorite = (recipeId: number) => {
    setFavorites(prev => 
      prev.includes(recipeId) 
        ? prev.filter(id => id !== recipeId)
        : [...prev, recipeId]
    );
  };

  const getCulturalTheme = (culture: string) => {
    return culturalThemes[culture as keyof typeof culturalThemes] || culturalThemes.general;
  };

  return (
    <View style={styles.container}>
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Discover Recipes</Text>
        </View>

        {/* Search Bar */}
        <View style={styles.searchContainer}>
          <View style={styles.searchBar}>
            <Search size={20} color="#8B4513" />
            <TextInput
              style={styles.searchInput}
              placeholder="Search recipes..."
              placeholderTextColor="#A0522D"
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
            <TouchableOpacity style={styles.voiceButton}>
              <Mic size={20} color="#8B4513" />
            </TouchableOpacity>
          </View>
        </View>

        {/* Browse Categories */}
        <View style={styles.browseSection}>
          <Text style={styles.sectionTitle}>Browse</Text>
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            style={styles.categoriesScrollView}
          >
            <View style={styles.categoriesContainer}>
              {categories.map((category, index) => {
                const theme = getCulturalTheme(category.culture);
                return (
                  <TouchableOpacity
                    key={index}
                    style={styles.categoryTile}
                    onPress={() => router.push(`/search?category=${encodeURIComponent(category.name)}`)}
                  >
                    <Image source={{ uri: category.image }} style={styles.categoryImage} />
                    <LinearGradient
                      colors={['transparent', ...theme.colors.map(color => color + 'CC')]}
                      style={styles.categoryOverlay}
                    >
                      <View style={styles.categoryContent}>
                        <Text style={styles.categoryIcon}>{category.icon}</Text>
                        <Text style={styles.categoryName}>{category.name}</Text>
                        {category.culture !== 'general' && (
                          <View style={styles.culturalBadge}>
                            <Text style={styles.culturalBadgeText}>
                              {category.culture.toUpperCase()}
                            </Text>
                          </View>
                        )}
                      </View>
                    </LinearGradient>
                  </TouchableOpacity>
                );
              })}
            </View>
          </ScrollView>
        </View>

        {/* Popular Recipes */}
        <View style={styles.popularSection}>
          <Text style={styles.sectionTitle}>Popular Recipes</Text>
          <View style={styles.popularGrid}>
            {popularRecipes.map((recipe) => {
              const theme = getCulturalTheme(recipe.culture);
              return (
                <TouchableOpacity
                  key={recipe.id}
                  style={styles.popularCard}
                  onPress={() => router.push(`/recipe-detail?id=${recipe.id}`)}
                >
                  <Image source={{ uri: recipe.image }} style={styles.popularImage} />
                  <LinearGradient
                    colors={['transparent', ...theme.colors.map(color => color + 'E6')]}
                    style={styles.popularOverlay}
                  >
                    <View style={styles.popularInfo}>
                      <View style={styles.culturalHeader}>
                        <Text style={styles.culturalPattern}>{theme.pattern}</Text>
                        <Text style={styles.culturalLabel}>
                          {recipe.culture.toUpperCase()} STYLE
                        </Text>
                      </View>
                      <Text style={styles.popularName}>{recipe.name}</Text>
                      <View style={styles.popularStats}>
                        <View style={styles.popularStat}>
                          <Clock size={14} color="#F5E6D3" />
                          <Text style={styles.popularStatText}>{recipe.time}</Text>
                        </View>
                        <View style={styles.popularStat}>
                          <Star size={14} color="#FFD700" />
                          <Text style={styles.popularStatText}>{recipe.rating}</Text>
                        </View>
                      </View>
                    </View>
                  </LinearGradient>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>

        {/* All Recipes */}
        <View style={styles.allRecipesSection}>
          <Text style={styles.sectionTitle}>All Recipes</Text>
          <View style={styles.recipesGrid}>
            {recipes.map((recipe) => {
              const theme = getCulturalTheme(recipe.culture);
              return (
                <TouchableOpacity
                  key={recipe.id}
                  style={[styles.recipeCard, { borderLeftColor: theme.accentColor }]}
                  onPress={() => router.push(`/recipe-detail?id=${recipe.id}`)}
                >
                  <Image source={{ uri: recipe.image }} style={styles.recipeImage} />
                  <View style={styles.recipeInfo}>
                    <View style={styles.recipeHeader}>
                      <Text style={styles.recipeName}>{recipe.name}</Text>
                      <View style={[styles.culturalTag, { backgroundColor: theme.accentColor }]}>
                        <Text style={styles.culturalTagText}>
                          {recipe.culture.toUpperCase()}
                        </Text>
                      </View>
                    </View>
                    <Text style={styles.recipeDescription} numberOfLines={2}>
                      {recipe.description}
                    </Text>
                    <View style={styles.recipeStats}>
                      <View style={styles.recipeStat}>
                        <Clock size={14} color="#8B4513" />
                        <Text style={styles.recipeStatText}>{recipe.time}</Text>
                      </View>
                      <View style={styles.recipeStat}>
                        {getDifficultyHats(recipe.difficulty)}
                      </View>
                      <View style={styles.recipeStat}>
                        <Star size={14} color="#FFD700" />
                        <Text style={styles.recipeStatText}>{recipe.rating}</Text>
                      </View>
                    </View>
                  </View>
                  <TouchableOpacity 
                    style={styles.favoriteButton}
                    onPress={(e) => {
                      e.stopPropagation();
                      toggleFavorite(recipe.id);
                    }}
                  >
                    <Heart 
                      size={20} 
                      color={favorites.includes(recipe.id) ? '#E74C3C' : '#DDD'} 
                      fill={favorites.includes(recipe.id) ? '#E74C3C' : 'transparent'}
                    />
                  </TouchableOpacity>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5E6D3',
  },
  content: {
    flex: 1,
    paddingTop: 60,
  },
  header: {
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  headerTitle: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#8B4513',
  },
  searchContainer: {
    paddingHorizontal: 20,
    marginBottom: 25,
  },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 25,
    paddingHorizontal: 20,
    paddingVertical: 15,
    gap: 12,
    elevation: 2,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#6B3410',
  },
  voiceButton: {
    padding: 5,
  },
  browseSection: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#8B4513',
    marginBottom: 20,
  },
  categoriesScrollView: {
    marginBottom: 10,
  },
  categoriesContainer: {
    flexDirection: 'row',
    gap: 15,
    paddingRight: 20,
  },
  categoryTile: {
    width: 140,
    height: 120,
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 4,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 6,
  },
  categoryImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  categoryOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    top: 0,
    justifyContent: 'flex-end',
    padding: 12,
  },
  categoryContent: {
    alignItems: 'center',
  },
  categoryIcon: {
    fontSize: 24,
    marginBottom: 5,
  },
  categoryName: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#F5E6D3',
    textAlign: 'center',
    marginBottom: 4,
  },
  culturalBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
  },
  culturalBadgeText: {
    fontSize: 8,
    fontWeight: 'bold',
    color: '#F5E6D3',
  },
  popularSection: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  popularGrid: {
    gap: 15,
  },
  popularCard: {
    height: 220,
    borderRadius: 24,
    overflow: 'hidden',
    elevation: 6,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 12,
    marginBottom: 15,
  },
  popularImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  popularOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    top: 0,
    justifyContent: 'flex-end',
    padding: 24,
  },
  popularInfo: {
    gap: 8,
  },
  culturalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  culturalPattern: {
    fontSize: 16,
    opacity: 0.8,
  },
  culturalLabel: {
    fontSize: 10,
    fontWeight: 'bold',
    color: '#F5E6D3',
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 10,
  },
  popularName: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#F5E6D3',
  },
  popularStats: {
    flexDirection: 'row',
    gap: 15,
  },
  popularStat: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  popularStatText: {
    fontSize: 14,
    color: '#F5E6D3',
    fontWeight: '500',
  },
  allRecipesSection: {
    paddingHorizontal: 20,
    marginBottom: 30,
  },
  recipesGrid: {
    gap: 15,
  },
  recipeCard: {
    flexDirection: 'row',
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 15,
    elevation: 2,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    overflow: 'hidden',
    borderLeftWidth: 4,
  },
  recipeImage: {
    width: 100,
    height: 100,
    resizeMode: 'cover',
  },
  recipeInfo: {
    flex: 1,
    padding: 15,
    justifyContent: 'space-between',
  },
  recipeHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 5,
  },
  recipeName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#8B4513',
    flex: 1,
    marginRight: 10,
  },
  culturalTag: {
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
  },
  culturalTagText: {
    fontSize: 8,
    fontWeight: 'bold',
    color: 'white',
  },
  recipeDescription: {
    fontSize: 14,
    color: '#6B3410',
    lineHeight: 18,
    marginBottom: 10,
  },
  recipeStats: {
    flexDirection: 'row',
    gap: 15,
  },
  recipeStat: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  recipeStatText: {
    fontSize: 12,
    color: '#8B4513',
    fontWeight: '500',
  },
  favoriteButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    padding: 5,
  },
});
</file>

<file path="app/+not-found.tsx/+not-found.tsx">
import { Link, Stack } from 'expo-router';
import { StyleSheet, Text, View } from 'react-native';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <View style={styles.container}>
        <Text style={styles.text}>This screen doesn't exist.</Text>
        <Link href="/" style={styles.link}>
          <Text>Go to home screen!</Text>
        </Link>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  text: {
    fontSize: 20,
    fontWeight: 600,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
</file>

<file path="app/api/upload-photo+api.ts/upload-photo+api.ts">
export async function POST(request: Request) {
  console.log('üì∏ Photo upload API called');
  
  try {
    const formData = await request.formData();
    const photo = formData.get('photo') as File;
    const recipeId = formData.get('recipeId') as string;
    const currentStep = formData.get('currentStep') as string;
    const mama = formData.get('mama') as string;
    
    if (!photo) {
      return new Response(JSON.stringify({ 
        success: false, 
        error: 'No photo provided' 
      }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    console.log('üì∏ Photo received:', {
      name: photo.name,
      size: photo.size,
      type: photo.type,
      recipeId,
      currentStep,
      mama
    });

    // Convert photo to base64 for processing
    const arrayBuffer = await photo.arrayBuffer();
    const base64 = Buffer.from(arrayBuffer).toString('base64');
    const mimeType = photo.type;
    
    // For now, we'll just return a success response
    // In the future, this is where you'd integrate with OpenAI Vision API
    // to analyze the photo and provide cooking feedback
    
    const responses = {
      nonna_lucia: [
        "Bello! That looks wonderful, amore! You're doing great!",
        "Perfetto! Just like my nonna used to make, tesoro!",
        "Mamma mia! Beautiful work, caro! Keep going!",
        "Ecco! That's exactly right, amore mio!"
      ],
      abuela_rosa: [
        "¬°√ìrale! That looks delicious, mijo! You're a natural!",
        "¬°Qu√© rico! Perfect technique, coraz√≥n!",
        "¬°Genial! Just like I taught you, amor!",
        "¬°Ay, s√≠! Beautiful work, mi nieto!"
      ],
      mae_malai: [
        "Aroi! That looks perfect, dear! Well done!",
        "Chai! Beautiful color and texture, sweetheart!",
        "Sabai sabai! You're doing wonderfully, little one!",
        "Dee mak! Just like Mae would make it!"
      ]
    };

    const mamaResponses = responses[mama as keyof typeof responses] || responses.nonna_lucia;
    const randomResponse = mamaResponses[Math.floor(Math.random() * mamaResponses.length)];

    return new Response(JSON.stringify({
      success: true,
      message: randomResponse,
      analysis: {
        confidence: 0.95,
        feedback: "Your cooking technique looks excellent! The color and texture are perfect for this step.",
        suggestions: ["Continue with the next step", "The timing looks just right"]
      }
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('‚ùå Photo upload error:', error);
    
    return new Response(JSON.stringify({
      success: false,
      error: 'Failed to process photo'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="app/index.tsx/index.tsx">
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Image } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import { ChefHat, Heart, Utensils } from 'lucide-react-native';
import * as WebBrowser from 'expo-web-browser';

export default function WelcomeScreen() {
  const router = useRouter();

  const handleBoltPress = async () => {
    await WebBrowser.openBrowserAsync('https://bolt.new/');
  };

  return (
    <LinearGradient
      colors={['#F5E6D3', '#E8D5C4', '#DCC5B0']}
      style={styles.container}
    >
      <View style={styles.content}>
        <View style={styles.logoContainer}>
          <View style={styles.logoWrapper}>
            <Text style={styles.logoText}>MAMIA</Text>
            <View style={styles.logoAccent} />
          </View>
          <Text style={styles.tagline}>Cooking with the Spirit of Care</Text>
        </View>

        <View style={styles.descriptionContainer}>
          <Text style={styles.description}>
            Learn authentic recipes from Italian Nonna, Mexican Abuela, and Thai Mae with hands-on guidance and cultural stories
          </Text>
          
          <View style={styles.featuresContainer}>
            <View style={styles.feature}>
              <Utensils size={28} color="#8B4513" />
              <Text style={styles.featureText}>Voice-guided cooking</Text>
            </View>
            <View style={styles.feature}>
              <Heart size={28} color="#8B4513" />
              <Text style={styles.featureText}>Cultural stories</Text>
            </View>
            <View style={styles.feature}>
              <ChefHat size={28} color="#8B4513" />
              <Text style={styles.featureText}>Authentic recipes</Text>
            </View>
          </View>
        </View>

        <TouchableOpacity 
          style={styles.startButton}
          onPress={() => router.push('/mama-selection')}
        >
          <LinearGradient
            colors={['#8B4513', '#6B3410']}
            style={styles.buttonGradient}
          >
            <Text style={styles.buttonText}>Enter the Kitchen</Text>
          </LinearGradient>
        </TouchableOpacity>

        <View style={styles.trustIndicators}>
          <Text style={styles.trustText}>Trusted by home cooks worldwide</Text>
          <View style={styles.trustStats}>
            <Text style={styles.trustStat}>10k+ recipes mastered</Text>
            <Text style={styles.trustDivider}>‚Ä¢</Text>
            <Text style={styles.trustStat}>3 cultural traditions</Text>
          </View>
        </View>
      </View>
      
      {/* Bolt Logo - Bottom Right Corner */}
      <TouchableOpacity 
        style={styles.bottomRightBoltContainer}
        onPress={handleBoltPress}
        activeOpacity={0.8}
      >
        <Image 
          source={require('../assets/images/white_circle_360x360.png')}
          style={styles.bottomRightBoltLogo}
          resizeMode="contain"
        />
      </TouchableOpacity>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 50,
  },
  logoWrapper: {
    alignItems: 'center',
    position: 'relative',
    marginBottom: 20,
  },
  logoText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#8B4513',
    letterSpacing: 4,
  },
  logoAccent: {
    width: 60,
    height: 4,
    backgroundColor: '#D2691E',
    borderRadius: 2,
    marginTop: 8,
  },
  tagline: {
    fontSize: 20,
    color: '#8B4513',
    fontStyle: 'italic',
    fontWeight: '600',
    letterSpacing: 1,
  },
  descriptionContainer: {
    alignItems: 'center',
    marginBottom: 60,
    paddingHorizontal: 10,
  },
  description: {
    fontSize: 18,
    textAlign: 'center',
    color: '#6B3410',
    lineHeight: 28,
    marginBottom: 40,
    paddingHorizontal: 10,
    fontWeight: '400',
  },
  featuresContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
    maxWidth: 320,
  },
  feature: {
    alignItems: 'center',
    gap: 12,
    flex: 1,
  },
  bottomRightBoltContainer: {
    position: 'absolute',
    bottom: 30,
    right: 30,
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
    elevation: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.4,
    shadowRadius: 12,
    borderWidth: 2,
    borderColor: 'rgba(139, 69, 19, 0.1)',
  },
  bottomRightBoltLogo: {
    width: 100,
    height: 100,
  },
  featureText: {
    fontSize: 14,
    color: '#6B3410',
    fontWeight: '600',
    textAlign: 'center',
    lineHeight: 18,
  },
  startButton: {
    width: '85%',
    maxWidth: 320,
    height: 56,
    borderRadius: 28,
    overflow: 'hidden',
    marginBottom: 30,
    elevation: 4,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  buttonGradient: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonText: {
    color: '#F5E6D3',
    fontSize: 18,
    fontWeight: 'bold',
    letterSpacing: 0.5,
  },
  trustIndicators: {
    alignItems: 'center',
    opacity: 0.8,
  },
  trustText: {
    fontSize: 14,
    color: '#8B4513',
    marginBottom: 8,
    fontWeight: '500',
  },
  trustStats: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  trustStat: {
    fontSize: 12,
    color: '#A0522D',
    fontWeight: '500',
  },
  trustDivider: {
    fontSize: 12,
    color: '#A0522D',
  }
});
</file>

<file path="app/mama-selection.tsx/mama-selection.tsx">
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import { ArrowLeft, Search, ChefHat } from 'lucide-react-native';

const mamas = [
  {
    id: 'italian',
    name: 'ITALIAN',
    subtitle: 'NONNA',
    firstName: 'Lucia',
    title: 'Traditional Italian Cook',
    description: 'From rolling pasta to rolling eyes. She\'s warm, opinionated, and always ready to feed you... whether you\'re hungry or not.',
    signature: 'Classic Carbonara',
    signatureDescription: 'Authentic Roman pasta with eggs, cheese, and pancetta - a family secret passed down for generations',
    phrase: '"A tavola non s\'invecchia"',
    translation: '(At the table, one does not grow old)',
    colors: ['#E67E22', '#D35400'],
    accentColor: '#C0392B',
    pattern: 'üçÖüåø',
    cookingEmoji: 'üçù',
    avatar: 'üëµüèª',
  },
  {
    id: 'mexican',
    name: 'MEXICAN',
    subtitle: 'ABUELA',
    firstName: 'Rosa',
    title: 'Traditional Mexican Cook',
    description: 'From rolling tortillas to rolling with laughter. She\'s nurturing, spirited, and believes every meal should be a celebration... even breakfast.',
    signature: 'Mole Poblano',
    signatureDescription: 'Complex sauce with chocolate and 20+ spices - the crown jewel of Mexican cuisine',
    phrase: '"El amor entra por la cocina"',
    translation: '(Love enters through the kitchen)',
    colors: ['#27AE60', '#229954'],
    accentColor: '#E74C3C',
    pattern: 'üå∂Ô∏èüíÄ',
    cookingEmoji: 'üåÆ',
    avatar: 'üëµüèΩ',
  },
  {
    id: 'thai',
    name: 'THAI',
    subtitle: 'MAE',
    firstName: 'Malai',
    title: 'Traditional Thai Cook',
    description: 'From balancing flavors to balancing life. She\'s gentle, wise, and knows that the secret ingredient is always patience... and a little extra chili.',
    signature: 'Traditional Green Curry',
    signatureDescription: 'Authentic Thai curry with perfect balance of sweet, sour, salty, and spicy flavors',
    phrase: '"‡∏Å‡∏¥‡∏ô‡∏Ç‡πâ‡∏≤‡∏ß‡∏Å‡∏±‡∏ô"',
    translation: '(Let\'s eat together)',
    colors: ['#F39C12', '#E67E22'],
    accentColor: '#D68910',
    pattern: 'üå∏üçÉ',
    cookingEmoji: 'üçõ',
    avatar: 'üëµüèª',
  },
];

export default function MamaSelectionScreen() {
  const router = useRouter();

  const handleMamaSelect = (mamaId: string) => {
    router.push(`/(tabs)?mama=${mamaId}`);
  };

  return (
    <LinearGradient
      colors={['#F5E6D3', '#E8D5C4']}
      style={styles.container}
    >
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <ArrowLeft size={24} color="#8B4513" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>MAMIA</Text>
        <TouchableOpacity style={styles.searchButton}>
          <Search size={24} color="#8B4513" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Title Section */}
        <View style={styles.titleSection}>
          <Text style={styles.mainTitle}>Choose Your{'\n'}Cooking Guide</Text>
          <Text style={styles.subtitle}>Learn authentic recipes from traditional cooks</Text>
        </View>

        {/* Horizontal Carousel */}
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          style={styles.carouselContainer}
          contentContainerStyle={styles.carouselContent}
          snapToInterval={320}
          decelerationRate="fast"
          pagingEnabled={false}
        >
          {mamas.map((mama, index) => (
            <View
              key={mama.id}
              style={[styles.mamaCard, { marginLeft: index === 0 ? 20 : 0 }]}
            >
              <LinearGradient
                colors={mama.colors}
                style={styles.cardGradient}
              >
                {/* Decorative Header */}
                <View style={styles.decorativeHeader}>
                  <Text style={styles.patternLeft}>{mama.pattern.split('')[0]}</Text>
                  <Text style={styles.ethnicityLabel}>{mama.name}</Text>
                  <Text style={styles.patternRight}>{mama.pattern.split('')[1]}</Text>
                </View>

                {/* Character Illustration - Back to Emoji */}
                <View style={styles.characterSection}>
                  <View style={styles.characterContainer}>
                    <View style={styles.characterCircle}>
                      <Text style={styles.characterEmoji}>{mama.avatar}</Text>
                    </View>
                    <View style={styles.cookingAccessory}>
                      <Text style={styles.cookingEmoji}>{mama.cookingEmoji}</Text>
                    </View>
                  </View>
                </View>

                {/* Name Section - Single Line */}
                <View style={styles.nameSection}>
                  <Text style={styles.mamaFullName}>
                    {mama.subtitle} {mama.firstName}
                  </Text>
                </View>

                {/* Character Description */}
                <View style={styles.descriptionSection}>
                  <Text style={styles.characterDescription}>{mama.description}</Text>
                </View>

                {/* Signature Dish */}
                <View style={styles.signatureSection}>
                  <Text style={styles.signatureLabel}>Signature Dish</Text>
                  <Text style={styles.signatureName}>{mama.signature}</Text>
                </View>

                {/* Mama Phrase */}
                <View style={styles.phraseSection}>
                  <Text style={styles.phraseLabel}>Mama Says</Text>
                  <Text style={styles.phrase}>{mama.phrase}</Text>
                  <Text style={styles.translation}>{mama.translation}</Text>
                </View>

                {/* CTA Button - Fixed at bottom */}
                <View style={styles.ctaContainer}>
                  <TouchableOpacity 
                    style={styles.ctaButton}
                    onPress={() => handleMamaSelect(mama.id)}
                  >
                    <View style={styles.ctaButtonContent}>
                      <ChefHat size={18} color={mama.colors[0]} />
                      <Text style={[styles.ctaButtonText, { color: mama.colors[0] }]}>
                        Open {mama.firstName}'s Cookbook
                      </Text>
                    </View>
                  </TouchableOpacity>
                </View>
              </LinearGradient>
            </View>
          ))}
        </ScrollView>

        {/* Bottom Section */}
        <View style={styles.bottomSection}>
          <Text style={styles.bottomText}>
            Each guide brings decades of cooking wisdom and authentic family recipes passed down through generations
          </Text>
          
          <TouchableOpacity style={styles.exploreButton}>
            <LinearGradient
              colors={['#8B4513', '#6B3410']}
              style={styles.exploreButtonGradient}
            >
              <Text style={styles.exploreButtonText}>Explore All Traditions</Text>
            </LinearGradient>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  backButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#8B4513',
    letterSpacing: 2,
  },
  searchButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    flex: 1,
  },
  titleSection: {
    paddingHorizontal: 20,
    marginBottom: 40,
    alignItems: 'center',
  },
  mainTitle: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#2C3E50',
    lineHeight: 38,
    textAlign: 'center',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#6B3410',
    textAlign: 'center',
    fontWeight: '500',
  },
  carouselContainer: {
    marginBottom: 40,
  },
  carouselContent: {
    paddingRight: 20,
  },
  mamaCard: {
    width: 300,
    height: 600,
    marginRight: 20,
    borderRadius: 28,
    overflow: 'hidden',
    elevation: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.4,
    shadowRadius: 20,
  },
  cardGradient: {
    flex: 1,
    padding: 20,
  },
  decorativeHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  patternLeft: {
    fontSize: 22,
    opacity: 0.8,
  },
  ethnicityLabel: {
    fontSize: 14,
    fontWeight: 'bold',
    color: 'white',
    letterSpacing: 2,
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 12,
  },
  patternRight: {
    fontSize: 22,
    opacity: 0.8,
  },
  characterSection: {
    alignItems: 'center',
    marginBottom: 15,
  },
  characterContainer: {
    position: 'relative',
    alignItems: 'center',
  },
  characterCircle: {
    width: 90,
    height: 90,
    borderRadius: 45,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 4,
    borderColor: 'rgba(255, 255, 255, 0.4)',
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 5 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
  },
  characterEmoji: {
    fontSize: 48,
  },
  cookingAccessory: {
    position: 'absolute',
    bottom: -8,
    right: -8,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    borderColor: 'rgba(255, 255, 255, 0.5)',
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  cookingEmoji: {
    fontSize: 16,
  },
  nameSection: {
    alignItems: 'center',
    marginBottom: 15,
  },
  mamaFullName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: 'white',
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 3,
  },
  descriptionSection: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    borderRadius: 12,
    padding: 12,
    marginBottom: 15,
  },
  characterDescription: {
    fontSize: 13,
    color: 'rgba(255, 255, 255, 0.95)',
    lineHeight: 18,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  signatureSection: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    borderRadius: 12,
    padding: 12,
    marginBottom: 15,
  },
  signatureLabel: {
    fontSize: 11,
    color: 'rgba(255, 255, 255, 0.8)',
    fontWeight: 'bold',
    textTransform: 'uppercase',
    letterSpacing: 1,
    marginBottom: 6,
  },
  signatureName: {
    fontSize: 16,
    color: 'white',
    fontWeight: 'bold',
  },
  phraseSection: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    borderRadius: 12,
    padding: 12,
    marginBottom: 15,
    borderLeftWidth: 4,
    borderLeftColor: 'rgba(255, 255, 255, 0.6)',
  },
  phraseLabel: {
    fontSize: 11,
    color: 'rgba(255, 255, 255, 0.8)',
    fontWeight: 'bold',
    textTransform: 'uppercase',
    letterSpacing: 1,
    marginBottom: 6,
  },
  phrase: {
    fontSize: 14,
    color: 'white',
    fontWeight: 'bold',
    fontStyle: 'italic',
    marginBottom: 3,
  },
  translation: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.9)',
    fontStyle: 'italic',
  },
  ctaContainer: {
    marginTop: 'auto',
    paddingTop: 10,
  },
  ctaButton: {
    backgroundColor: 'white',
    borderRadius: 22,
    paddingVertical: 14,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
  },
  ctaButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
  },
  ctaButtonText: {
    fontSize: 15,
    fontWeight: 'bold',
  },
  bottomSection: {
    paddingHorizontal: 20,
    paddingVertical: 30,
    alignItems: 'center',
  },
  bottomText: {
    fontSize: 16,
    color: '#6B3410',
    textAlign: 'center',
    lineHeight: 24,
    fontStyle: 'italic',
    marginBottom: 25,
  },
  exploreButton: {
    borderRadius: 25,
    overflow: 'hidden',
  },
  exploreButtonGradient: {
    paddingHorizontal: 30,
    paddingVertical: 15,
  },
  exploreButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
</file>

<file path="app/recipe-detail.tsx/recipe-detail.tsx">
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, Image } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { 
  ArrowLeft, 
  Clock, 
  ChefHat, 
  Star, 
  Users, 
  Play, 
  Heart,
  Share2,
  ShoppingCart,
  Timer
} from 'lucide-react-native';

const recipeData = {
  1: {
    id: 1,
    name: 'Classic Carbonara',
    culture: 'italian',
    mama: 'nonna_lucia',
    image: 'https://i.imgur.com/UWR05kt.jpg',
    difficulty: 2,
    time: '25 min',
    servings: 4,
    rating: 4.8,
    description: 'A traditional Roman pasta dish made with eggs, cheese, pancetta, and black pepper. This authentic recipe has been passed down through generations of Italian families.',
    story: 'Carbonara was born in Rome during World War II. Legend says it was created by Italian charcoal workers (carbonari) who needed a hearty meal using simple ingredients they could carry with them.',
    ingredients: [
      { item: 'Spaghetti or Linguine', amount: '400g' },
      { item: 'Pancetta or Guanciale', amount: '150g' },
      { item: 'Large Eggs', amount: '4' },
      { item: 'Pecorino Romano Cheese', amount: '100g' },
      { item: 'Black Pepper', amount: '1 tsp' },
      { item: 'Salt', amount: 'to taste' },
      { item: 'Extra Virgin Olive Oil', amount: '2 tbsp' }
    ],
    instructions: [
      'Fill a large pot with water and bring to a rolling boil. Add a generous amount of salt.',
      'While water heats, cut pancetta into small cubes and cook in a large pan until crispy.',
      'In a bowl, whisk together eggs, grated Pecorino Romano, and freshly ground black pepper.',
      'Cook pasta according to package directions until al dente. Reserve 1 cup of pasta water.',
      'Drain pasta and immediately add to the pan with pancetta. Remove from heat.',
      'Quickly add the egg mixture while tossing pasta. Add pasta water gradually until creamy.',
      'Serve immediately with extra cheese and black pepper. Buon appetito!'
    ],
    tips: [
      'Never add cream to authentic carbonara',
      'Work quickly when adding eggs to prevent scrambling',
      'Use freshly grated Pecorino Romano for best flavor',
      'Save some pasta water - it\'s the secret to perfect sauce'
    ],
    nutrition: {
      calories: 520,
      protein: '22g',
      carbs: '65g',
      fat: '18g'
    },
    chef: 'Nonna Lucia',
    chefAvatar: 'üëµüèª'
  },
  2: {
    id: 2,
    name: 'Nonna\'s Minestrone',
    culture: 'italian',
    mama: 'nonna_lucia',
    image: 'https://i.imgur.com/zj23RzP.jpg',
    difficulty: 1,
    time: '45 min',
    servings: 6,
    rating: 4.9,
    description: 'A hearty Italian vegetable soup that changes with the seasons. This version uses whatever vegetables are fresh and available.',
    story: 'Minestrone means "big soup" in Italian. Every nonna has her own version, using whatever vegetables are in season. It\'s a soup of love and resourcefulness.',
    ingredients: [
      { item: 'Olive Oil', amount: '3 tbsp' },
      { item: 'Onion, diced', amount: '1 large' },
      { item: 'Carrots, diced', amount: '2' },
      { item: 'Celery, diced', amount: '2 stalks' },
      { item: 'Garlic, minced', amount: '3 cloves' },
      { item: 'Canned Tomatoes', amount: '400g' },
      { item: 'Vegetable Broth', amount: '1.5L' },
      { item: 'Cannellini Beans', amount: '400g' },
      { item: 'Small Pasta', amount: '100g' },
      { item: 'Fresh Basil', amount: '1/4 cup' },
      { item: 'Parmesan Cheese', amount: '50g' }
    ],
    instructions: [
      'Heat olive oil in a large pot over medium heat.',
      'Add onion, carrots, and celery. Cook until softened, about 8 minutes.',
      'Add garlic and cook for another minute until fragrant.',
      'Add tomatoes, breaking them up with a spoon. Cook for 5 minutes.',
      'Pour in broth and bring to a boil. Add beans and simmer for 15 minutes.',
      'Add pasta and cook until al dente, about 10 minutes.',
      'Stir in fresh basil and season with salt and pepper.',
      'Serve hot with grated Parmesan cheese.'
    ],
    tips: [
      'Use seasonal vegetables for best flavor',
      'Let the soup rest overnight - it tastes even better the next day',
      'Add pasta just before serving to prevent mushiness',
      'Drizzle with good olive oil before serving'
    ],
    nutrition: {
      calories: 280,
      protein: '12g',
      carbs: '45g',
      fat: '8g'
    },
    chef: 'Nonna Lucia',
    chefAvatar: 'üëµüèª'
  },
  3: {
    id: 3,
    name: 'Tacos al Pastor',
    culture: 'mexican',
    mama: 'abuela_rosa',
    image: 'https://images.pexels.com/photos/4958792/pexels-photo-4958792.jpeg',
    difficulty: 2,
    time: '35 min',
    servings: 4,
    rating: 4.7,
    description: 'Traditional Mexican tacos with marinated pork, pineapple, and fresh cilantro. A street food favorite that brings authentic flavors to your kitchen.',
    story: 'Tacos al Pastor originated from Lebanese immigrants in Mexico who adapted their shawarma technique. The vertical trompo and pineapple addition make it uniquely Mexican.',
    ingredients: [
      { item: 'Pork Shoulder', amount: '1 kg' },
      { item: 'Pineapple', amount: '1/2 fresh' },
      { item: 'Corn Tortillas', amount: '12' },
      { item: 'White Onion', amount: '1 medium' },
      { item: 'Fresh Cilantro', amount: '1/2 cup' },
      { item: 'Lime', amount: '2 limes' },
      { item: 'Achiote Paste', amount: '2 tbsp' },
      { item: 'Orange Juice', amount: '1/4 cup' },
      { item: 'Garlic', amount: '3 cloves' },
      { item: 'Chipotle Peppers', amount: '2' },
      { item: 'Salt', amount: 'to taste' }
    ],
    instructions: [
      'Blend achiote paste, orange juice, garlic, chipotle peppers, and salt to make marinade.',
      'Cut pork into thin slices and marinate for at least 2 hours or overnight.',
      'Cook marinated pork in a hot skillet until edges are crispy, about 8-10 minutes.',
      'Grill pineapple slices until caramelized, then dice into small pieces.',
      'Warm tortillas on a comal or dry skillet until pliable.',
      'Dice onion finely and chop cilantro.',
      'Assemble tacos with pork, pineapple, onion, and cilantro.',
      'Serve with lime wedges and your favorite salsa.'
    ],
    tips: [
      'Marinate the pork overnight for maximum flavor',
      'Get the pork crispy on the edges for authentic texture',
      'Fresh pineapple is essential - canned won\'t give the same flavor',
      'Warm your tortillas properly for the best experience'
    ],
    nutrition: {
      calories: 380,
      protein: '28g',
      carbs: '32g',
      fat: '16g'
    },
    chef: 'Abuela Rosa',
    chefAvatar: 'üëµüèΩ'
  },
  4: {
    id: 4,
    name: 'Green Curry',
    culture: 'thai',
    mama: 'mae_malai',
    image: 'https://i.imgur.com/ORMJpqJ.jpg',
    difficulty: 2,
    time: '35 min',
    servings: 4,
    rating: 4.6,
    description: 'Aromatic Thai curry with coconut milk and fresh herbs',
    story: 'Green curry is one of Thailand\'s most beloved dishes, known for its perfect balance of spicy, sweet, and aromatic flavors.',
    ingredients: [
      { item: 'Coconut Milk', amount: '400ml' },
      { item: 'Green Curry Paste', amount: '2 tbsp' },
      { item: 'Chicken Thigh', amount: '300g' },
      { item: 'Thai Eggplant', amount: '1 cup' },
      { item: 'Green Beans', amount: '100g' },
      { item: 'Thai Basil', amount: '1/4 cup' },
      { item: 'Fish Sauce', amount: '1 tbsp' },
      { item: 'Palm Sugar', amount: '1 tbsp' }
    ],
    instructions: [
      'Heat coconut milk in a wok until oil separates.',
      'Add curry paste and fry until fragrant.',
      'Add chicken and cook until done.',
      'Add vegetables and remaining coconut milk.',
      'Season with fish sauce and palm sugar.',
      'Garnish with Thai basil and serve.'
    ],
    tips: [
      'Use fresh curry paste for best flavor',
      'Don\'t overcook the vegetables',
      'Taste and adjust seasoning as you go'
    ],
    nutrition: {
      calories: 380,
      protein: '25g',
      carbs: '15g',
      fat: '28g'
    },
    chef: 'Mae Malai',
    chefAvatar: 'üëµüèª'
  },
  5: {
    id: 5,
    name: 'Traditional Green Curry',
    culture: 'thai',
    mama: 'mae_malai',
    image: 'https://images.pexels.com/photos/2116093/pexels-photo-2116093.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',
    difficulty: 2,
    time: '45 min',
    servings: 4,
    rating: 4.8,
    description: 'Authentic Thai green curry with coconut milk, fresh herbs, and your choice of protein. A perfect balance of spicy, sweet, and aromatic flavors.',
    story: 'Green curry, or "gaeng keow wan" in Thai, represents the heart of Thai cuisine - the perfect balance of flavors. Mae Malai learned this recipe from her grandmother in Bangkok, where fresh ingredients and patience create culinary magic.',
    ingredients: [
      { item: 'Coconut Milk', amount: '400ml' },
      { item: 'Green Curry Paste', amount: '2-3 tbsp' },
      { item: 'Chicken Thigh (or Tofu)', amount: '300g' },
      { item: 'Thai Eggplant, sliced', amount: '1 medium' },
      { item: 'Green Beans, trimmed', amount: '100g' },
      { item: 'Kaffir Lime Leaves', amount: '2 leaves' },
      { item: 'Fish Sauce', amount: '1 tbsp' },
      { item: 'Palm Sugar', amount: '1 tbsp' },
      { item: 'Thai Basil Leaves', amount: '1/4 cup' },
      { item: 'Red Chili, sliced', amount: '1 piece' },
      { item: 'Jasmine Rice', amount: 'for serving' }
    ],
    instructions: [
      'Heat 1/3 of coconut milk in wok over medium heat until oil separates, about 3-4 minutes.',
      'Add green curry paste and fry until fragrant and aromatic, about 2 minutes.',
      'Add chicken pieces and cook until just done and coated with paste, about 5 minutes.',
      'Pour in remaining coconut milk and bring to gentle simmer.',
      'Add eggplant and green beans, cook for 8-10 minutes until vegetables are tender.',
      'Season with fish sauce and palm sugar, taste and adjust for perfect balance.',
      'Add kaffir lime leaves and simmer 2 more minutes to infuse flavors.',
      'Garnish with fresh Thai basil and sliced chili, serve immediately with jasmine rice.'
    ],
    tips: [
      'Fresh curry paste makes all the difference - look for it in Asian markets',
      'Don\'t rush the coconut milk - let it separate naturally for rich flavor',
      'Balance is key: sweet, salty, spicy, and aromatic should harmonize',
      'Thai eggplant has the best texture, but regular eggplant works too'
    ],
    nutrition: {
      calories: 420,
      protein: '28g',
      carbs: '18g',
      fat: '30g'
    },
    chef: 'Mae Malai',
    chefAvatar: 'üëµüèª'
  },
  7: {
    id: 7,
    name: 'Risotto alla Milanese',
    culture: 'italian',
    mama: 'nonna_lucia',
    image: 'https://images.pexels.com/photos/1586942/pexels-photo-1586942.jpeg?auto=compress&cs=tinysrgb&w=600',
    difficulty: 3,
    time: '40 min',
    servings: 4,
    rating: 4.7,
    description: 'Creamy saffron risotto from Northern Italy',
    story: 'This golden risotto is a signature dish of Milan, traditionally served with osso buco.',
    ingredients: [
      { item: 'Arborio Rice', amount: '320g' },
      { item: 'Saffron Threads', amount: '1/2 tsp' },
      { item: 'Beef Stock', amount: '1.5L' },
      { item: 'White Wine', amount: '150ml' },
      { item: 'Onion', amount: '1 small' },
      { item: 'Butter', amount: '60g' },
      { item: 'Parmesan', amount: '80g' }
    ],
    instructions: [
      'Heat stock and keep warm. Soak saffron in 2 tbsp warm stock.',
      'Saut√© diced onion in butter until translucent.',
      'Add rice and toast for 2 minutes until edges are translucent.',
      'Add wine and stir until absorbed.',
      'Add warm stock one ladle at a time, stirring constantly.',
      'After 18 minutes, add saffron mixture.',
      'Finish with butter and Parmesan. Serve immediately.'
    ],
    tips: [
      'Use good quality saffron for authentic color and flavor',
      'Stir constantly for creamy texture',
      'Rice should be al dente, not mushy'
    ],
    nutrition: {
      calories: 380,
      protein: '12g',
      carbs: '65g',
      fat: '8g'
    },
    chef: 'Nonna Lucia',
    chefAvatar: 'üëµüèª'
  },
  8: {
    id: 8,
    name: 'Pozole Rojo',
    culture: 'mexican',
    mama: 'abuela_rosa',
    image: 'https://i.imgur.com/yCR4wf6.jpg',
    difficulty: 2,
    time: '2.5 hours',
    servings: 6,
    rating: 4.6,
    description: 'Traditional hominy soup for celebrations',
    story: 'Pozole is a ceremonial dish with ancient roots, traditionally served during special occasions.',
    ingredients: [
      { item: 'Pork Shoulder', amount: '1 kg' },
      { item: 'Hominy', amount: '2 cans' },
      { item: 'Guajillo Chiles', amount: '6' },
      { item: 'Ancho Chiles', amount: '3' },
      { item: 'Garlic', amount: '4 cloves' },
      { item: 'White Onion', amount: '1 large' },
      { item: 'Bay Leaves', amount: '2' }
    ],
    instructions: [
      'Simmer pork with onion and bay leaves for 2 hours.',
      'Toast and soak chiles, then blend with garlic.',
      'Strain chile mixture and add to pot.',
      'Add hominy and simmer 30 minutes.',
      'Shred pork and return to pot.',
      'Season with salt and serve with garnishes.'
    ],
    tips: [
      'Don\'t skip toasting the chiles',
      'Garnish with cabbage, radishes, and lime',
      'Tastes better the next day'
    ],
    nutrition: {
      calories: 420,
      protein: '35g',
      carbs: '25g',
      fat: '20g'
    },
    chef: 'Abuela Rosa',
    chefAvatar: 'üëµüèΩ'
  },
  9: {
    id: 9,
    name: 'Tom Yum Goong',
    culture: 'thai',
    mama: 'mae_malai',
    image: 'https://i.imgur.com/2pB8HIc.jpg',
    difficulty: 2,
    time: '30 min',
    servings: 4,
    rating: 4.8,
    description: 'Spicy and sour shrimp soup with lemongrass',
    story: 'Tom Yum is Thailand\'s most famous soup, balancing hot, sour, salty, and sweet flavors.',
    ingredients: [
      { item: 'Shrimp', amount: '400g' },
      { item: 'Lemongrass', amount: '3 stalks' },
      { item: 'Kaffir Lime Leaves', amount: '4' },
      { item: 'Galangal', amount: '3 slices' },
      { item: 'Thai Chilies', amount: '3-5' },
      { item: 'Fish Sauce', amount: '2 tbsp' },
      { item: 'Lime Juice', amount: '3 tbsp' }
    ],
    instructions: [
      'Bring water to boil with lemongrass, galangal, and lime leaves.',
      'Add chilies and simmer 5 minutes.',
      'Add shrimp and cook until pink.',
      'Season with fish sauce and lime juice.',
      'Garnish with cilantro and serve hot.'
    ],
    tips: [
      'Don\'t boil after adding lime juice',
      'Adjust chilies to taste',
      'Fresh herbs are essential'
    ],
    nutrition: {
      calories: 180,
      protein: '25g',
      carbs: '8g',
      fat: '2g'
    },
    chef: 'Mae Malai',
    chefAvatar: 'üëµüèª'
  }
};

const mamaThemes = {
  italian: {
    colors: ['#E67E22', '#D35400'],
    bgColors: ['#f9f5ee', '#f5f1ea'],
    accentColor: '#bb9457',
    textColor: '#7d5a3c',
    lightTextColor: '#6b4f30',
  },
  mexican: {
    colors: ['#16A085', '#148F77'],
    bgColors: ['#f0f8f5', '#ecf5f1'],
    accentColor: '#16a085',
    textColor: '#2d5a4a',
    lightTextColor: '#3a6b5a',
  },
  thai: {
    colors: ['#F39C12', '#E67E22'],
    bgColors: ['#fffbf0', '#fef8eb'],
    accentColor: '#e6ac00',
    textColor: '#8b6914',
    lightTextColor: '#a67c00',
  }
};

export default function RecipeDetailScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const [isFavorited, setIsFavorited] = useState(false);
  const [activeTab, setActiveTab] = useState('ingredients');

  const recipeId = parseInt(params.id as string);
  const recipe = recipeData[recipeId as keyof typeof recipeData];

  if (!recipe) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Recipe not found</Text>
        <TouchableOpacity onPress={() => router.push('/(tabs)/recipes')}>
          <Text style={styles.backText}>Go to Recipes</Text>
        </TouchableOpacity>
      </View>
    );
  }

  const theme = mamaThemes[recipe.culture as keyof typeof mamaThemes];

  const getDifficultyHats = (difficulty: number) => {
    return Array(3).fill(0).map((_, index) => (
      <ChefHat 
        key={index} 
        size={16} 
        color={index < difficulty ? theme.accentColor : '#DDD'} 
      />
    ));
  };

  const handleStartCooking = () => {
    router.push(`/cooking?recipeId=${recipe.id}&mama=${recipe.mama}`);
  };

  const handleBackPress = () => {
    // FIXED: Navigate back to the correct mama's cookbook based on recipe's mama
    if (recipe.mama) {
      console.log('üîô Navigating back to', recipe.mama, 'cookbook from recipe', recipe.name);
      router.push(`/(tabs)?mama=${recipe.mama}`);
    } else if (router.canGoBack()) {
      router.back();
    } else {
      // Fallback to recipes tab
      router.push('/(tabs)/recipes');
    }
  };

  const renderTabContent = () => {
    switch (activeTab) {
      case 'ingredients':
        return (
          <View style={styles.tabContent}>
            {recipe.ingredients.map((ingredient, index) => (
              <View key={index} style={styles.ingredientItem}>
                <View style={styles.ingredientCheckbox} />
                <Text style={[styles.ingredientAmount, { color: theme.accentColor }]}>
                  {ingredient.amount}
                </Text>
                <Text style={[styles.ingredientName, { color: theme.textColor }]}>
                  {ingredient.item}
                </Text>
              </View>
            ))}
            
            {/* Mama's Tips Section */}
            <View style={[styles.mamaTipsContainer, { backgroundColor: theme.bgColors[1] }]}>
              <Text style={[styles.mamaTipsTitle, { color: theme.accentColor }]}>
                {recipe.chef.split(' ')[0]}'s Tips
              </Text>
              {recipe.tips.map((tip, index) => (
                <Text key={index} style={[styles.mamaTipText, { color: theme.lightTextColor }]}>
                  ‚Ä¢ {tip}
                </Text>
              ))}
            </View>
          </View>
        );
      case 'instructions':
        return (
          <View style={styles.tabContent}>
            {recipe.instructions.map((step, index) => (
              <View key={index} style={styles.instructionItem}>
                <View style={[styles.stepNumber, { backgroundColor: theme.accentColor }]}>
                  <Text style={styles.stepNumberText}>{index + 1}</Text>
                </View>
                <Text style={[styles.instructionText, { color: theme.textColor }]}>{step}</Text>
              </View>
            ))}
          </View>
        );
      case 'story':
        return (
          <View style={styles.tabContent}>
            <Text style={[styles.storyText, { color: theme.textColor }]}>{recipe.story}</Text>
          </View>
        );
      default:
        return null;
    }
  };

  return (
    <View style={[styles.container, { backgroundColor: theme.bgColors[0] }]}>
      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Header Image */}
        <View style={styles.imageContainer}>
          <Image source={{ uri: recipe.image }} style={styles.recipeImage} />
          <LinearGradient
            colors={['transparent', 'rgba(0,0,0,0.7)']}
            style={styles.imageOverlay}
          >
            <TouchableOpacity 
              style={styles.backButton}
              onPress={handleBackPress}
            >
              <ArrowLeft size={24} color="white" />
            </TouchableOpacity>
            
            <View style={styles.imageActions}>
              <TouchableOpacity 
                style={styles.actionButton}
                onPress={() => setIsFavorited(!isFavorited)}
              >
                <Heart 
                  size={24} 
                  color={isFavorited ? '#E74C3C' : 'white'} 
                  fill={isFavorited ? '#E74C3C' : 'transparent'}
                />
              </TouchableOpacity>
              <TouchableOpacity style={styles.actionButton}>
                <Share2 size={24} color="white" />
              </TouchableOpacity>
            </View>
          </LinearGradient>
        </View>

        {/* Recipe Card */}
        <View style={[styles.recipeCard, { backgroundColor: theme.bgColors[0] }]}>
          {/* Watermark Pattern */}
          <View style={styles.watermarkContainer}>
            <Text style={styles.watermark}>üçù</Text>
          </View>

          {/* Recipe Header with Mama Icon */}
          <View style={styles.recipeHeader}>
            <View style={styles.titleContainer}>
              <Text style={[styles.recipeName, { color: theme.textColor }]}>
                {recipe.name}
              </Text>
              <View style={styles.mamaIcon}>
                <Text style={styles.mamaAvatar}>{recipe.chefAvatar}</Text>
              </View>
            </View>
            <Text style={[styles.recipeDescription, { color: theme.lightTextColor }]}>
              {recipe.description}
            </Text>
          </View>

          {/* Decorative Divider */}
          <View style={[styles.divider, { backgroundColor: theme.accentColor }]} />

          {/* Recipe Stats */}
          <View style={styles.statsContainer}>
            <View style={styles.statsRow}>
              <View style={styles.statItem}>
                <Users size={20} color={theme.accentColor} />
                <Text style={[styles.statText, { color: theme.textColor }]}>
                  Serves {recipe.servings}
                </Text>
              </View>
              <View style={styles.statItem}>
                <Clock size={20} color={theme.accentColor} />
                <Text style={[styles.statText, { color: theme.textColor }]}>
                  {recipe.time}
                </Text>
              </View>
              <View style={styles.statItem}>
                {getDifficultyHats(recipe.difficulty)}
                <Text style={[styles.statText, { color: theme.textColor }]}>
                  {recipe.difficulty === 1 ? 'Easy' : recipe.difficulty === 2 ? 'Medium' : 'Hard'}
                </Text>
              </View>
            </View>
          </View>

          {/* Start Cooking Button - Now Centered */}
          <View style={styles.startCookingContainer}>
            <TouchableOpacity 
              style={[styles.startCookingButton, { backgroundColor: theme.accentColor }]}
              onPress={handleStartCooking}
            >
              <Play size={18} color="white" />
              <Text style={styles.startCookingText}>
                Start Cooking with {recipe.chef.split(' ')[0]}
              </Text>
            </TouchableOpacity>
          </View>

          {/* Tabs */}
          <View style={styles.tabsContainer}>
            {['ingredients', 'instructions', 'story'].map((tab) => (
              <TouchableOpacity
                key={tab}
                style={[
                  styles.tab,
                  activeTab === tab && { backgroundColor: theme.accentColor }
                ]}
                onPress={() => setActiveTab(tab)}
              >
                <Text style={[
                  styles.tabText,
                  { color: activeTab === tab ? 'white' : theme.textColor }
                ]}>
                  {tab.charAt(0).toUpperCase() + tab.slice(1)}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {/* Tab Content */}
          {renderTabContent()}

          {/* Signature */}
          <View style={styles.signatureContainer}>
            <View style={[styles.divider, { backgroundColor: theme.accentColor }]} />
            <View style={styles.signature}>
              <Text style={[styles.signatureText, { color: theme.accentColor }]}>
                ‚Äî With love, {recipe.chef}
              </Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    fontSize: 18,
    color: '#E74C3C',
    marginBottom: 20,
  },
  backText: {
    fontSize: 16,
    color: '#3498DB',
    textDecorationLine: 'underline',
  },
  imageContainer: {
    height: 280,
    position: 'relative',
  },
  recipeImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  imageOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'space-between',
    padding: 20,
    paddingTop: 60,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    alignSelf: 'flex-start',
  },
  imageActions: {
    flexDirection: 'row',
    gap: 10,
    alignSelf: 'flex-end',
  },
  actionButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  recipeCard: {
    marginTop: -20,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    paddingHorizontal: 24,
    paddingTop: 32,
    paddingBottom: 40,
    position: 'relative',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -5 },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 10,
  },
  watermarkContainer: {
    position: 'absolute',
    top: 40,
    right: 40,
    opacity: 0.05,
    zIndex: 0,
  },
  watermark: {
    fontSize: 120,
  },
  recipeHeader: {
    marginBottom: 24,
    zIndex: 1,
  },
  titleContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  recipeName: {
    fontSize: 32,
    fontWeight: 'bold',
    flex: 1,
    lineHeight: 38,
  },
  mamaIcon: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  mamaAvatar: {
    fontSize: 24,
  },
  recipeDescription: {
    fontSize: 16,
    lineHeight: 24,
    fontStyle: 'italic',
  },
  divider: {
    height: 1,
    width: '60%',
    alignSelf: 'center',
    marginVertical: 24,
    opacity: 0.3,
  },
  statsContainer: {
    marginBottom: 24,
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  statText: {
    fontSize: 14,
    fontWeight: '500',
  },
  startCookingContainer: {
    alignItems: 'center',
    marginBottom: 32,
  },
  startCookingButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    paddingHorizontal: 24,
    paddingVertical: 14,
    borderRadius: 25,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  startCookingText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  tabsContainer: {
    flexDirection: 'row',
    backgroundColor: '#f8f8f8',
    borderRadius: 25,
    padding: 4,
    marginBottom: 24,
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 20,
    alignItems: 'center',
  },
  tabText: {
    fontSize: 14,
    fontWeight: '500',
  },
  tabContent: {
    marginBottom: 32,
  },
  ingredientItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  ingredientCheckbox: {
    width: 18,
    height: 18,
    borderRadius: 4,
    borderWidth: 2,
    borderColor: '#bb9457',
    backgroundColor: '#ede3d2',
    marginRight: 12,
  },
  ingredientAmount: {
    fontSize: 16,
    fontWeight: 'bold',
    width: 80,
  },
  ingredientName: {
    fontSize: 16,
    flex: 1,
  },
  mamaTipsContainer: {
    marginTop: 32,
    padding: 20,
    borderRadius: 16,
    borderLeftWidth: 4,
    borderLeftColor: '#bb9457',
  },
  mamaTipsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  mamaTipText: {
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 8,
  },
  instructionItem: {
    flexDirection: 'row',
    marginBottom: 20,
    gap: 15,
  },
  stepNumber: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 2,
  },
  stepNumberText: {
    color: 'white',
    fontSize: 14,
    fontWeight: 'bold',
  },
  instructionText: {
    fontSize: 16,
    lineHeight: 24,
    flex: 1,
  },
  storyText: {
    fontSize: 16,
    lineHeight: 26,
    fontStyle: 'italic',
    textAlign: 'justify',
  },
  signatureContainer: {
    marginTop: 32,
  },
  signature: {
    alignItems: 'flex-end',
    marginTop: 16,
  },
  signatureText: {
    fontSize: 18,
    fontStyle: 'italic',
    fontWeight: '500',
  },
});
</file>

<file path="app/search.tsx/search.tsx">
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView, TextInput } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import { 
  Search, 
  ArrowLeft, 
  Clock, 
  ChefHat, 
  Star, 
  Filter,
  Mic,
  X
} from 'lucide-react-native';

const allRecipes = [
  {
    id: 1,
    name: 'Classic Carbonara',
    category: 'Pasta & Sauces',
    difficulty: 2,
    time: '25 min',
    rating: 4.8,
    image: 'üçù',
    culture: 'italian',
    tags: ['pasta', 'eggs', 'cheese', 'quick', 'traditional'],
  },
  {
    id: 2,
    name: 'Nonna\'s Minestrone',
    category: 'Comfort Foods',
    difficulty: 1,
    time: '45 min',
    rating: 4.9,
    image: 'üç≤',
    culture: 'italian',
    tags: ['soup', 'vegetables', 'healthy', 'comfort'],
  },
  {
    id: 3,
    name: 'Tacos al Pastor',
    category: 'Tacos & Salsas',
    difficulty: 3,
    time: '2 hours',
    rating: 4.7,
    image: 'üåÆ',
    culture: 'mexican',
    tags: ['pork', 'spicy', 'traditional', 'street food'],
  },
  {
    id: 4,
    name: 'Green Curry',
    category: 'Curries',
    difficulty: 2,
    time: '35 min',
    rating: 4.6,
    image: 'üçõ',
    culture: 'thai',
    tags: ['curry', 'coconut', 'spicy', 'aromatic'],
  },
  {
    id: 5,
    name: 'Mole Poblano',
    category: 'Traditional Dishes',
    difficulty: 3,
    time: '3 hours',
    rating: 4.9,
    image: 'üå∂Ô∏è',
    culture: 'mexican',
    tags: ['chocolate', 'complex', 'traditional', 'celebration'],
  },
  {
    id: 6,
    name: 'Pad Thai',
    category: 'Stir-fries',
    difficulty: 2,
    time: '20 min',
    rating: 4.5,
    image: 'üçú',
    culture: 'thai',
    tags: ['noodles', 'sweet', 'sour', 'quick'],
  },
  {
    id: 7,
    name: 'Risotto alla Milanese',
    category: 'Pasta & Sauces',
    difficulty: 3,
    time: '40 min',
    rating: 4.7,
    image: 'üçö',
    culture: 'italian',
    tags: ['rice', 'saffron', 'creamy', 'elegant'],
  },
  {
    id: 8,
    name: 'Chicken Mole',
    category: 'Traditional Dishes',
    difficulty: 2,
    time: '1.5 hours',
    rating: 4.6,
    image: 'üçó',
    culture: 'mexican',
    tags: ['chicken', 'sauce', 'traditional', 'family'],
  },
];

const cuisineTypes = ['All', 'Italian', 'Mexican', 'Thai'];
const difficultyLevels = ['All', 'Beginner', 'Intermediate', 'Advanced'];
const cookingTimes = ['All', 'Under 30 min', '30-60 min', 'Over 1 hour'];
const popularTags = ['quick', 'traditional', 'spicy', 'comfort', 'healthy', 'vegetarian'];

export default function SearchScreen() {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCuisine, setSelectedCuisine] = useState('All');
  const [selectedDifficulty, setSelectedDifficulty] = useState('All');
  const [selectedTime, setSelectedTime] = useState('All');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [showFilters, setShowFilters] = useState(false);

  const filteredRecipes = allRecipes.filter(recipe => {
    const matchesSearch = recipe.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         recipe.category.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         recipe.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
    
    const matchesCuisine = selectedCuisine === 'All' || 
                          recipe.culture.toLowerCase() === selectedCuisine.toLowerCase();
    
    const matchesDifficulty = selectedDifficulty === 'All' || 
                             (selectedDifficulty === 'Beginner' && recipe.difficulty === 1) ||
                             (selectedDifficulty === 'Intermediate' && recipe.difficulty === 2) ||
                             (selectedDifficulty === 'Advanced' && recipe.difficulty === 3);
    
    const matchesTime = selectedTime === 'All' ||
                       (selectedTime === 'Under 30 min' && parseInt(recipe.time) < 30) ||
                       (selectedTime === '30-60 min' && parseInt(recipe.time) >= 30 && parseInt(recipe.time) <= 60) ||
                       (selectedTime === 'Over 1 hour' && (recipe.time.includes('hour') || parseInt(recipe.time) > 60));
    
    const matchesTags = selectedTags.length === 0 || 
                       selectedTags.some(tag => recipe.tags.includes(tag));

    return matchesSearch && matchesCuisine && matchesDifficulty && matchesTime && matchesTags;
  });

  const getDifficultyHats = (difficulty: number) => {
    return Array(3).fill(0).map((_, index) => (
      <ChefHat 
        key={index} 
        size={16} 
        color={index < difficulty ? '#E67E22' : '#DDD'} 
      />
    ));
  };

  const toggleTag = (tag: string) => {
    setSelectedTags(prev => 
      prev.includes(tag) 
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
  };

  const clearFilters = () => {
    setSelectedCuisine('All');
    setSelectedDifficulty('All');
    setSelectedTime('All');
    setSelectedTags([]);
  };

  return (
    <LinearGradient
      colors={['#FFF8E1', '#FFE0B2']}
      style={styles.container}
    >
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <ArrowLeft size={24} color="#E67E22" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Search Recipes</Text>
        <TouchableOpacity 
          style={styles.filterButton}
          onPress={() => setShowFilters(!showFilters)}
        >
          <Filter size={24} color="#E67E22" />
        </TouchableOpacity>
      </View>

      <View style={styles.searchContainer}>
        <View style={styles.searchBar}>
          <Search size={20} color="#8B4513" />
          <TextInput
            style={styles.searchInput}
            placeholder="Search recipes, ingredients, or cuisine..."
            placeholderTextColor="#8B4513"
            value={searchQuery}
            onChangeText={setSearchQuery}
          />
          <TouchableOpacity style={styles.voiceButton}>
            <Mic size={20} color="#E67E22" />
          </TouchableOpacity>
        </View>
      </View>

      {showFilters && (
        <View style={styles.filtersContainer}>
          <ScrollView showsVerticalScrollIndicator={false}>
            {/* Cuisine Filter */}
            <View style={styles.filterSection}>
              <Text style={styles.filterTitle}>Cuisine</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={styles.filterOptions}>
                  {cuisineTypes.map((cuisine) => (
                    <TouchableOpacity
                      key={cuisine}
                      style={[
                        styles.filterChip,
                        selectedCuisine === cuisine && styles.selectedFilterChip
                      ]}
                      onPress={() => setSelectedCuisine(cuisine)}
                    >
                      <Text style={[
                        styles.filterChipText,
                        selectedCuisine === cuisine && styles.selectedFilterChipText
                      ]}>
                        {cuisine}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </ScrollView>
            </View>

            {/* Difficulty Filter */}
            <View style={styles.filterSection}>
              <Text style={styles.filterTitle}>Difficulty</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={styles.filterOptions}>
                  {difficultyLevels.map((difficulty) => (
                    <TouchableOpacity
                      key={difficulty}
                      style={[
                        styles.filterChip,
                        selectedDifficulty === difficulty && styles.selectedFilterChip
                      ]}
                      onPress={() => setSelectedDifficulty(difficulty)}
                    >
                      <Text style={[
                        styles.filterChipText,
                        selectedDifficulty === difficulty && styles.selectedFilterChipText
                      ]}>
                        {difficulty}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </ScrollView>
            </View>

            {/* Time Filter */}
            <View style={styles.filterSection}>
              <Text style={styles.filterTitle}>Cooking Time</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={styles.filterOptions}>
                  {cookingTimes.map((time) => (
                    <TouchableOpacity
                      key={time}
                      style={[
                        styles.filterChip,
                        selectedTime === time && styles.selectedFilterChip
                      ]}
                      onPress={() => setSelectedTime(time)}
                    >
                      <Text style={[
                        styles.filterChipText,
                        selectedTime === time && styles.selectedFilterChipText
                      ]}>
                        {time}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </ScrollView>
            </View>

            {/* Tags Filter */}
            <View style={styles.filterSection}>
              <Text style={styles.filterTitle}>Popular Tags</Text>
              <View style={styles.tagsContainer}>
                {popularTags.map((tag) => (
                  <TouchableOpacity
                    key={tag}
                    style={[
                      styles.tagChip,
                      selectedTags.includes(tag) && styles.selectedTagChip
                    ]}
                    onPress={() => toggleTag(tag)}
                  >
                    <Text style={[
                      styles.tagChipText,
                      selectedTags.includes(tag) && styles.selectedTagChipText
                    ]}>
                      {tag}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <TouchableOpacity style={styles.clearFiltersButton} onPress={clearFilters}>
              <Text style={styles.clearFiltersText}>Clear All Filters</Text>
            </TouchableOpacity>
          </ScrollView>
        </View>
      )}

      <View style={styles.resultsHeader}>
        <Text style={styles.resultsCount}>
          {filteredRecipes.length} recipe{filteredRecipes.length !== 1 ? 's' : ''} found
        </Text>
      </View>

      <ScrollView style={styles.recipesContainer} showsVerticalScrollIndicator={false}>
        {filteredRecipes.map((recipe) => (
          <TouchableOpacity
            key={recipe.id}
            style={styles.recipeCard}
            onPress={() => router.push(`/recipe-detail?id=${recipe.id}`)}
          >
            <LinearGradient
              colors={['#FFFFFF', '#F8F8F8']}
              style={styles.cardGradient}
            >
              <View style={styles.recipeHeader}>
                <Text style={styles.recipeImage}>{recipe.image}</Text>
                <View style={styles.recipeInfo}>
                  <Text style={styles.recipeName}>{recipe.name}</Text>
                  <Text style={styles.recipeCategory}>{recipe.category}</Text>
                  <View style={styles.recipeTags}>
                    {recipe.tags.slice(0, 2).map((tag, index) => (
                      <View key={index} style={styles.recipeTag}>
                        <Text style={styles.recipeTagText}>{tag}</Text>
                      </View>
                    ))}
                  </View>
                </View>
              </View>

              <View style={styles.recipeDetails}>
                <View style={styles.detailItem}>
                  <Clock size={16} color="#8B4513" />
                  <Text style={styles.detailText}>{recipe.time}</Text>
                </View>
                <View style={styles.detailItem}>
                  {getDifficultyHats(recipe.difficulty)}
                </View>
                <View style={styles.detailItem}>
                  <Star size={16} color="#FFD700" />
                  <Text style={styles.detailText}>{recipe.rating}</Text>
                </View>
              </View>
            </LinearGradient>
          </TouchableOpacity>
        ))}

        {filteredRecipes.length === 0 && (
          <View style={styles.noResultsContainer}>
            <Text style={styles.noResultsText}>No recipes found</Text>
            <Text style={styles.noResultsSubtext}>
              Try adjusting your search or filters
            </Text>
          </View>
        )}
      </ScrollView>
    </LinearGradient>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  backButton: {
    padding: 10,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#E67E22',
  },
  filterButton: {
    padding: 10,
  },
  searchContainer: {
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 25,
    paddingHorizontal: 15,
    paddingVertical: 12,
    gap: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#5D4037',
  },
  voiceButton: {
    padding: 5,
  },
  filtersContainer: {
    backgroundColor: 'white',
    marginHorizontal: 20,
    borderRadius: 15,
    padding: 20,
    marginBottom: 20,
    maxHeight: 300,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  filterSection: {
    marginBottom: 20,
  },
  filterTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#5D4037',
    marginBottom: 10,
  },
  filterOptions: {
    flexDirection: 'row',
    gap: 10,
  },
  filterChip: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#F0F0F0',
  },
  selectedFilterChip: {
    backgroundColor: '#E67E22',
  },
  filterChipText: {
    fontSize: 14,
    color: '#5D4037',
    fontWeight: '500',
  },
  selectedFilterChipText: {
    color: 'white',
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  tagChip: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 15,
    backgroundColor: '#F0F0F0',
  },
  selectedTagChip: {
    backgroundColor: '#E67E22',
  },
  tagChipText: {
    fontSize: 12,
    color: '#5D4037',
    fontWeight: '500',
  },
  selectedTagChipText: {
    color: 'white',
  },
  clearFiltersButton: {
    alignItems: 'center',
    paddingVertical: 10,
  },
  clearFiltersText: {
    fontSize: 14,
    color: '#E67E22',
    fontWeight: '600',
    textDecorationLine: 'underline',
  },
  resultsHeader: {
    paddingHorizontal: 20,
    marginBottom: 15,
  },
  resultsCount: {
    fontSize: 16,
    color: '#5D4037',
    fontWeight: '500',
  },
  recipesContainer: {
    flex: 1,
    paddingHorizontal: 20,
  },
  recipeCard: {
    marginBottom: 15,
    borderRadius: 15,
    overflow: 'hidden',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  cardGradient: {
    padding: 15,
  },
  recipeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
  },
  recipeImage: {
    fontSize: 40,
    marginRight: 15,
  },
  recipeInfo: {
    flex: 1,
  },
  recipeName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#5D4037',
    marginBottom: 5,
  },
  recipeCategory: {
    fontSize: 14,
    color: '#8B4513',
    marginBottom: 8,
  },
  recipeTags: {
    flexDirection: 'row',
    gap: 5,
  },
  recipeTag: {
    backgroundColor: '#E67E22',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  recipeTagText: {
    fontSize: 10,
    color: 'white',
    fontWeight: '500',
  },
  recipeDetails: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 5,
  },
  detailText: {
    fontSize: 14,
    color: '#5D4037',
    fontWeight: '500',
  },
  noResultsContainer: {
    alignItems: 'center',
    paddingVertical: 40,
  },
  noResultsText: {
    fontSize: 18,
    color: '#8B4513',
    fontWeight: '600',
    marginBottom: 10,
  },
  noResultsSubtext: {
    fontSize: 14,
    color: '#8B4513',
    textAlign: 'center',
  },
});
</file>

<file path="app.json/app.json">
{
  "expo": {
    "name": "Mamia - Cook with Soul",
    "slug": "mamia-cooking-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "mamia",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.mamia.cookingapp"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/icon.png",
        "backgroundColor": "#F5E6D3"
      },
      "package": "com.mamia.cookingapp"
    },
    "web": {
      "bundler": "metro",
      "output": "server",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router", 
      "expo-font", 
      "expo-web-browser",
      [
        "expo-dev-client",
        {
          "addGeneratedScheme": false
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {
        "origin": false
      },
      "eas": {
        "projectId": "your-project-id"
      }
    }
  }
}
</file>

<file path="components/AdaptiveUI.tsx/AdaptiveUI.tsx">
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';
import { CookingContext } from '@/hooks/useCookingContext';

interface AdaptiveUIProps {
  context: CookingContext;
  children: React.ReactNode;
  style?: ViewStyle;
}

export default function AdaptiveUI({ context, children, style }: AdaptiveUIProps) {
  const getAdaptiveStyles = () => {
    const { stage, adaptiveSettings } = context;
    
    let adaptiveStyle: ViewStyle = {};

    // Adjust opacity based on screen brightness setting
    if (adaptiveSettings.screenBrightness < 1) {
      adaptiveStyle.opacity = Math.max(0.7, adaptiveSettings.screenBrightness);
    }

    // Hide non-essential elements during active cooking
    if (stage === 'active') {
      // This would be handled by individual components checking context
      // but we can set global styles here
    }

    // Emphasize timers during monitoring stage
    if (stage === 'monitoring') {
      // Timer components would check this context
    }

    return adaptiveStyle;
  };

  return (
    <View style={[styles.container, getAdaptiveStyles(), style]}>
      {children}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
</file>

<file path="components/ContextAwareVoiceInterface.tsx/ContextAwareVoiceInterface.tsx">
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Animated } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Mic, Volume2, CircleHelp as HelpCircle, Zap, MicOff, TriangleAlert as AlertTriangle, RefreshCw } from 'lucide-react-native';
import ContextAwareVoiceService, { VoiceContext, VoiceListeningState } from '@/services/ContextAwareVoiceService';

interface ContextAwareVoiceInterfaceProps {
  onCommand: (command: string, action: string) => void;
  currentStep: number;
  totalSteps: number;
  isNonnaSpeaking?: boolean;
  cookingState: VoiceListeningState;
}

export default function ContextAwareVoiceInterface({ 
  onCommand, 
  currentStep, 
  totalSteps, 
  isNonnaSpeaking = false,
  cookingState
}: ContextAwareVoiceInterfaceProps) {
  const [voiceContext, setVoiceContext] = useState<VoiceContext>({
    state: 'idle',
    isListening: false,
    requiresWakeWord: true,
    availableCommands: [],
    recognitionStatus: 'idle'
  });

  // Animation values
  const [pulseAnim] = useState(new Animated.Value(1));
  const [waveAnim] = useState(new Animated.Value(0));
  const [errorShakeAnim] = useState(new Animated.Value(0));

  useEffect(() => {
    // Set up voice service callbacks
    ContextAwareVoiceService.setStatusCallback(setVoiceContext);
    ContextAwareVoiceService.setCommandCallback(onCommand);

    // Update cooking context when props change
    ContextAwareVoiceService.setCookingContext(cookingState, {
      currentStep,
      totalSteps,
      isNonnaSpeaking
    });

    return () => {
      ContextAwareVoiceService.cleanup();
    };
  }, [onCommand, currentStep, totalSteps, isNonnaSpeaking, cookingState]);

  // Pulse animation for listening state
  useEffect(() => {
    if (voiceContext.isListening) {
      const pulse = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 800,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 800,
            useNativeDriver: true,
          }),
        ])
      );
      pulse.start();
      return () => pulse.stop();
    } else {
      pulseAnim.setValue(1);
    }
  }, [voiceContext.isListening, pulseAnim]);

  // Wave animation for speaking state
  useEffect(() => {
    if (isNonnaSpeaking) {
      const wave = Animated.loop(
        Animated.timing(waveAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        })
      );
      wave.start();
      return () => wave.stop();
    } else {
      waveAnim.setValue(0);
    }
  }, [isNonnaSpeaking, waveAnim]);

  // Shake animation for error state
  useEffect(() => {
    if (voiceContext.recognitionStatus === 'error') {
      const shake = Animated.sequence([
        Animated.timing(errorShakeAnim, {
          toValue: 10,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(errorShakeAnim, {
          toValue: -10,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(errorShakeAnim, {
          toValue: 10,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(errorShakeAnim, {
          toValue: 0,
          duration: 100,
          useNativeDriver: true,
        }),
      ]);
      shake.start();
    }
  }, [voiceContext.recognitionStatus, errorShakeAnim]);

  const handleVoiceToggle = () => {
    if (!ContextAwareVoiceService.isAvailable()) return;

    if (voiceContext.recognitionStatus === 'error') {
      // Clear error and retry
      ContextAwareVoiceService.clearError();
      ContextAwareVoiceService.startListening();
    } else if (voiceContext.state === 'speaking') {
      // Interrupt Nonna
      ContextAwareVoiceService.triggerManualCommand();
    } else if (voiceContext.isListening) {
      // Stop listening
      ContextAwareVoiceService.stopListening();
    } else {
      // Start listening
      ContextAwareVoiceService.startListening();
    }
  };

  const getStateConfig = () => {
    switch (voiceContext.recognitionStatus) {
      case 'error':
        return {
          colors: ['#E74C3C', '#C0392B'],
          icon: <AlertTriangle size={24} color="white" />,
          title: '‚ö†Ô∏è Voice Error',
          subtitle: voiceContext.errorMessage || 'Speech recognition error',
          commandsTitle: 'Suggestions:',
          showWakeWordHint: false,
          borderColor: '#E74C3C',
          isError: true,
        };
      case 'processing':
        return {
          colors: ['#9B59B6', '#8E44AD'],
          icon: <RefreshCw size={24} color="white" />,
          title: 'üîÑ Processing...',
          subtitle: 'Understanding your command',
          commandsTitle: 'Processing voice input...',
          showWakeWordHint: false,
          borderColor: '#9B59B6',
        };
      default:
        break;
    }

    switch (voiceContext.state) {
      case 'cooking':
        return {
          colors: ['#27AE60', '#229954'],
          icon: <Mic size={24} color="white" />,
          title: 'üç≥ Cooking Mode',
          subtitle: voiceContext.isListening ? 'Always listening - no wake word needed' : 'Tap to start listening',
          commandsTitle: 'Say directly:',
          showWakeWordHint: false,
          borderColor: '#27AE60',
        };
      case 'speaking':
        return {
          colors: ['#E67E22', '#D35400'],
          icon: <Volume2 size={24} color="white" />,
          title: 'üó£Ô∏è Nonna Speaking',
          subtitle: 'Say "Hey Nonna" to interrupt or tap here',
          commandsTitle: 'To interrupt:',
          showWakeWordHint: true,
          borderColor: '#E67E22',
        };
      case 'idle':
        return {
          colors: ['#3498DB', '#2980B9'],
          icon: <HelpCircle size={24} color="white" />,
          title: 'üò¥ Ready to Help',
          subtitle: 'Say "Hey Nonna" + your question',
          commandsTitle: 'Try saying:',
          showWakeWordHint: true,
          borderColor: '#3498DB',
        };
      default:
        return {
          colors: ['#95A5A6', '#7F8C8D'],
          icon: <MicOff size={24} color="white" />,
          title: '‚ùå Voice Unavailable',
          subtitle: 'Browser does not support voice commands',
          commandsTitle: '',
          showWakeWordHint: false,
          borderColor: '#95A5A6',
        };
    }
  };

  const config = getStateConfig();

  const renderSoundWaves = () => {
    if (!isNonnaSpeaking) return null;

    const waves = [0, 1, 2, 3, 4, 5, 6, 7];
    
    return (
      <View style={styles.soundWaves}>
        {waves.map((index) => (
          <Animated.View
            key={index}
            style={[
              styles.soundWave,
              {
                height: waveAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [4, Math.random() * 20 + 8],
                }),
                opacity: waveAnim.interpolate({
                  inputRange: [0, 0.5, 1],
                  outputRange: [0.3, 1, 0.3],
                }),
              },
            ]}
          />
        ))}
      </View>
    );
  };

  const renderErrorSuggestions = () => {
    if (voiceContext.recognitionStatus !== 'error' || !voiceContext.suggestions) {
      return null;
    }

    return (
      <View style={styles.errorSuggestions}>
        {voiceContext.suggestions.map((suggestion, index) => (
          <View key={index} style={styles.suggestionItem}>
            <Text style={styles.suggestionBullet}>‚Ä¢</Text>
            <Text style={styles.suggestionText}>{suggestion}</Text>
          </View>
        ))}
        <TouchableOpacity 
          style={styles.retryButton}
          onPress={() => ContextAwareVoiceService.triggerManualCommand()}
        >
          <RefreshCw size={16} color="#E74C3C" />
          <Text style={styles.retryButtonText}>Try Again</Text>
        </TouchableOpacity>
      </View>
    );
  };

  if (!ContextAwareVoiceService.isAvailable()) {
    return (
      <View style={styles.unavailableContainer}>
        <Text style={styles.unavailableText}>Voice commands not supported in this browser</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Performance indicator */}
      <View style={styles.performanceIndicator}>
        <Zap size={12} color="#E67E22" />
        <Text style={styles.performanceText}>
          Status: {voiceContext.recognitionStatus.toUpperCase()}
        </Text>
      </View>

      {/* Sound waves when Nonna is speaking */}
      {renderSoundWaves()}

      {/* Main voice interface */}
      <Animated.View
        style={[
          styles.voiceCard,
          {
            borderColor: config.borderColor,
            transform: [
              { scale: voiceContext.isListening ? pulseAnim : 1 },
              { translateX: voiceContext.recognitionStatus === 'error' ? errorShakeAnim : 0 }
            ]
          }
        ]}
      >
        <TouchableOpacity
          style={styles.voiceButton}
          onPress={handleVoiceToggle}
        >
          <LinearGradient
            colors={config.colors}
            style={styles.voiceGradient}
          >
            <View style={styles.voiceContent}>
              <View style={styles.iconContainer}>
                {config.icon}
              </View>
              
              <View style={styles.textContainer}>
                <Text style={styles.voiceTitle}>{config.title}</Text>
                <Text style={styles.voiceSubtitle}>{config.subtitle}</Text>
              </View>
            </View>
          </LinearGradient>
        </TouchableOpacity>
      </Animated.View>

      {/* Error suggestions */}
      {renderErrorSuggestions()}

      {/* Available commands */}
      {voiceContext.recognitionStatus !== 'error' && (
        <View style={styles.commandsContainer}>
          <Text style={styles.commandsTitle}>{config.commandsTitle}</Text>
          <View style={styles.commandsList}>
            {voiceContext.availableCommands.slice(0, 4).map((command, index) => (
              <View key={index} style={styles.commandChip}>
                {config.showWakeWordHint && !command.includes('Interrupt') && (
                  <Text style={styles.wakeWordHint}>Hey Nonna, </Text>
                )}
                <Text style={styles.commandText}>{command.replace('Hey Nonna, ', '')}</Text>
              </View>
            ))}
          </View>
        </View>
      )}

      {/* Context help */}
      <View style={styles.contextHelp}>
        <Text style={styles.contextHelpText}>
          {voiceContext.recognitionStatus === 'error' && '‚ö†Ô∏è Voice recognition needs attention'}
          {voiceContext.recognitionStatus === 'processing' && 'üîÑ Processing your voice command...'}
          {voiceContext.recognitionStatus !== 'error' && voiceContext.recognitionStatus !== 'processing' && (
            <>
              {voiceContext.state === 'cooking' && 'üç≥ Always listening while cooking'}
              {voiceContext.state === 'speaking' && 'üó£Ô∏è Nonna is talking - interrupt anytime'}
              {voiceContext.state === 'idle' && 'üò¥ Say "Hey Nonna" to wake up'}
            </>
          )}
        </Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    gap: 12,
    paddingVertical: 15,
  },
  unavailableContainer: {
    alignItems: 'center',
    padding: 20,
    opacity: 0.6,
  },
  unavailableText: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    textAlign: 'center',
  },
  
  // Performance indicator
  performanceIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
    backgroundColor: 'rgba(230, 126, 34, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  performanceText: {
    fontSize: 11,
    color: '#E67E22',
    fontWeight: '600',
  },
  
  // Sound waves
  soundWaves: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 3,
    height: 20,
    marginBottom: 8,
  },
  soundWave: {
    width: 3,
    backgroundColor: '#E67E22',
    borderRadius: 1.5,
    minHeight: 4,
  },
  
  // Main voice card
  voiceCard: {
    width: '100%',
    maxWidth: 400,
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    borderWidth: 2,
  },
  voiceButton: {
    width: '100%',
  },
  voiceGradient: {
    paddingVertical: 20,
    paddingHorizontal: 25,
  },
  voiceContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 15,
  },
  iconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  textContainer: {
    flex: 1,
  },
  voiceTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 4,
  },
  voiceSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
    lineHeight: 18,
  },
  
  // Error suggestions
  errorSuggestions: {
    width: '100%',
    maxWidth: 400,
    backgroundColor: 'rgba(231, 76, 60, 0.1)',
    borderRadius: 15,
    padding: 15,
    borderWidth: 1,
    borderColor: 'rgba(231, 76, 60, 0.2)',
  },
  suggestionItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 8,
  },
  suggestionBullet: {
    fontSize: 14,
    color: '#E74C3C',
    fontWeight: 'bold',
    marginRight: 8,
    marginTop: 1,
  },
  suggestionText: {
    fontSize: 13,
    color: '#C0392B',
    flex: 1,
    lineHeight: 18,
  },
  retryButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: 'rgba(231, 76, 60, 0.1)',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: 'rgba(231, 76, 60, 0.3)',
    marginTop: 8,
  },
  retryButtonText: {
    fontSize: 14,
    color: '#E74C3C',
    fontWeight: '600',
  },
  
  // Commands section
  commandsContainer: {
    width: '100%',
    maxWidth: 400,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 15,
    padding: 15,
  },
  commandsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#8B4513',
    marginBottom: 10,
    textAlign: 'center',
  },
  commandsList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    justifyContent: 'center',
  },
  commandChip: {
    flexDirection: 'row',
    backgroundColor: 'rgba(139, 69, 19, 0.1)',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(139, 69, 19, 0.2)',
  },
  wakeWordHint: {
    fontSize: 12,
    color: '#E67E22',
    fontWeight: '600',
  },
  commandText: {
    fontSize: 12,
    color: '#8B4513',
    fontWeight: '500',
  },
  
  // Context help
  contextHelp: {
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  contextHelpText: {
    fontSize: 12,
    color: '#6B3410',
    fontStyle: 'italic',
    textAlign: 'center',
  },
});
</file>

<file path="components/ContextualPrompt.tsx/ContextualPrompt.tsx">
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Animated } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { CircleHelp as HelpCircle, Clock, Heart, TriangleAlert as AlertTriangle, CircleCheck as CheckCircle, X, ChevronRight } from 'lucide-react-native';
import { CookingPrompt } from '@/hooks/useCookingContext';

interface ContextualPromptProps {
  prompt: CookingPrompt;
  onDismiss: () => void;
  onAction?: () => void;
}

export default function ContextualPrompt({ prompt, onDismiss, onAction }: ContextualPromptProps) {
  const [slideAnim] = useState(new Animated.Value(-100));
  const [pulseAnim] = useState(new Animated.Value(1));

  useEffect(() => {
    // Slide in animation
    Animated.spring(slideAnim, {
      toValue: 0,
      useNativeDriver: true,
      tension: 100,
      friction: 8,
    }).start();

    // Pulse animation for high priority prompts
    if (prompt.priority === 'high') {
      const pulse = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.05,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true,
          }),
        ])
      );
      pulse.start();
      return () => pulse.stop();
    }
  }, [slideAnim, pulseAnim, prompt.priority]);

  const getPromptConfig = () => {
    switch (prompt.type) {
      case 'help':
        return {
          icon: <HelpCircle size={20} color="white" />,
          colors: ['#3498DB', '#2980B9'],
          borderColor: '#3498DB',
          emoji: 'ü§î',
        };
      case 'progress':
        return {
          icon: <CheckCircle size={20} color="white" />,
          colors: ['#9B59B6', '#8E44AD'],
          borderColor: '#9B59B6',
          emoji: 'üëÄ',
        };
      case 'timer':
        return {
          icon: <Clock size={20} color="white" />,
          colors: ['#E67E22', '#D35400'],
          borderColor: '#E67E22',
          emoji: '‚è∞',
        };
      case 'safety':
        return {
          icon: <AlertTriangle size={20} color="white" />,
          colors: ['#E74C3C', '#C0392B'],
          borderColor: '#E74C3C',
          emoji: '‚ö†Ô∏è',
        };
      case 'encouragement':
        return {
          icon: <Heart size={20} color="white" />,
          colors: ['#27AE60', '#229954'],
          borderColor: '#27AE60',
          emoji: 'üí™',
        };
      default:
        return {
          icon: <HelpCircle size={20} color="white" />,
          colors: ['#3498DB', '#2980B9'],
          borderColor: '#3498DB',
          emoji: 'üí≠',
        };
    }
  };

  const config = getPromptConfig();

  const handleDismiss = () => {
    Animated.timing(slideAnim, {
      toValue: -100,
      duration: 300,
      useNativeDriver: true,
    }).start(() => {
      onDismiss();
    });
  };

  const handleAction = () => {
    if (onAction) {
      onAction();
    }
    handleDismiss();
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [
            { translateY: slideAnim },
            { scale: pulseAnim },
          ],
        },
      ]}
    >
      <LinearGradient
        colors={config.colors}
        style={[
          styles.promptCard,
          {
            borderColor: config.borderColor,
          },
        ]}
      >
        <View style={styles.promptContent}>
          <View style={styles.promptHeader}>
            <View style={styles.iconContainer}>
              {config.icon}
            </View>
            <Text style={styles.promptMessage}>
              {config.emoji} {prompt.message}
            </Text>
            {prompt.dismissible && (
              <TouchableOpacity 
                style={styles.dismissButton}
                onPress={handleDismiss}
              >
                <X size={18} color="rgba(255, 255, 255, 0.8)" />
              </TouchableOpacity>
            )}
          </View>

          {prompt.action && (
            <TouchableOpacity 
              style={styles.actionButton}
              onPress={handleAction}
            >
              <Text style={styles.actionButtonText}>Take Action</Text>
              <ChevronRight size={16} color="white" />
            </TouchableOpacity>
          )}
        </View>

        {/* Priority indicator */}
        <View style={[
          styles.priorityIndicator,
          prompt.priority === 'high' && styles.highPriority,
          prompt.priority === 'medium' && styles.mediumPriority,
          prompt.priority === 'low' && styles.lowPriority,
        ]} />
      </LinearGradient>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 0,
    left: 20,
    right: 20,
    zIndex: 1000,
    elevation: 10,
  },
  promptCard: {
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    position: 'relative',
  },
  promptContent: {
    gap: 12,
  },
  promptHeader: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 12,
  },
  iconContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 2,
  },
  promptMessage: {
    flex: 1,
    fontSize: 15,
    fontWeight: '600',
    color: 'white',
    lineHeight: 22,
  },
  dismissButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    borderRadius: 20,
    alignSelf: 'flex-start',
  },
  actionButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: 'white',
  },
  priorityIndicator: {
    position: 'absolute',
    top: 0,
    right: 0,
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  highPriority: {
    backgroundColor: '#FFD700',
  },
  mediumPriority: {
    backgroundColor: '#FFA500',
  },
  lowPriority: {
    backgroundColor: '#87CEEB',
  },
});
</file>

<file path="components/VoiceCommandInterface.tsx/VoiceCommandInterface.tsx">
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Animated } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Volume2, CircleHelp as HelpCircle, Timer, Zap } from 'lucide-react-native';
import VoiceCommandService from '@/services/VoiceCommandService';
import VoiceStatusIndicator from './VoiceStatusIndicator';
import OptimizedVoiceService, { OptimizedVoiceStatus } from '@/services/OptimizedVoiceService';

interface VoiceCommandInterfaceProps {
  onCommand: (command: string, type: string) => void;
  currentStep: number;
  totalSteps: number;
  isEnabled?: boolean;
}

export default function VoiceCommandInterface({ 
  onCommand, 
  currentStep, 
  totalSteps, 
  isEnabled = true 
}: VoiceCommandInterfaceProps) {
  const [voiceStatus, setVoiceStatus] = useState<OptimizedVoiceStatus>({
    state: 'idle',
    message: "üé§ Say 'Hey Nonna' or tap to speak",
    isPlaying: false
  });
  const [isListening, setIsListening] = useState(false);
  
  // Animation for speaking state
  const [pulseAnim] = useState(new Animated.Value(1));
  const [waveAnim] = useState(new Animated.Value(0));

  useEffect(() => {
    // Set up optimized voice service callbacks
    OptimizedVoiceService.setStatusCallback(setVoiceStatus);
    
    // Set up legacy voice command service callbacks for compatibility
    VoiceCommandService.setStatusCallback((status) => {
      // Convert legacy status to optimized status
      setVoiceStatus({
        state: status.state,
        message: status.message,
        action: status.action,
        suggestions: status.suggestions,
        isPlaying: false,
        responseSource: 'fallback'
      });
    });
    
    VoiceCommandService.setCommandCallback(onCommand);

    return () => {
      OptimizedVoiceService.setStatusCallback(() => {});
      VoiceCommandService.setStatusCallback(() => {});
      VoiceCommandService.setCommandCallback(() => {});
    };
  }, [onCommand]);

  useEffect(() => {
    setIsListening(VoiceCommandService.getListeningState());
  }, [voiceStatus.state]);

  // Pulse animation when speaking
  useEffect(() => {
    if (voiceStatus.isPlaying) {
      const pulse = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.1,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true,
          }),
        ])
      );
      pulse.start();
      return () => pulse.stop();
    } else {
      pulseAnim.setValue(1);
    }
  }, [voiceStatus.isPlaying, pulseAnim]);

  // Wave animation when speaking
  useEffect(() => {
    if (voiceStatus.isPlaying) {
      const wave = Animated.loop(
        Animated.timing(waveAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        })
      );
      wave.start();
      return () => wave.stop();
    } else {
      waveAnim.setValue(0);
    }
  }, [voiceStatus.isPlaying, waveAnim]);

  const handleVoiceToggle = () => {
    if (!isEnabled) return;

    // If audio is playing, stop it
    if (voiceStatus.isPlaying) {
      OptimizedVoiceService.interruptCurrentAudio();
      return;
    }

    if (isListening) {
      VoiceCommandService.stopListening();
    } else {
      VoiceCommandService.startListening();
    }
  };

  // Get button appearance based on state
  const getButtonConfig = () => {
    if (!VoiceCommandService.isAvailable()) {
      return {
        colors: ['#CCC', '#AAA'],
        disabled: true,
        scale: 1,
        text: "Voice not supported",
        subtext: "Browser doesn't support voice commands"
      };
    }

    if (voiceStatus.isPlaying) {
      return {
        colors: ['#27AE60', '#229954'],
        disabled: false,
        scale: pulseAnim,
        text: "üó£Ô∏è Nonna is speaking...",
        subtext: "Tap to interrupt"
      };
    }

    if (isListening) {
      return {
        colors: ['#E74C3C', '#C0392B'],
        disabled: false,
        scale: 1.05,
        text: "üé§ Listening...",
        subtext: "Say your command now"
      };
    }

    if (voiceStatus.state === 'processing') {
      return {
        colors: ['#F39C12', '#E67E22'],
        disabled: false,
        scale: 1,
        text: "ü§î Nonna is thinking...",
        subtext: "Processing your request"
      };
    }

    if (voiceStatus.state === 'generating_audio') {
      return {
        colors: ['#9B59B6', '#8E44AD'],
        disabled: false,
        scale: 1,
        text: "üéµ Creating audio...",
        subtext: "Generating voice response"
      };
    }

    if (voiceStatus.state === 'error') {
      return {
        colors: ['#E74C3C', '#C0392B'],
        disabled: false,
        scale: 1,
        text: "‚ùå Try again",
        subtext: "Tap to retry voice command"
      };
    }

    return {
      colors: ['#3498DB', '#2980B9'],
      disabled: false,
      scale: 1,
      text: "üí¨ Say 'Hey Nonna' or tap to speak",
      subtext: "Ready for your next question"
    };
  };

  if (!isEnabled) {
    return (
      <View style={styles.disabledContainer}>
        <Text style={styles.disabledText}>Voice commands disabled</Text>
      </View>
    );
  }

  const buttonConfig = getButtonConfig();

  return (
    <View style={styles.container}>
      {/* Performance Indicator */}
      {voiceStatus.responseTime && (
        <View style={styles.performanceIndicator}>
          <Zap size={12} color="#E67E22" />
          <Text style={styles.performanceText}>
            {voiceStatus.responseSource === 'instant' ? '‚ö° Instant' : 
             voiceStatus.responseSource === 'cached' ? 'üéØ Cached' :
             voiceStatus.responseSource === 'ai' ? 'ü§ñ AI' : 'üîÑ Fallback'} 
            ({voiceStatus.responseTime}ms)
          </Text>
        </View>
      )}

      {/* Speaking Indicator with Sound Waves */}
      {voiceStatus.isPlaying && (
        <View style={styles.speakingIndicator}>
          <View style={styles.soundWaves}>
            {[0, 1, 2, 3, 4, 5, 6, 7].map((index) => (
              <Animated.View
                key={index}
                style={[
                  styles.soundWave,
                  {
                    height: waveAnim.interpolate({
                      inputRange: [0, 1],
                      outputRange: [4, Math.random() * 20 + 8],
                    }),
                    opacity: waveAnim.interpolate({
                      inputRange: [0, 0.5, 1],
                      outputRange: [0.3, 1, 0.3],
                    }),
                  },
                ]}
              />
            ))}
          </View>
        </View>
      )}

      {/* SINGLE INTERACTIVE VOICE TAB */}
      <Animated.View
        style={[
          styles.voiceTabContainer,
          { transform: [{ scale: buttonConfig.scale }] }
        ]}
      >
        <TouchableOpacity
          style={[
            styles.voiceTab,
            buttonConfig.disabled && styles.disabledTab
          ]}
          onPress={handleVoiceToggle}
          disabled={buttonConfig.disabled}
        >
          <LinearGradient
            colors={buttonConfig.colors}
            style={styles.voiceTabGradient}
          >
            <View style={styles.voiceTabContent}>
              <Text style={styles.voiceTabText}>{buttonConfig.text}</Text>
              <Text style={styles.voiceTabSubtext}>{buttonConfig.subtext}</Text>
            </View>
          </LinearGradient>
        </TouchableOpacity>
      </Animated.View>

      {/* Quick Command Suggestions - Only show on error */}
      {voiceStatus.state === 'error' && voiceStatus.suggestions && (
        <View style={styles.suggestionsContainer}>
          <Text style={styles.suggestionsTitle}>Quick Commands:</Text>
          <View style={styles.suggestionsList}>
            {voiceStatus.suggestions.slice(0, 3).map((suggestion, index) => (
              <TouchableOpacity
                key={index}
                style={styles.suggestionChip}
                onPress={() => {
                  const cleanSuggestion = suggestion.replace('Try: ', '').replace(/"/g, '');
                  OptimizedVoiceService.processVoiceCommand(cleanSuggestion, {
                    currentStep,
                    totalSteps,
                    priority: 'conversation'
                  });
                }}
              >
                <Text style={styles.suggestionText}>
                  {suggestion.replace('Try: ', '')}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    gap: 12,
    paddingVertical: 10,
  },
  disabledContainer: {
    alignItems: 'center',
    padding: 20,
    opacity: 0.5,
  },
  disabledText: {
    fontSize: 14,
    color: '#CCC',
    fontStyle: 'italic',
  },
  
  // Performance indicator
  performanceIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
    backgroundColor: 'rgba(230, 126, 34, 0.1)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  performanceText: {
    fontSize: 11,
    color: '#E67E22',
    fontWeight: '600',
  },
  
  // Speaking indicator with sound waves
  speakingIndicator: {
    alignItems: 'center',
    marginBottom: 8,
  },
  soundWaves: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 3,
    height: 20,
  },
  soundWave: {
    width: 3,
    backgroundColor: '#27AE60',
    borderRadius: 1.5,
    minHeight: 4,
  },
  
  // Single Interactive Voice Tab
  voiceTabContainer: {
    width: '100%',
    maxWidth: 400,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
  },
  voiceTab: {
    borderRadius: 20,
    overflow: 'hidden',
  },
  disabledTab: {
    elevation: 2,
    shadowOpacity: 0.1,
  },
  voiceTabGradient: {
    paddingVertical: 20,
    paddingHorizontal: 25,
  },
  voiceTabContent: {
    alignItems: 'center',
    gap: 6,
  },
  voiceTabText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: 'white',
    textAlign: 'center',
  },
  voiceTabSubtext: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
    textAlign: 'center',
    fontStyle: 'italic',
  },
  
  // Quick Command Suggestions (only on error)
  suggestionsContainer: {
    width: '100%',
    maxWidth: 400,
    backgroundColor: 'rgba(231, 76, 60, 0.1)',
    borderRadius: 15,
    padding: 15,
    borderWidth: 1,
    borderColor: 'rgba(231, 76, 60, 0.2)',
  },
  suggestionsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#E74C3C',
    marginBottom: 10,
    textAlign: 'center',
  },
  suggestionsList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    justifyContent: 'center',
  },
  suggestionChip: {
    backgroundColor: 'rgba(231, 76, 60, 0.1)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(231, 76, 60, 0.3)',
  },
  suggestionText: {
    fontSize: 12,
    color: '#E74C3C',
    fontWeight: '500',
  },
});
</file>

<file path="components/VoiceStatusIndicator.tsx/VoiceStatusIndicator.tsx">
import React from 'react';
import { View, Text, StyleSheet, Animated } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Mic, Volume2, CircleCheck as CheckCircle, Circle as XCircle, Loader } from 'lucide-react-native';
import { OptimizedVoiceStatus } from '@/services/OptimizedVoiceService';

interface VoiceStatusIndicatorProps {
  status: OptimizedVoiceStatus;
  style?: any;
}

export default function VoiceStatusIndicator({ status, style }: VoiceStatusIndicatorProps) {
  const pulseAnim = React.useRef(new Animated.Value(1)).current;
  const waveAnim = React.useRef(new Animated.Value(0)).current;

  // Pulse animation for listening state
  React.useEffect(() => {
    if (status.state === 'listening') {
      const pulse = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 800,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 800,
            useNativeDriver: true,
          }),
        ])
      );
      pulse.start();
      return () => pulse.stop();
    } else {
      pulseAnim.setValue(1);
    }
  }, [status.state, pulseAnim]);

  // Wave animation for listening state
  React.useEffect(() => {
    if (status.state === 'listening') {
      const wave = Animated.loop(
        Animated.timing(waveAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        })
      );
      wave.start();
      return () => wave.stop();
    } else {
      waveAnim.setValue(0);
    }
  }, [status.state, waveAnim]);

  const getStatusConfig = () => {
    switch (status.state) {
      case 'idle':
        return {
          colors: ['#FFFFFF', '#FFF8F0'],
          borderColor: 'rgba(139, 69, 19, 0.2)',
          icon: <Mic size={20} color="#E67E22" />,
          textColor: '#8B4513',
          showPulse: false,
          showWaves: false,
        };
      case 'listening':
        return {
          colors: ['#E74C3C', '#C0392B'],
          borderColor: '#E74C3C',
          icon: <Mic size={20} color="white" />,
          textColor: 'white',
          showPulse: true,
          showWaves: true,
        };
      case 'processing':
        return {
          colors: ['#F39C12', '#E67E22'],
          borderColor: '#F39C12',
          icon: <Loader size={20} color="white" />,
          textColor: 'white',
          showPulse: false,
          showWaves: false,
        };
      case 'generating_audio':
        return {
          colors: ['#9B59B6', '#8E44AD'],
          borderColor: '#9B59B6',
          icon: <Loader size={20} color="white" />,
          textColor: 'white',
          showPulse: true,
          showWaves: false,
        };
      case 'speaking':
        return {
          colors: ['#27AE60', '#229954'],
          borderColor: '#27AE60',
          icon: <Volume2 size={20} color="white" />,
          textColor: 'white',
          showPulse: false,
          showWaves: false,
        };
      case 'success':
        return {
          colors: ['#27AE60', '#229954'],
          borderColor: '#27AE60',
          icon: <CheckCircle size={20} color="white" />,
          textColor: 'white',
          showPulse: false,
          showWaves: false,
        };
      case 'error':
        return {
          colors: ['#E74C3C', '#C0392B'],
          borderColor: '#E74C3C',
          icon: <XCircle size={20} color="white" />,
          textColor: 'white',
          showPulse: false,
          showWaves: false,
        };
      default:
        return {
          colors: ['#FFFFFF', '#FFF8F0'],
          borderColor: 'rgba(139, 69, 19, 0.2)',
          icon: <Mic size={20} color="#E67E22" />,
          textColor: '#8B4513',
          showPulse: false,
          showWaves: false,
        };
    }
  };

  const config = getStatusConfig();

  const renderSoundWaves = () => {
    if (!config.showWaves) return null;

    const waves = [0, 1, 2, 3, 4, 5, 6, 7];
    
    return (
      <View style={styles.soundWaves}>
        {waves.map((index) => (
          <Animated.View
            key={index}
            style={[
              styles.soundWave,
              {
                height: waveAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [4, Math.random() * 20 + 8],
                }),
                opacity: waveAnim.interpolate({
                  inputRange: [0, 0.5, 1],
                  outputRange: [0.3, 1, 0.3],
                }),
                transform: [{
                  translateY: waveAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, -2],
                  }),
                }],
              },
            ]}
          />
        ))}
      </View>
    );
  };

  return (
    <View style={[styles.container, style]}>
      <Animated.View
        style={[
          styles.statusCard,
          {
            transform: config.showPulse ? [{ scale: pulseAnim }] : [],
          },
        ]}
      >
        <LinearGradient
          colors={config.colors}
          style={[
            styles.statusGradient,
            {
              borderColor: config.borderColor,
            },
          ]}
        >
          <View style={styles.statusContent}>
            <View style={styles.iconContainer}>
              {config.icon}
            </View>
            
            <View style={styles.textContainer}>
              <Text style={[styles.statusMessage, { color: config.textColor }]}>
                {status.message}
              </Text>
              
              {status.action && (
                <Text style={[styles.statusAction, { color: config.textColor }]}>
                  {status.action}
                </Text>
              )}
            </View>
            
            {renderSoundWaves()}
          </View>
          
          {status.suggestions && status.suggestions.length > 0 && (
            <View style={styles.suggestionsContainer}>
              <Text style={[styles.suggestionsTitle, { color: config.textColor }]}>
                Try saying:
              </Text>
              {status.suggestions.map((suggestion, index) => (
                <Text key={index} style={[styles.suggestion, { color: config.textColor }]}>
                  ‚Ä¢ {suggestion}
                </Text>
              ))}
            </View>
          )}
        </LinearGradient>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
  },
  statusCard: {
    borderRadius: 16,
    overflow: 'hidden',
    elevation: 4,
    shadowColor: '#8B4513',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.15,
    shadowRadius: 6,
    minWidth: 280,
  },
  statusGradient: {
    padding: 16,
    borderWidth: 2,
  },
  statusContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  textContainer: {
    flex: 1,
  },
  statusMessage: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 2,
  },
  statusAction: {
    fontSize: 12,
    opacity: 0.8,
    fontStyle: 'italic',
  },
  soundWaves: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 2,
    marginLeft: 8,
  },
  soundWave: {
    width: 3,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    borderRadius: 1.5,
  },
  suggestionsContainer: {
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255, 255, 255, 0.3)',
  },
  suggestionsTitle: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 6,
    opacity: 0.9,
  },
  suggestion: {
    fontSize: 11,
    opacity: 0.8,
    marginBottom: 2,
    fontStyle: 'italic',
  },
});
</file>

<file path="eas.json/eas.json">
{
  "cli": {
    "version": ">= 12.0.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "resourceClass": "m-medium"
      },
      "android": {
        "buildType": "apk"
      }
    },
    "preview": {
      "distribution": "internal",
      "ios": {
        "resourceClass": "m-medium"
      }
    },
    "production": {
      "ios": {
        "resourceClass": "m-medium"
      }
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="expo-env.d.ts/expo-env.d.ts">
/// <reference types="expo/types" />

// NOTE: This file should not be edited and should be in your git ignore
</file>

<file path="hooks/useCookingContext.ts/useCookingContext.ts">
import { useState, useEffect, useCallback } from 'react';

export type CookingStage = 'prep' | 'active' | 'monitoring' | 'completion';
export type KitchenMode = 'reading' | 'cooking' | 'monitoring';

export interface CookingContext {
  stage: CookingStage;
  mode: KitchenMode;
  progress: number;
  timeInStage: number;
  lastActivity: Date;
  shouldShowPrompt: boolean;
  adaptiveSettings: {
    voiceSensitivity: number;
    screenBrightness: number;
    autoAdvance: boolean;
    showSafetyReminders: boolean;
  };
}

export interface CookingPrompt {
  type: 'help' | 'progress' | 'timer' | 'safety' | 'encouragement';
  message: string;
  action?: () => void;
  dismissible: boolean;
  priority: 'low' | 'medium' | 'high';
}

export function useCookingContext(currentStep: number, totalSteps: number, activeTimers: number) {
  const [context, setContext] = useState<CookingContext>({
    stage: 'prep',
    mode: 'reading',
    progress: 0,
    timeInStage: 0,
    lastActivity: new Date(),
    shouldShowPrompt: false,
    adaptiveSettings: {
      voiceSensitivity: 0.7,
      screenBrightness: 1.0,
      autoAdvance: false,
      showSafetyReminders: true,
    },
  });

  const [currentPrompt, setCurrentPrompt] = useState<CookingPrompt | null>(null);
  const [stageStartTime, setStageStartTime] = useState<Date>(new Date());

  // Update cooking stage based on progress and context
  const updateCookingStage = useCallback(() => {
    const progress = currentStep / totalSteps;
    let newStage: CookingStage = 'prep';
    let newMode: KitchenMode = 'reading';

    if (progress <= 0.2) {
      newStage = 'prep';
      newMode = 'reading';
    } else if (progress <= 0.8) {
      newStage = 'active';
      newMode = 'cooking';
    } else if (progress < 1.0 || activeTimers > 0) {
      newStage = 'monitoring';
      newMode = activeTimers > 0 ? 'monitoring' : 'cooking';
    } else {
      newStage = 'completion';
      newMode = 'reading';
    }

    setContext(prev => {
      const stageChanged = prev.stage !== newStage;
      if (stageChanged) {
        setStageStartTime(new Date());
      }

      return {
        ...prev,
        stage: newStage,
        mode: newMode,
        progress,
        timeInStage: stageChanged ? 0 : prev.timeInStage,
      };
    });
  }, [currentStep, totalSteps, activeTimers]);

  // Monitor time in stage
  useEffect(() => {
    const interval = setInterval(() => {
      const now = new Date();
      const timeSinceActivity = (now.getTime() - context.lastActivity.getTime()) / 1000;
      const timeInCurrentStage = (now.getTime() - stageStartTime.getTime()) / 1000;

      setContext(prev => ({
        ...prev,
        timeInStage: timeInCurrentStage,
        shouldShowPrompt: timeSinceActivity > 30 && !currentPrompt,
      }));
    }, 1000);

    return () => clearInterval(interval);
  }, [context.lastActivity, stageStartTime, currentPrompt]);

  // Update cooking stage when dependencies change
  useEffect(() => {
    updateCookingStage();
  }, [updateCookingStage]);

  // Generate contextual prompts (simplified)
  useEffect(() => {
    if (!context.shouldShowPrompt || currentPrompt) return;

    const generatePrompt = (): CookingPrompt | null => {
      const { stage, timeInStage } = context;

      // Stage-based encouragement
      if (timeInStage > 120) { // 2 minutes in stage
        if (stage === 'active' && context.progress > 0.5) {
          return {
            type: 'encouragement',
            message: 'Almost done! Let\'s check your progress.',
            dismissible: true,
            priority: 'low',
          };
        }
      }

      return null;
    };

    const prompt = generatePrompt();
    if (prompt) {
      setCurrentPrompt(prompt);
    }
  }, [context, currentPrompt, activeTimers]);

  // Adaptive settings based on context (simplified)
  useEffect(() => {
    setContext(prev => {
      const newSettings = { ...prev.adaptiveSettings };

      // Adjust screen brightness based on stage
      if (prev.stage === 'active') {
        newSettings.screenBrightness = 1.0; // Full brightness for active cooking
      } else {
        newSettings.screenBrightness = 0.8; // Normal brightness
      }

      // Enable auto-advance for timer completions
      newSettings.autoAdvance = prev.stage === 'monitoring';

      // Show safety reminders during active cooking
      newSettings.showSafetyReminders = prev.stage === 'active';

      return {
        ...prev,
        adaptiveSettings: newSettings,
      };
    });
  }, [context.stage]);

  // User activity tracking
  const recordActivity = useCallback(() => {
    setContext(prev => ({
      ...prev,
      lastActivity: new Date(),
      shouldShowPrompt: false,
    }));
    
    // Dismiss low-priority prompts on activity
    if (currentPrompt?.priority === 'low') {
      setCurrentPrompt(null);
    }
  }, [currentPrompt]);

  // Timer completion handler
  const handleTimerCompletion = useCallback((timerName: string) => {
    recordActivity();
    
    // Auto-advance to next step if enabled
    if (context.adaptiveSettings.autoAdvance) {
      setTimeout(() => {
        setCurrentPrompt({
          type: 'timer',
          message: `Timer finished! Ready for next step?`,
          action: () => {
            // This would trigger step advancement
            console.log('Auto-advancing to next step');
          },
          dismissible: true,
          priority: 'high',
        });
      }, 10000); // Show after 10 seconds
    }
  }, [context.adaptiveSettings.autoAdvance, recordActivity]);

  // Dismiss current prompt
  const dismissPrompt = useCallback(() => {
    setCurrentPrompt(null);
    recordActivity();
  }, [recordActivity]);

  // Get stage-specific UI configuration
  const getStageConfig = useCallback(() => {
    switch (context.stage) {
      case 'prep':
        return {
          title: 'üìã Prep Mode',
          subtitle: 'Get ingredients ready',
          colors: ['#3498DB', '#2980B9'],
          hideNonEssential: false,
          emphasizeIngredients: true,
          showEquipmentList: true,
        };
      case 'active':
        return {
          title: 'üî• Cooking Mode',
          subtitle: 'Screen stays awake',
          colors: ['#E74C3C', '#C0392B'],
          hideNonEssential: true,
          emphasizeCurrentStep: true,
          enlargeTimers: true,
        };
      case 'monitoring':
        return {
          title: '‚è∞ Monitoring',
          subtitle: 'Timers active',
          colors: ['#F39C12', '#E67E22'],
          hideNonEssential: true,
          emphasizeTimers: true,
          showNextStepPreview: true,
        };
      case 'completion':
        return {
          title: 'üéØ Complete',
          subtitle: 'Well done!',
          colors: ['#27AE60', '#229954'],
          hideNonEssential: false,
          showPhotoUpload: true,
          showRating: true,
        };
      default:
        return {
          title: 'üî• Cooking Mode',
          subtitle: 'Screen stays awake',
          colors: ['#E74C3C', '#C0392B'],
          hideNonEssential: false,
          emphasizeCurrentStep: true,
        };
    }
  }, [context.stage]);

  return {
    context,
    currentPrompt,
    recordActivity,
    handleTimerCompletion,
    dismissPrompt,
    getStageConfig,
  };
}
</file>

<file path="hooks/useCookingMode.ts/useCookingMode.ts">
import { useState, useEffect } from 'react';
import { Platform } from 'react-native';
import { activateKeepAwake, deactivateKeepAwake } from 'expo-keep-awake';

export interface CookingModeState {
  isActive: boolean;
  screenAwake: boolean;
  startTime: Date | null;
  totalCookingTime: number; // in seconds
}

export function useCookingMode() {
  const [cookingMode, setCookingMode] = useState<CookingModeState>({
    isActive: false,
    screenAwake: false,
    startTime: null,
    totalCookingTime: 0,
  });

  // Keep screen awake when cooking mode is active
  useEffect(() => {
    if (cookingMode.isActive && cookingMode.screenAwake) {
      if (Platform.OS !== 'web') {
        activateKeepAwake();
      }
      console.log('üî• Screen keep-awake activated');
    } else {
      if (Platform.OS !== 'web') {
        deactivateKeepAwake();
      }
      console.log('üí§ Screen keep-awake deactivated');
    }

    // Cleanup on unmount
    return () => {
      if (Platform.OS !== 'web') {
        deactivateKeepAwake();
      }
    };
  }, [cookingMode.isActive, cookingMode.screenAwake]);

  // Track cooking time
  useEffect(() => {
    let interval: NodeJS.Timeout;

    if (cookingMode.isActive && cookingMode.startTime) {
      interval = setInterval(() => {
        setCookingMode(prev => ({
          ...prev,
          totalCookingTime: Math.floor((Date.now() - prev.startTime!.getTime()) / 1000),
        }));
      }, 1000);
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [cookingMode.isActive, cookingMode.startTime]);

  const startCookingMode = (keepScreenAwake: boolean = true) => {
    setCookingMode({
      isActive: true,
      screenAwake: keepScreenAwake,
      startTime: new Date(),
      totalCookingTime: 0,
    });
    console.log('üî• Cooking mode started');
  };

  const exitCookingMode = () => {
    setCookingMode({
      isActive: false,
      screenAwake: false,
      startTime: null,
      totalCookingTime: 0,
    });
    console.log('üèÅ Cooking mode ended');
  };

  const toggleScreenAwake = () => {
    setCookingMode(prev => ({
      ...prev,
      screenAwake: !prev.screenAwake,
    }));
  };

  const updateScreenAwake = (awake: boolean) => {
    setCookingMode(prev => ({
      ...prev,
      screenAwake: awake,
    }));
  };

  return {
    cookingMode,
    startCookingMode,
    exitCookingMode,
    toggleScreenAwake,
    updateScreenAwake,
  };
}
</file>

<file path="hooks/useFrameworkReady.ts/useFrameworkReady.ts">
import { useEffect } from 'react';

declare global {
  interface Window {
    frameworkReady?: () => void;
  }
}

export function useFrameworkReady() {
  useEffect(() => {
    window.frameworkReady?.();
  });
}
</file>

<file path="hooks/useUnifiedChat.ts/useUnifiedChat.ts">
import { useState, useCallback } from 'react';
import UnifiedConversationService, { ConversationContext, MamaPersonality } from '@/services/UnifiedConversationService';

export interface ChatMessage {
  id: string;
  text: string;
  sender: 'user' | 'mama';
  timestamp: Date;
  isVoice?: boolean;
  responseTime?: number;
  source?: 'template' | 'gpt' | 'fallback';
}

export interface ChatState {
  messages: ChatMessage[];
  isLoading: boolean;
  error: string | null;
  isTyping: boolean;
}

export function useUnifiedChat(mama: MamaPersonality = 'nonna_lucia') {
  const [chatState, setChatState] = useState<ChatState>({
    messages: [],
    isLoading: false,
    error: null,
    isTyping: false
  });

  // Initialize conversation with mama
  const initializeChat = useCallback((context: ConversationContext, recipe?: any) => {
    console.log('üöÄ Initializing unified chat:', { mama, context, recipe: recipe?.name });
    
    UnifiedConversationService.setMama(mama);
    UnifiedConversationService.setContext(context, recipe);
    
    // Add welcome message based on context
    if (context === 'pre_cooking') {
      const welcomeMessage: ChatMessage = {
        id: Date.now().toString(),
        text: getWelcomeMessage(mama),
        sender: 'mama',
        timestamp: new Date(),
        source: 'template'
      };
      
      setChatState(prev => ({
        ...prev,
        messages: [welcomeMessage]
      }));
    }
  }, [mama]);

  // Send message (text or voice)
  const sendMessage = useCallback(async (
    text: string, 
    options?: {
      isVoice?: boolean;
      priority?: 'emergency' | 'normal' | 'low';
      maxWords?: number;
    }
  ) => {
    if (!text.trim()) return;

    const startTime = Date.now();
    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      text: text.trim(),
      sender: 'user',
      timestamp: new Date(),
      isVoice: options?.isVoice || false
    };

    // Add user message immediately
    setChatState(prev => ({
      ...prev,
      messages: [...prev.messages, userMessage],
      isLoading: true,
      isTyping: true,
      error: null
    }));

    try {
      console.log('üí¨ Sending unified chat message:', {
        text: text.substring(0, 50) + '...',
        isVoice: options?.isVoice,
        priority: options?.priority
      });

      const response = await UnifiedConversationService.chat(text, options);
      const responseTime = Date.now() - startTime;

      const mamaMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        text: response,
        sender: 'mama',
        timestamp: new Date(),
        isVoice: options?.isVoice || false,
        responseTime,
        source: responseTime < 200 ? 'template' : 'gpt'
      };

      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, mamaMessage],
        isLoading: false,
        isTyping: false
      }));

      console.log('‚úÖ Chat response received:', {
        response: response.substring(0, 50) + '...',
        responseTime,
        source: mamaMessage.source
      });

    } catch (error) {
      console.error('‚ùå Chat error:', error);
      
      const errorMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        text: "Sorry amore, I had trouble understanding. Could you try again?",
        sender: 'mama',
        timestamp: new Date(),
        source: 'fallback'
      };

      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, errorMessage],
        isLoading: false,
        isTyping: false,
        error: 'Failed to get response'
      }));
    }
  }, []);

  // Update recipe progress (for cooking context)
  const updateRecipeProgress = useCallback((currentStep: number, totalSteps: number) => {
    UnifiedConversationService.updateRecipeProgress(currentStep, totalSteps);
  }, []);

  // Switch conversation context
  const switchContext = useCallback((context: ConversationContext, recipe?: any) => {
    console.log('üîÑ Switching conversation context:', context);
    UnifiedConversationService.setContext(context, recipe);
    
    // Add context switch message
    const contextMessage: ChatMessage = {
      id: Date.now().toString(),
      text: getContextSwitchMessage(context, mama),
      sender: 'mama',
      timestamp: new Date(),
      source: 'template'
    };

    setChatState(prev => ({
      ...prev,
      messages: [...prev.messages, contextMessage]
    }));
  }, [mama]);

  // Clear chat history
  const clearChat = useCallback(() => {
    console.log('üóëÔ∏è Clearing chat history');
    UnifiedConversationService.clearHistory();
    setChatState({
      messages: [],
      isLoading: false,
      error: null,
      isTyping: false
    });
  }, []);

  // Get service status
  const getServiceStatus = useCallback(() => {
    return UnifiedConversationService.getServiceStatus();
  }, []);

  return {
    chatState,
    sendMessage,
    initializeChat,
    updateRecipeProgress,
    switchContext,
    clearChat,
    getServiceStatus,
    isAvailable: UnifiedConversationService.isAvailable()
  };
}

// Helper functions
function getWelcomeMessage(mama: MamaPersonality): string {
  const welcomes = {
    nonna_lucia: "Ciao amore! Welcome to Nonna's kitchen! What would you like to cook today?",
    abuela_rosa: "¬°Hola mijo! Welcome to Abuela's cocina! What delicious meal shall we make?",
    mae_malai: "Sawasdee dear! Welcome to Mae's kitchen! What Thai dish would you like to learn?"
  };
  
  return welcomes[mama];
}

function getContextSwitchMessage(context: ConversationContext, mama: MamaPersonality): string {
  const mamaName = mama === 'nonna_lucia' ? 'Nonna' : mama === 'abuela_rosa' ? 'Abuela' : 'Mae';
  
  switch (context) {
    case 'cooking':
      return `Bene! Let's start cooking together, amore! ${mamaName} will guide you step by step.`;
    case 'post_cooking':
      return `Bravissimo! You did wonderful, tesoro! How did it turn out?`;
    default:
      return `${mamaName} is here to help you cook with love!`;
  }
}
</file>

<file path="package.json/package.json">
{
  "name": "mamia-cooking-app",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "EXPO_NO_TELEMETRY=1 expo start",
    "dev:client": "EXPO_NO_TELEMETRY=1 expo start --dev-client",
    "build:web": "expo export --platform web",
    "build:dev": "eas build --profile development",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.1.0",
    "@lucide/lab": "^0.1.2",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "expo": "^53.0.0",
    "expo-blur": "~14.1.3",
    "expo-camera": "~16.1.5",
    "expo-constants": "~17.1.3",
    "expo-dev-client": "~5.0.8",
    "expo-font": "~13.2.2",
    "expo-haptics": "~14.1.3",
    "expo-keep-awake": "~13.0.2",
    "expo-linear-gradient": "~14.1.3",
    "expo-linking": "~7.1.3",
    "expo-router": "~5.0.2",
    "expo-splash-screen": "~0.30.6",
    "expo-status-bar": "~2.2.2",
    "expo-symbols": "~0.4.3",
    "expo-system-ui": "~5.0.5",
    "expo-web-browser": "~14.1.5",
    "lucide-react-native": "^0.475.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.1",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.3.0",
    "react-native-screens": "~4.10.0",
    "react-native-svg": "15.11.2",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-web": "^0.20.0",
    "react-native-webview": "13.13.5",
    "@expo-google-fonts/playfair-display": "^0.2.3",
    "@expo-google-fonts/poppins": "^0.2.3",
    "@expo-google-fonts/dancing-script": "^0.2.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "typescript": "~5.8.3"
  }
}
</file>

<file path="README.md/README.md">
# Mamia - Cook with Soul üçùüëµüèª

A beautiful cooking app that connects you with traditional grandmothers (Nonna Isabella, Abuela Carmen, Mae Siriporn) for authentic cultural recipes with AI-powered voice guidance.

## Features

### üéØ Core Features
- **Cultural Cooking Guides**: Learn from Italian Nonna, Mexican Abuela, and Thai Mae
- **Voice-Guided Cooking**: Step-by-step audio instructions with Italian personality
- **Smart Timers**: Multiple cooking timers with voice alerts
- **Recipe Discovery**: Browse by cuisine, difficulty, and cooking time
- **Photo Progress**: Show your cooking progress to get feedback

### ü§ñ AI-Powered Features (Development Build)
- **Intelligent Conversations**: Chat with Nonna Isabella using OpenAI GPT-4o mini
- **Contextual Guidance**: AI understands your cooking progress and provides relevant help
- **Premium Voice**: High-quality Italian voice synthesis with ElevenLabs
- **Smart Encouragement**: Personalized motivation based on cooking milestones

### üåê Web Compatibility
- **Browser TTS Fallback**: Works without API keys using browser speech synthesis
- **Responsive Design**: Beautiful UI across all screen sizes
- **Progressive Enhancement**: Core features work everywhere, premium features in dev builds

## Development Setup

### Prerequisites
- Node.js 18+
- Expo CLI
- EAS CLI (for development builds)

### Installation

1. **Clone and Install**
   ```bash
   git clone <repository-url>
   cd mamia-cooking-app
   npm install
   ```

2. **Environment Setup**
   ```bash
   cp .env.example .env
   # Add your API keys to .env file
   ```

3. **Web Development**
   ```bash
   npm run dev
   ```

4. **Development Build** (for AI features)
   ```bash
   npm run dev:client
   npm run build:dev
   ```

### Environment Variables

Create a `.env` file with:

```env
# Optional: For premium AI features in development builds
EXPO_PUBLIC_ELEVENLABS_API_KEY=your_elevenlabs_api_key
EXPO_PUBLIC_NONNA_VOICE_ID=your_voice_id
EXPO_PUBLIC_OPENAI_API_KEY=your_openai_api_key
```

**Note**: The app works perfectly without API keys using fallback features.

## Architecture

### Platform Strategy
- **Web**: Browser TTS + Static responses (no API keys needed)
- **Development Build**: Full AI features with ElevenLabs + OpenAI
- **Production**: Configurable based on available API keys

### Key Services
- **VoiceService**: Handles speech synthesis with platform detection
- **ConversationService**: Manages AI conversations with fallbacks
- **Platform Detection**: Automatically chooses best available features

### File Structure
```
app/
‚îú‚îÄ‚îÄ (tabs)/           # Main tab navigation
‚îú‚îÄ‚îÄ _layout.tsx       # Root layout with required framework code
‚îú‚îÄ‚îÄ mama-selection.tsx # Choose your cooking guide
‚îú‚îÄ‚îÄ recipe-detail.tsx # Recipe instructions and details
‚îú‚îÄ‚îÄ cooking.tsx       # Active cooking with voice guidance
‚îî‚îÄ‚îÄ search.tsx        # Recipe search and filters

services/
‚îú‚îÄ‚îÄ VoiceService.ts   # Speech synthesis with platform detection
‚îî‚îÄ‚îÄ ConversationService.ts # AI conversations with fallbacks
```

## Building for Production

### Web Build
```bash
npm run build:web
```

### Development Build (with AI features)
```bash
# Configure EAS project
eas build:configure

# Build for iOS/Android
npm run build:dev
```

### API Key Management
- **Development**: Add keys to `.env` for full features
- **Production**: Use EAS Secrets for secure key management
- **Fallback**: App works without keys using browser TTS and static responses

## Features by Platform

| Feature | Web | Development Build | Production |
|---------|-----|-------------------|------------|
| Basic Voice TTS | ‚úÖ Browser | ‚úÖ Native | ‚úÖ Configurable |
| Recipe Browsing | ‚úÖ | ‚úÖ | ‚úÖ |
| Cooking Timers | ‚úÖ | ‚úÖ | ‚úÖ |
| Photo Upload | ‚úÖ | ‚úÖ | ‚úÖ |
| AI Conversations | ‚ùå | ‚úÖ (with API key) | ‚úÖ (with API key) |
| Premium Voice | ‚ùå | ‚úÖ (with API key) | ‚úÖ (with API key) |
| Contextual Guidance | ‚ùå | ‚úÖ (with API key) | ‚úÖ (with API key) |

## Contributing

1. Fork the repository
2. Create a feature branch
3. Test on both web and development build
4. Ensure fallbacks work without API keys
5. Submit a pull request

## License

MIT License - see LICENSE file for details

---

**Cook with Soul** ‚ù§Ô∏è - Bringing traditional cooking wisdom to the digital age
</file>

<file path="services/ContextAwareVoiceService.ts/ContextAwareVoiceService.ts">
import { Platform } from 'react-native';
import OptimizedVoiceService from './OptimizedVoiceService';

export type VoiceListeningState = 'cooking' | 'speaking' | 'idle';
export type RecognitionStatus = 'idle' | 'listening' | 'processing' | 'error';

export interface VoiceContext {
  state: VoiceListeningState;
  isListening: boolean;
  requiresWakeWord: boolean;
  availableCommands: string[];
  currentStep?: number;
  totalSteps?: number;
  isNonnaSpeaking?: boolean;
  recognitionStatus: RecognitionStatus;
  errorMessage?: string;
  suggestions?: string[];
}

interface VoiceCommand {
  pattern: RegExp;
  action: string;
  requiresWakeWord: boolean;
  priority: 'emergency' | 'navigation' | 'cooking' | 'conversation';
  description: string;
}

class ContextAwareVoiceService {
  private currentContext: VoiceContext = {
    state: 'idle',
    isListening: false,
    requiresWakeWord: true,
    availableCommands: [],
    recognitionStatus: 'idle'
  };

  private recognition: any = null;
  private statusCallback: ((context: VoiceContext) => void) | null = null;
  private commandCallback: ((command: string, action: string) => void) | null = null;
  private isInitialized = false;
  private retryCount = 0;
  private maxRetries = 3;

  // Define voice commands for each context
  private readonly VOICE_COMMANDS: Record<VoiceListeningState, VoiceCommand[]> = {
    cooking: [
      // No wake word needed during active cooking
      { pattern: /^(next|next step|avanti)$/i, action: 'next_step', requiresWakeWord: false, priority: 'navigation', description: 'Next step' },
      { pattern: /^(previous|previous step|back|indietro)$/i, action: 'previous_step', requiresWakeWord: false, priority: 'navigation', description: 'Previous step' },
      { pattern: /^(repeat|repeat that|again|ripeti)$/i, action: 'repeat_step', requiresWakeWord: false, priority: 'navigation', description: 'Repeat step' },
      { pattern: /^(ingredients|what ingredients|ingredienti)$/i, action: 'show_ingredients', requiresWakeWord: false, priority: 'cooking', description: 'Show ingredients' },
      { pattern: /^(set timer|timer|imposta timer)\s*(\d+)?\s*(minutes?|mins?|minuti?)?$/i, action: 'set_timer', requiresWakeWord: false, priority: 'cooking', description: 'Set timer' },
      { pattern: /^(help|aiuto|stuck|confuso)$/i, action: 'emergency_help', requiresWakeWord: false, priority: 'emergency', description: 'Get help' },
      // Wake word commands for complex requests
      { pattern: /^hey nonna,?\s*(.*)/i, action: 'complex_request', requiresWakeWord: true, priority: 'conversation', description: 'Complex question' },
    ],
    
    speaking: [
      // Only wake word or emergency commands when Nonna is speaking
      { pattern: /^hey nonna$/i, action: 'interrupt_speaking', requiresWakeWord: true, priority: 'emergency', description: 'Interrupt Nonna' },
      { pattern: /^(stop|basta|ferma|pause)$/i, action: 'interrupt_speaking', requiresWakeWord: false, priority: 'emergency', description: 'Stop speaking' },
    ],
    
    idle: [
      // All commands require wake word when idle
      { pattern: /^hey nonna,?\s*(next|next step|what's next)$/i, action: 'next_step', requiresWakeWord: true, priority: 'navigation', description: 'Next step' },
      { pattern: /^hey nonna,?\s*(help|help me|aiuto)$/i, action: 'emergency_help', requiresWakeWord: true, priority: 'emergency', description: 'Get help' },
      { pattern: /^hey nonna,?\s*(ingredients|what ingredients)$/i, action: 'show_ingredients', requiresWakeWord: true, priority: 'cooking', description: 'Show ingredients' },
      { pattern: /^hey nonna,?\s*(set timer|timer)\s*(\d+)?\s*(minutes?|mins?)?$/i, action: 'set_timer', requiresWakeWord: true, priority: 'cooking', description: 'Set timer' },
      { pattern: /^hey nonna,?\s*(.+)$/i, action: 'general_question', requiresWakeWord: true, priority: 'conversation', description: 'Ask question' },
    ]
  };

  constructor() {
    this.initializeSpeechRecognition();
  }

  private initializeSpeechRecognition() {
    if (typeof window !== 'undefined' && 'webkitSpeechRecognition' in window) {
      // @ts-ignore
      this.recognition = new webkitSpeechRecognition();
      this.recognition.continuous = true; // Keep listening
      this.recognition.interimResults = false;
      this.recognition.lang = 'en-US';
      
      this.recognition.onstart = () => {
        console.log('üé§ Context-aware speech recognition started');
        this.retryCount = 0;
        this.updateContext({ 
          ...this.currentContext, 
          isListening: true, 
          recognitionStatus: 'listening',
          errorMessage: undefined,
          suggestions: undefined
        });
      };

      this.recognition.onresult = (event: any) => {
        const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
        console.log('üé§ Heard in', this.currentContext.state, 'mode:', transcript);
        this.updateContext({ 
          ...this.currentContext, 
          recognitionStatus: 'processing',
          errorMessage: undefined,
          suggestions: undefined
        });
        this.processContextualCommand(transcript);
      };

      this.recognition.onerror = (event: any) => {
        console.error('üé§ Speech recognition error:', event.error);
        this.handleRecognitionError(event.error);
      };

      this.recognition.onend = () => {
        console.log('üé§ Speech recognition ended');
        
        // Only auto-restart if we're in cooking mode, not speaking, and no error occurred
        if (this.currentContext.state === 'cooking' && 
            !this.currentContext.isNonnaSpeaking && 
            this.currentContext.recognitionStatus !== 'error' &&
            this.retryCount < this.maxRetries) {
          setTimeout(() => this.startListening(), 1000);
        } else {
          this.updateContext({ 
            ...this.currentContext, 
            isListening: false,
            recognitionStatus: this.currentContext.recognitionStatus === 'error' ? 'error' : 'idle'
          });
        }
      };

      this.isInitialized = true;
    }
  }

  private handleRecognitionError(errorType: string) {
    let errorMessage = '';
    let suggestions: string[] = [];

    switch (errorType) {
      case 'no-speech':
        errorMessage = 'No speech detected';
        suggestions = [
          'Speak closer to your microphone',
          'Check if your microphone is working',
          'Try speaking louder and clearer'
        ];
        break;
      
      case 'not-allowed':
        errorMessage = 'Microphone access denied';
        suggestions = [
          'Allow microphone access in browser settings',
          'Refresh the page and grant permission',
          'Check browser microphone permissions'
        ];
        break;
      
      case 'network':
        errorMessage = 'Network connection issue';
        suggestions = [
          'Check your internet connection',
          'Try again in a moment',
          'Refresh the page if problem persists'
        ];
        break;
      
      case 'audio-capture':
        errorMessage = 'Microphone not available';
        suggestions = [
          'Check if another app is using the microphone',
          'Try refreshing the page',
          'Check microphone hardware connection'
        ];
        break;
      
      default:
        errorMessage = 'Speech recognition error occurred';
        suggestions = [
          'Try speaking again',
          'Check microphone permissions',
          'Refresh the page if needed'
        ];
    }

    this.retryCount++;
    
    this.updateContext({
      ...this.currentContext,
      isListening: false,
      recognitionStatus: 'error',
      errorMessage,
      suggestions
    });

    // Auto-retry for certain errors in cooking mode
    if (this.currentContext.state === 'cooking' && 
        (errorType === 'no-speech' || errorType === 'network') &&
        this.retryCount < this.maxRetries) {
      setTimeout(() => {
        console.log(`üîÑ Auto-retrying speech recognition (${this.retryCount}/${this.maxRetries})`);
        this.startListening();
      }, 2000);
    }
  }

  // Set the current cooking context
  setCookingContext(state: VoiceListeningState, options?: {
    currentStep?: number;
    totalSteps?: number;
    isNonnaSpeaking?: boolean;
  }) {
    console.log('üéØ Setting voice context to:', state, options);
    
    const newContext: VoiceContext = {
      state,
      isListening: this.currentContext.isListening,
      requiresWakeWord: this.getRequiresWakeWord(state, options?.isNonnaSpeaking),
      availableCommands: this.getAvailableCommands(state),
      currentStep: options?.currentStep,
      totalSteps: options?.totalSteps,
      isNonnaSpeaking: options?.isNonnaSpeaking || false,
      recognitionStatus: this.currentContext.recognitionStatus === 'error' ? 'idle' : this.currentContext.recognitionStatus,
      errorMessage: undefined,
      suggestions: undefined
    };

    this.currentContext = newContext;
    this.updateContext(newContext);

    // Auto-start listening in cooking mode
    if (state === 'cooking' && !options?.isNonnaSpeaking && !this.currentContext.isListening) {
      this.startListening();
    }
    
    // Stop listening when Nonna starts speaking
    if (options?.isNonnaSpeaking && this.currentContext.isListening) {
      this.stopListening();
    }
  }

  private getRequiresWakeWord(state: VoiceListeningState, isNonnaSpeaking?: boolean): boolean {
    if (state === 'cooking' && !isNonnaSpeaking) return false; // No wake word during active cooking
    return true; // Wake word required for speaking and idle states
  }

  private getAvailableCommands(state: VoiceListeningState): string[] {
    return this.VOICE_COMMANDS[state].map(cmd => cmd.description);
  }

  private processContextualCommand(transcript: string) {
    const commands = this.VOICE_COMMANDS[this.currentContext.state];
    
    for (const command of commands) {
      const match = transcript.match(command.pattern);
      if (match) {
        console.log('‚úÖ Matched command:', command.action, 'in', this.currentContext.state, 'mode');
        
        // Check wake word requirement
        if (command.requiresWakeWord && !transcript.includes('hey nonna')) {
          console.log('‚ùå Wake word required but not found');
          this.provideFeedback('wake_word_required');
          return;
        }

        // Clear any error state on successful command
        this.updateContext({
          ...this.currentContext,
          recognitionStatus: 'idle',
          errorMessage: undefined,
          suggestions: undefined
        });

        // Provide immediate audio acknowledgment
        this.provideAcknowledgment(command.action);

        // Execute command
        if (this.commandCallback) {
          // Extract parameters for timer commands
          if (command.action === 'set_timer') {
            const timeMatch = transcript.match(/(\d+)/);
            const minutes = timeMatch ? parseInt(timeMatch[1]) : 5;
            this.commandCallback(`set_timer_${minutes * 60}`, command.action);
          } else if (command.action === 'complex_request' || command.action === 'general_question') {
            // Pass the full question to AI
            const question = match[1] || transcript;
            this.commandCallback(question, 'ai_question');
          } else {
            this.commandCallback(transcript, command.action);
          }
        }
        return;
      }
    }

    // No command matched
    console.log('‚ùå No command matched in', this.currentContext.state, 'mode');
    this.provideFeedback('command_not_recognized');
  }

  private async provideAcknowledgment(action: string) {
    const acknowledgments = {
      next_step: "Ecco!",
      previous_step: "S√¨!",
      repeat_step: "Certo!",
      show_ingredients: "Bene!",
      set_timer: "Perfetto!",
      emergency_help: "Calma, amore!",
      interrupt_speaking: "S√¨, tesoro?",
      general_question: "Dimmi, caro!"
    };

    const response = acknowledgments[action as keyof typeof acknowledgments] || "Bene!";
    
    // Quick acknowledgment without changing context
    OptimizedVoiceService.processVoiceCommand(response, {
      isAcknowledgment: true,
      isDirectMessage: true,
      priority: 'emergency',
      maxWords: 3,
      useExactText: true
    });
  }

  private async provideFeedback(type: 'wake_word_required' | 'command_not_recognized') {
    const feedback = {
      wake_word_required: "Say 'Hey Nonna' first, amore!",
      command_not_recognized: this.currentContext.state === 'cooking' 
        ? "Try: next step, ingredients, or set timer"
        : "Say 'Hey Nonna' then your question, tesoro!"
    };

    OptimizedVoiceService.processVoiceCommand(feedback[type], {
      isFeedback: true,
      isDirectMessage: true,
      priority: 'conversation',
      maxWords: 10,
      useExactText: true
    });
  }

  // Public API methods
  startListening() {
    if (!this.isInitialized || !this.recognition) {
      console.log('‚ùå Speech recognition not available');
      this.updateContext({
        ...this.currentContext,
        recognitionStatus: 'error',
        errorMessage: 'Speech recognition not supported',
        suggestions: ['Use a supported browser like Chrome or Safari']
      });
      return;
    }

    if (this.currentContext.isListening) {
      return;
    }

    try {
      this.recognition.start();
      console.log('üé§ Started listening in', this.currentContext.state, 'mode');
    } catch (error) {
      console.error('‚ùå Failed to start listening:', error);
      this.updateContext({
        ...this.currentContext,
        recognitionStatus: 'error',
        errorMessage: 'Failed to start speech recognition',
        suggestions: ['Try refreshing the page', 'Check microphone permissions']
      });
    }
  }

  stopListening() {
    if (this.recognition && this.currentContext.isListening) {
      this.recognition.stop();
      console.log('üîá Stopped listening');
    }
    
    this.updateContext({
      ...this.currentContext,
      isListening: false,
      recognitionStatus: 'idle',
      errorMessage: undefined,
      suggestions: undefined
    });
  }

  // Clear error state
  clearError() {
    this.updateContext({
      ...this.currentContext,
      recognitionStatus: 'idle',
      errorMessage: undefined,
      suggestions: undefined
    });
    this.retryCount = 0;
  }

  // Callback setters
  setStatusCallback(callback: (context: VoiceContext) => void) {
    this.statusCallback = callback;
  }

  setCommandCallback(callback: (command: string, action: string) => void) {
    this.commandCallback = callback;
  }

  private updateContext(context: VoiceContext) {
    this.currentContext = context;
    if (this.statusCallback) {
      this.statusCallback(context);
    }
  }

  // Get current context
  getCurrentContext(): VoiceContext {
    return { ...this.currentContext };
  }

  // Check if service is available
  isAvailable(): boolean {
    return this.isInitialized;
  }

  // Manual command trigger (for tap-to-speak)
  triggerManualCommand() {
    if (this.currentContext.recognitionStatus === 'error') {
      // Clear error and try again
      this.clearError();
      this.startListening();
    } else if (this.currentContext.state === 'speaking') {
      // Interrupt Nonna
      this.processContextualCommand('stop');
    } else {
      // Start listening
      this.startListening();
    }
  }

  // Cleanup
  cleanup() {
    this.stopListening();
    this.statusCallback = null;
    this.commandCallback = null;
  }
}

export default new ContextAwareVoiceService();
</file>

<file path="services/ConversationService.ts/ConversationService.ts">
import { Platform } from 'react-native';

class ConversationService {
  private apiKey: string;
  private baseURL = 'https://api.openai.com/v1/chat/completions';
  private conversationHistory: Array<{role: 'user' | 'assistant', content: string}> = [];

  constructor() {
    this.apiKey = process.env.EXPO_PUBLIC_OPENAI_API_KEY || '';
    
    // ENHANCED API KEY LOGGING
    if (this.apiKey) {
      console.log('‚úÖ ConversationService: OpenAI API key is PRESENT');
      console.log('üîë API Key length:', this.apiKey.length);
      console.log('üîë API Key starts with:', this.apiKey.substring(0, 7) + '...');
    } else {
      console.error('‚ùå ConversationService: OpenAI API key is MISSING!');
      console.error('üö® Set EXPO_PUBLIC_OPENAI_API_KEY in your .env file');
    }
  }

  async askNonna(userQuestion: string, context?: {
    currentStep?: number;
    totalSteps?: number;
    recipeName?: string;
    currentInstruction?: string;
    timers?: Array<{name: string, time: number, active: boolean}>;
    responseMode?: 'concise' | 'detailed';
    maxWords?: number;
    priority?: 'emergency' | 'navigation' | 'cooking' | 'conversation';
    isWelcome?: boolean;
    chef?: string;
    userName?: string;
    cookMode?: 'extended' | 'basic';
    conversationContext?: 'pre_cooking' | 'cooking' | 'post_cooking';
    currentMama?: 'nonna_lucia' | 'abuela_rosa' | 'mae_malai';
    isVoice?: boolean;
    recentHistory?: Array<{role: string, content: string}>;
  }): Promise<string> {
    console.log('üé§ askNonna called with:', {
      userQuestion: userQuestion.substring(0, 100) + '...',
      context,
      hasApiKey: !!this.apiKey,
      timestamp: new Date().toISOString()
    });

    // Return fallback response if no API key is available
    if (!this.apiKey) {
      console.log('‚ùå No API key available, using fallback');
      return this.getFallbackResponse(userQuestion, context);
    }

    const systemPrompt = this.createOptimizedSystemPrompt(context);
    console.log('üìù System prompt created (first 200 chars):', systemPrompt.substring(0, 200) + '...');

    try {
      // Use recent history if provided, otherwise use internal history
      let messages = [];
      
      if (context?.recentHistory && context.recentHistory.length > 0) {
        messages = [
          { role: 'system', content: systemPrompt },
          ...context.recentHistory,
          { role: 'user', content: userQuestion }
        ];
      } else {
        // For welcome messages, don't add to conversation history - treat as standalone
        if (!context?.isWelcome) {
          // Add user message to history for non-welcome messages
          this.conversationHistory.push({ role: 'user', content: userQuestion });

          // Keep only last 4 messages to manage token usage and speed
          if (this.conversationHistory.length > 4) {
            this.conversationHistory = this.conversationHistory.slice(-4);
          }
        }

        messages = [
          { role: 'system', content: systemPrompt },
          // For welcome messages, use the userQuestion directly without history
          ...(context?.isWelcome ? 
            [{ role: 'user', content: userQuestion }] : 
            this.conversationHistory
          )
        ];
      }

      // Optimize request parameters for faster responses
      const maxTokens = this.getMaxTokensForContext(context);
      const temperature = this.getTemperatureForContext(context);

      const requestBody = {
        model: 'gpt-4o-mini',
        messages,
        max_tokens: maxTokens,
        temperature: temperature,
        presence_penalty: 0.1,
        frequency_penalty: 0.1,
        // OPTIMIZATION: Add stop sequences for faster responses
        stop: this.getStopSequencesForContext(context)
      };

      console.log('üì§ Sending to OpenAI:', {
        model: requestBody.model,
        messageCount: requestBody.messages.length,
        maxTokens: requestBody.max_tokens,
        temperature: requestBody.temperature,
        lastUserMessage: userQuestion.substring(0, 50) + '...',
        systemPromptLength: systemPrompt.length,
        isWelcome: context?.isWelcome,
        conversationContext: context?.conversationContext,
        currentMama: context?.currentMama
      });

      const response = await fetch(this.baseURL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify(requestBody)
      });

      console.log('üì• OpenAI Response status:', response.status, response.statusText);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå OpenAI API failed:', {
          status: response.status,
          statusText: response.statusText,
          error: errorText.substring(0, 200) + '...'
        });
        throw new Error(`OpenAI API failed: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      console.log('üì• OpenAI Response data:', {
        choices: data.choices?.length || 0,
        usage: data.usage,
        model: data.model,
        finishReason: data.choices?.[0]?.finish_reason,
        responseLength: data.choices?.[0]?.message?.content?.length || 0
      });

      let nonnaResponse = data.choices[0].message.content;
      console.log('üó£Ô∏è Raw AI response for', context?.currentMama || 'nonna_lucia', ':', nonnaResponse);

      // CRITICAL: Validate and optimize response length with cultural phrase control
      nonnaResponse = this.validateAndOptimizeResponse(nonnaResponse, context);
      console.log('‚úÖ Optimized', context?.currentMama || 'nonna_lucia', 'response:', nonnaResponse);

      // Add response to history only for non-welcome messages and if not using external history
      if (!context?.isWelcome && !context?.recentHistory) {
        this.conversationHistory.push({ role: 'assistant', content: nonnaResponse });
      }

      return nonnaResponse;
    } catch (error) {
      console.error('‚ùå OpenAI API error:', error);
      const fallbackResponse = this.getFallbackResponse(userQuestion, context);
      console.log('üîÑ Using fallback response:', fallbackResponse);
      return fallbackResponse;
    }
  }

  private createOptimizedSystemPrompt(context?: {
    responseMode?: 'concise' | 'detailed';
    maxWords?: number;
    priority?: 'emergency' | 'navigation' | 'cooking' | 'conversation';
    currentStep?: number;
    totalSteps?: number;
    recipeName?: string;
    currentInstruction?: string;
    timers?: Array<{name: string, time: number, active: boolean}>;
    isWelcome?: boolean;
    chef?: string;
    userName?: string;
    cookMode?: 'extended' | 'basic';
    conversationContext?: 'pre_cooking' | 'cooking' | 'post_cooking';
    currentMama?: 'nonna_lucia' | 'abuela_rosa' | 'mae_malai';
    isVoice?: boolean;
  }): string {
    console.log('üèóÔ∏è Creating optimized system prompt with context:', context);

    // Get mama personality
    const mamaConfig = this.getMamaPersonality(context?.currentMama || 'nonna_lucia');
    console.log('üëµ Using mama config for', context?.currentMama || 'nonna_lucia', ':', {
      name: mamaConfig.name,
      culture: mamaConfig.culture,
      language: mamaConfig.language,
      expressionsCount: mamaConfig.expressions.length
    });

    // Handle welcome messages specially
    if (context?.isWelcome) {
      const welcomePrompt = `You are ${mamaConfig.name}, a ${mamaConfig.description}.

CRITICAL CULTURAL IDENTITY:
- You are EXCLUSIVELY ${mamaConfig.culture} and speak ${mamaConfig.language}
- NEVER use Italian words if you are Mexican (no "bene", "perfetto", "ecco", "mamma mia")
- NEVER use Spanish words if you are Italian (no "√≥rale", "bueno", "genial")
- NEVER use Thai words if you are not Thai (no "chai", "aroi", "sabai")
- Your approved expressions ONLY: ${mamaConfig.expressions.join(', ')}

WELCOME MESSAGE CONTEXT:
- User name: ${context.userName || mamaConfig.defaultEndearment}
- Recipe: ${context.recipeName || 'Classic Carbonara'}
- This is a warm greeting ${context.cookMode ? 'for cooking mode' : 'before cooking begins'}
- Cook mode: ${context.cookMode || 'not specified'}
- Conversation context: ${context.conversationContext || 'pre_cooking'}

RESPONSE REQUIREMENTS:
- Be warm, welcoming, and excited about cooking together
- Use EXACTLY 1 ${mamaConfig.language} expression from YOUR approved list: ${mamaConfig.expressions.join(', ')}
- Keep it personal and heartfelt
- Express genuine excitement about the recipe
- Maximum ${context.maxWords || 25} words for clear audio
- Sound like a real ${mamaConfig.culture} grandmother who loves to cook

FORBIDDEN WORDS/PHRASES:
${this.getForbiddenExpressions(context?.currentMama || 'nonna_lucia').join(', ')}

EXAMPLES FOR INITIAL WELCOME:
"Welcome ${context.userName || mamaConfig.defaultEndearment}! Today we cook my ${context.recipeName || 'carbonara'}. I can't wait, tell me when you're ready!"
"${mamaConfig.greeting} ${context.userName || mamaConfig.defaultEndearment}! My beautiful ${context.recipeName || 'recipe'} - we make it together with love!"

EXAMPLES FOR COOKING MODE START:
"${mamaConfig.cookingStart} Let's start cooking, ${context.userName || mamaConfig.defaultEndearment}. I'll guide you step by step!"
"${mamaConfig.expressions[0]}! Now we cook together, ${context.userName || mamaConfig.defaultEndearment}. Say 'Hey ${mamaConfig.shortName}' if you need help!"

Be authentic, warm, and excited about cooking together! Respond as if you're genuinely welcoming someone into your kitchen.`;

      console.log('üëã Welcome prompt created for:', context.userName, context.recipeName, 'cookMode:', context.cookMode);
      return welcomePrompt;
    }

    // Create context-specific prompt with STRICT CULTURAL CONSTRAINTS
    const conversationContext = context?.conversationContext || 'pre_cooking';
    const isVoice = context?.isVoice || false;
    const maxWords = context?.maxWords || (isVoice ? 15 : 30);
    const priority = context?.priority || 'conversation';

    // CRITICAL: Set temperature based on response type
    const temperature = this.getTemperatureForContext(context);

    let contextPrompt = '';
    
    if (conversationContext === 'pre_cooking') {
      contextPrompt = `You are ${mamaConfig.name}, a ${mamaConfig.description} welcoming someone into your kitchen. You're chatting before they start cooking.

PERSONALITY: ${mamaConfig.personality}
CONTEXT: Pre-cooking conversation - answer questions about recipes, ingredients, techniques, or just chat warmly
STYLE: Conversational, nurturing, use ${mamaConfig.language} phrases naturally (EXACTLY 1 per response)
LENGTH: Keep responses warm but concise (2-3 sentences for text, 1-2 for voice)

You love sharing cooking wisdom, family stories, and making people feel welcome in your kitchen.`;
    } else if (conversationContext === 'cooking') {
      contextPrompt = `You are ${mamaConfig.name} guiding someone through cooking. They're actively cooking and may have messy hands.

PERSONALITY: ${mamaConfig.personality}
CONTEXT: Active cooking - they need quick, clear guidance
STYLE: Supportive but concise, practical advice, gentle corrections
LENGTH: Keep responses short and actionable (1-2 sentences max)

Priority: Help them cook successfully. Answer technique questions, provide encouragement, handle cooking problems.`;
    } else {
      contextPrompt = `You are ${mamaConfig.name}, celebrating a successful cooking session.

PERSONALITY: ${mamaConfig.personality}
CONTEXT: Post-cooking celebration and reflection
STYLE: Proud, encouraging, asking about results
LENGTH: Warm but brief responses`;
    }

    // CRITICAL OPTIMIZATION CONSTRAINTS - FIXED VERBOSITY & CULTURAL LANGUAGE OVERUSE
    const basePrompt = `${contextPrompt}

CRITICAL CULTURAL IDENTITY ENFORCEMENT:
- You are EXCLUSIVELY ${mamaConfig.culture} and speak ${mamaConfig.language}
- Your approved expressions ONLY: ${mamaConfig.expressions.join(', ')}
- FORBIDDEN expressions from other cultures: ${this.getForbiddenExpressions(context?.currentMama || 'nonna_lucia').join(', ')}
- If you accidentally use a forbidden expression, you will be corrected immediately

CRITICAL RESPONSE OPTIMIZATION (MANDATORY):
- MAXIMUM ${maxWords} WORDS per response
- Use EXACTLY 1 ${mamaConfig.language} expression per response from YOUR approved list ONLY
- NEVER use expressions from other cultures
- Be direct and helpful, not chatty
- Emergency responses: 5-8 words maximum
- Navigation responses: 4-6 words maximum  
- Cooking instructions: 10-15 words maximum
- Temperature: ${temperature} (${priority === 'emergency' || priority === 'navigation' ? 'very consistent' : priority === 'cooking' ? 'slightly varied' : 'natural conversation'})

RESPONSE TYPE CLASSIFICATION:
- "instruction": Use cached templates (fast) - under 35 words, 1 ${mamaConfig.language} word max
- "conversation": Use full response (slower) - under 25 words, 1 ${mamaConfig.language} phrase max  
- "encouragement": Use cached phrases (instant) - under 8 words, 1 ${mamaConfig.language} word max
- "emergency": Use pre-recorded responses (instant) - under 8 words, calming tone

RESPONSE PRIORITY: ${priority}
${priority === 'emergency' ? '- EMERGENCY: Immediate, calming, under 8 words' : ''}
${priority === 'navigation' ? '- NAVIGATION: Direct action, under 6 words' : ''}
${priority === 'cooking' ? '- COOKING: Clear instruction, under 35 words' : ''}

PERSONALITY (keep brief):
- Warm but concise: "${mamaConfig.shortAck}" not "${mamaConfig.longAck}"
- Use "we" for togetherness: "Now we add salt"
- One ${mamaConfig.language} word per response from YOUR list: "${mamaConfig.expressions[0]}" or "${mamaConfig.expressions[1]}"
- Emergency tone: Calm and reassuring

CULTURAL AUTHENTICITY EXAMPLES FOR ${mamaConfig.culture.toUpperCase()}:
${mamaConfig.culture} instruction: "Step 2: Add the garlic to the hot oil. ${mamaConfig.expressions[0]}! Let it sizzle for 30 seconds until fragrant."
${mamaConfig.culture} encouragement: "${mamaConfig.expressions[1]}! You're doing great, ${mamaConfig.defaultEndearment}."
${mamaConfig.culture} conversation: "${mamaConfig.expressions[2]}! That's a wonderful question about cooking..."
${mamaConfig.culture} emergency: "${mamaConfig.calmingExpression}, ${mamaConfig.defaultEndearment}! We fix this together."
${mamaConfig.culture} navigation: "${mamaConfig.expressions[0]}! Next step, ${mamaConfig.defaultEndearment}!"

Current Context:
- Recipe: ${context?.recipeName || 'Classic Carbonara'}
${context?.currentStep && context?.totalSteps ? `- Step ${context.currentStep} of ${context.totalSteps}` : ''}
${context?.currentInstruction ? `- Current: ${context.currentInstruction}` : ''}
${context?.timers && context.timers.length > 0 ? 
  `- Timers: ${context.timers.filter(t => t.active).map(t => `${t.name} (${Math.floor(t.time/60)}:${(t.time%60).toString().padStart(2,'0')})`).join(', ')}` : ''}

Keep responses SHORT, helpful, and authentically ${mamaConfig.culture} with EXACTLY 1 ${mamaConfig.language} expression per response from YOUR approved list!`;

    console.log('üìã Optimized prompt created with context:', conversationContext, 'priority:', priority, 'temperature:', temperature, 'mama:', context?.currentMama);
    return basePrompt;
  }

  private getMamaPersonality(mama: 'nonna_lucia' | 'abuela_rosa' | 'mae_malai') {
    const personalities = {
      nonna_lucia: {
        name: 'Nonna Lucia',
        description: 'warm 68-year-old Italian grandmother from Tuscany who loves cooking with her family',
        culture: 'Italian',
        language: 'Italian',
        personality: 'Warm, encouraging, slightly opinionated, full of Italian expressions',
        greeting: 'Ciao bella!',
        cookingStart: 'Bene!',
        shortName: 'Nonna',
        shortAck: 'Bello!',
        longAck: 'Che bello, amore mio!',
        defaultEndearment: 'amore',
        calmingExpression: 'Calma',
        expressions: ['Perfetto', 'Ecco', 'Bene', 'Bravo', 'Mamma mia', 'Bello', 'Certo', 'Magnifico']
      },
      abuela_rosa: {
        name: 'Abuela Rosa',
        description: 'loving 65-year-old Mexican grandmother from Guadalajara who speaks beautiful Spanglish and believes every meal should be a celebration',
        culture: 'Mexican',
        language: 'Spanish/Spanglish',
        personality: 'Nurturing, spirited, uses beautiful Spanglish naturally, believes every meal should be a celebration',
        greeting: '¬°Hola mijo!',
        cookingStart: '¬°√ìrale pues!',
        shortName: 'Abuela',
        shortAck: '¬°Bueno!',
        longAck: '¬°Qu√© bueno, mi coraz√≥n!',
        defaultEndearment: 'mijo',
        calmingExpression: 'Tranquilo',
        expressions: ['¬°√ìrale!', '¬°Qu√© rico!', '¬°Genial!', '¬°Ay, s√≠!', '¬°Bueno!', '¬°Claro que s√≠!', '¬°Excelente!', '¬°√Åndale!']
      },
      mae_malai: {
        name: 'Mae Malai',
        description: 'gentle 62-year-old Thai grandmother who knows that patience is the secret ingredient',
        culture: 'Thai',
        language: 'Thai',
        personality: 'Gentle, wise, knows that patience is the secret ingredient',
        greeting: 'Sawasdee ka!',
        cookingStart: 'Chai laew!',
        shortName: 'Mae',
        shortAck: 'Aroi!',
        longAck: 'Aroi mak mak, sweetheart!',
        defaultEndearment: 'dear',
        calmingExpression: 'Jai yen yen',
        expressions: ['Chai', 'Aroi', 'Sabai sabai', 'Mai pen rai', 'Dee mak', 'Krub krub', 'Sanuk', 'Jai dee']
      }
    };

    return personalities[mama];
  }

  // NEW: Get forbidden expressions for cross-cultural contamination prevention
  private getForbiddenExpressions(currentMama: 'nonna_lucia' | 'abuela_rosa' | 'mae_malai'): string[] {
    const allPersonalities = {
      nonna_lucia: ['Perfetto', 'Ecco', 'Bene', 'Bravo', 'Mamma mia', 'Bello', 'Certo', 'Magnifico', 'Calma'],
      abuela_rosa: ['¬°√ìrale!', '¬°Qu√© rico!', '¬°Genial!', '¬°Ay, s√≠!', '¬°Bueno!', '¬°Claro que s√≠!', '¬°Excelente!', '¬°√Åndale!', 'Tranquilo'],
      mae_malai: ['Chai', 'Aroi', 'Sabai sabai', 'Mai pen rai', 'Dee mak', 'Krub krub', 'Sanuk', 'Jai dee', 'Jai yen yen']
    };

    const forbidden: string[] = [];
    
    // Add expressions from other mamas as forbidden
    Object.entries(allPersonalities).forEach(([mama, expressions]) => {
      if (mama !== currentMama) {
        forbidden.push(...expressions);
      }
    });

    return forbidden;
  }

  private getMaxTokensForContext(context?: any): number {
    const priority = context?.priority || 'conversation';
    const maxWords = context?.maxWords || 15;
    const isVoice = context?.isVoice || false;
    
    // Handle welcome messages
    if (context?.isWelcome) {
      return Math.min(50, Math.ceil((context.maxWords || 25) * 1.3));
    }
    
    // ENHANCED: Handle cooking instructions with more tokens
    if (context?.isInstruction || priority === 'cooking') {
      return Math.min(60, Math.ceil((context.maxWords || 35) * 1.3));
    }
    
    // Voice responses should be shorter
    const baseTokens = Math.ceil(maxWords * 1.3);
    const voiceMultiplier = isVoice ? 0.8 : 1.0;
    
    switch (priority) {
      case 'emergency': return Math.min(Math.ceil(baseTokens * voiceMultiplier), 15);
      case 'navigation': return Math.min(Math.ceil(baseTokens * voiceMultiplier), 12);
      case 'cooking': return Math.min(Math.ceil(baseTokens * voiceMultiplier), 60); // INCREASED for cooking
      case 'conversation': return Math.min(Math.ceil(baseTokens * voiceMultiplier), 40);
      default: return Math.ceil(baseTokens * voiceMultiplier);
    }
  }

  private getTemperatureForContext(context?: any): number {
    const priority = context?.priority || 'conversation';
    const conversationContext = context?.conversationContext || 'pre_cooking';
    
    // Welcome messages should be more varied and warm
    if (context?.isWelcome) {
      return 0.7;
    }
    
    // Pre-cooking allows more creativity
    if (conversationContext === 'pre_cooking') {
      return 0.6;
    }
    
    // CRITICAL: Set temperature based on priority for consistency
    switch (priority) {
      case 'emergency': return 0.1; // Very consistent, calming responses
      case 'navigation': return 0.2; // Consistent, direct responses
      case 'cooking': return 0.2; // Slightly varied but clear instructions (REDUCED from 0.3)
      case 'conversation': return 0.4; // More natural conversation
      default: return 0.2; // Default to more consistent
    }
  }

  private getStopSequencesForContext(context?: any): string[] {
    const priority = context?.priority || 'conversation';
    
    // OpenAI API allows maximum 4 stop sequences
    switch (priority) {
      case 'emergency':
      case 'navigation':
        return ['\n\n', '.', '!', '?']; // Exactly 4 sequences
      case 'cooking':
        return ['\n\n', '. Now', '. Next', '. Then']; // Exactly 4 sequences
      default:
        return ['\n\n', '---', '***', '.']; // Exactly 4 sequences
    }
  }

  private validateAndOptimizeResponse(response: string, context?: any): string {
    const maxWords = context?.maxWords || 15;
    const priority = context?.priority || 'conversation';
    const isVoice = context?.isVoice || false;
    const currentMama = context?.currentMama || 'nonna_lucia';
    
    console.log('üîç Validating response for', currentMama, ':', {
      originalResponse: response,
      maxWords,
      priority,
      isWelcome: context?.isWelcome,
      isVoice,
      responseLength: response.length
    });
    
    // Allow longer responses for welcome messages
    if (context?.isWelcome) {
      const words = response.trim().split(/\s+/);
      const maxWelcomeWords = context.maxWords || 25;
      if (words.length <= maxWelcomeWords) {
        console.log('‚úÖ Welcome response within limit:', words.length, 'words');
        return this.ensureCorrectCulturalUsage(response, currentMama);
      }
      console.log('‚ö†Ô∏è Welcome response too long, truncating from', words.length, 'words to', maxWelcomeWords);
      return this.truncateToSentence(response, maxWelcomeWords, currentMama);
    }
    
    // Count words
    const words = response.trim().split(/\s+/);
    console.log('üìä Response word count:', words.length, 'vs max:', maxWords);
    
    // If response is within limit, validate cultural usage
    if (words.length <= maxWords) {
      console.log('‚úÖ Response within word limit');
      return this.ensureCorrectCulturalUsage(response, currentMama);
    }
    
    console.log('‚ö†Ô∏è Response too long, truncating');
    
    // Truncate based on priority
    switch (priority) {
      case 'emergency':
        return this.truncateToSentence(response, 8, currentMama);
      case 'navigation':
        return this.truncateToSentence(response, 6, currentMama);
      case 'cooking':
        return this.truncateToSentence(response, 15, currentMama);
      default:
        return this.truncateToSentence(response, maxWords, currentMama);
    }
  }

  private truncateToSentence(text: string, maxWords: number, currentMama?: 'nonna_lucia' | 'abuela_rosa' | 'mae_malai'): string {
    console.log('‚úÇÔ∏è Truncating to sentence, max words:', maxWords);
    
    const sentences = text.split(/[.!?]+/).filter(s => s.trim());
    
    if (sentences.length > 0) {
      const firstSentence = sentences[0].trim();
      const words = firstSentence.split(/\s+/);
      
      if (words.length <= maxWords) {
        const result = firstSentence + (firstSentence.endsWith('.') ? '' : '.');
        console.log('‚úÖ First sentence fits:', result);
        return this.ensureCorrectCulturalUsage(result, currentMama);
      }
    }
    
    // Fallback: truncate to max words
    const words = text.trim().split(/\s+/);
    const result = words.slice(0, maxWords).join(' ') + '.';
    console.log('üîÑ Fallback truncation:', result);
    return this.ensureCorrectCulturalUsage(result, currentMama);
  }

  // CRITICAL: Ensure EXACTLY 1 cultural expression per response (fix cross-cultural contamination)
  private ensureCorrectCulturalUsage(text: string, mama?: 'nonna_lucia' | 'abuela_rosa' | 'mae_malai'): string {
    const mamaConfig = this.getMamaPersonality(mama || 'nonna_lucia');
    const expressions = mamaConfig.expressions;
    const forbiddenExpressions = this.getForbiddenExpressions(mama || 'nonna_lucia');
    
    console.log('üåç Checking cultural expression usage for', mama, '- Approved:', expressions.length, 'Forbidden:', forbiddenExpressions.length);
    
    // STEP 1: Remove any forbidden expressions from other cultures
    let cleanedText = text;
    let contaminationRemoved = false;
    
    for (const forbidden of forbiddenExpressions) {
      const cleanForbidden = forbidden.toLowerCase().replace(/[¬°!]/g, '');
      if (cleanedText.toLowerCase().includes(cleanForbidden)) {
        console.warn('üö® CROSS-CULTURAL CONTAMINATION DETECTED:', forbidden, 'in', mama, 'response');
        cleanedText = cleanedText.replace(new RegExp(cleanForbidden, 'gi'), '');
        contaminationRemoved = true;
      }
    }
    
    if (contaminationRemoved) {
      cleanedText = cleanedText.replace(/\s+/g, ' ').trim();
      console.log('üßπ Removed cross-cultural contamination:', cleanedText);
    }
    
    // STEP 2: Count existing approved cultural expressions
    let expressionCount = 0;
    let foundExpressions: string[] = [];
    
    for (const expr of expressions) {
      const cleanExpr = expr.toLowerCase().replace(/[¬°!]/g, '');
      if (cleanedText.toLowerCase().includes(cleanExpr)) {
        expressionCount++;
        foundExpressions.push(expr);
      }
    }
    
    console.log('üìä Found', expressionCount, mamaConfig.language, 'expressions:', foundExpressions);
    
    // STEP 3: Ensure exactly 1 approved expression
    if (expressionCount === 0) {
      const randomExpression = expressions[Math.floor(Math.random() * expressions.length)];
      const result = `${randomExpression}! ${cleanedText}`;
      console.log('‚ûï Added missing', mamaConfig.language, 'expression:', result);
      return result;
    }
    
    // If more than 1 expression, remove extras (keep only the first one)
    if (expressionCount > 1) {
      console.log('‚ö†Ô∏è Too many', mamaConfig.language, 'expressions, removing extras');
      
      // Remove all but the first expression found
      for (let i = 1; i < foundExpressions.length; i++) {
        const exprToRemove = foundExpressions[i];
        const cleanExpr = exprToRemove.replace(/[¬°!]/g, '');
        cleanedText = cleanedText.replace(new RegExp(cleanExpr, 'gi'), '');
      }
      
      // Clean up extra spaces
      cleanedText = cleanedText.replace(/\s+/g, ' ').trim();
      console.log('‚úÇÔ∏è Cleaned text with single', mamaConfig.language, 'expression:', cleanedText);
      return cleanedText;
    }
    
    console.log('‚úÖ Exactly 1', mamaConfig.language, 'expression - perfect!');
    return cleanedText;
  }

  private getFallbackResponse(userQuestion: string, context?: any): string {
    console.log('üîÑ Getting fallback response for:', userQuestion.substring(0, 50) + '...', context);
    
    const mama = context?.currentMama || 'nonna_lucia';
    const mamaConfig = this.getMamaPersonality(mama);
    
    // Handle welcome messages
    if (context?.isWelcome) {
      const userName = context.userName || mamaConfig.defaultEndearment;
      const recipeName = context.recipeName || 'my special recipe';
      
      if (context.cookMode) {
        // Cooking mode welcome
        const cookingWelcomes = [
          `${mamaConfig.cookingStart} Let's start cooking, ${userName}. I'll guide you step by step!`,
          `${mamaConfig.expressions[0]}! Now we cook together, ${userName}. Say 'Hey ${mamaConfig.shortName}' if you need help!`,
          `${mamaConfig.expressions[1]}! Time to cook, ${userName}. We make magic in the kitchen!`
        ];
        const response = cookingWelcomes[Math.floor(Math.random() * cookingWelcomes.length)];
        console.log('üëã Cooking mode welcome fallback for', mama, ':', response);
        return response;
      } else {
        // Initial welcome
        const welcomeResponses = [
          `Welcome ${userName}! Today we cook my ${recipeName}. I can't wait, tell me when you're ready!`,
          `${mamaConfig.greeting} ${userName}! My beautiful ${recipeName} - we make it together with love!`,
          `${mamaConfig.expressions[0]}! ${userName}! Today we cook ${recipeName} the traditional way!`
        ];
        const response = welcomeResponses[Math.floor(Math.random() * welcomeResponses.length)];
        console.log('üëã Initial welcome fallback for', mama, ':', response);
        return response;
      }
    }
    
    const question = userQuestion.toLowerCase();
    const priority = context?.priority || 'conversation';
    
    // Use priority-appropriate responses with EXACTLY 1 cultural expression
    if (priority === 'emergency') {
      return `${mamaConfig.expressions[0]}! ${mamaConfig.calmingExpression}, ${mamaConfig.defaultEndearment}! We fix this together!`;
    }
    
    if (priority === 'navigation') {
      if (question.includes('next')) return `${mamaConfig.expressions[1]}! Next step, ${mamaConfig.defaultEndearment}!`;
      if (question.includes('back')) return `${mamaConfig.expressions[0]}! Going back, ${mamaConfig.defaultEndearment}!`;
      return `${mamaConfig.expressions[2]}! Let's continue, ${mamaConfig.defaultEndearment}!`;
    }
    
    if (question.includes('timer') || question.includes('time')) {
      return `${mamaConfig.expressions[0]}! Timer set, ${mamaConfig.defaultEndearment}!`;
    }
    
    if (question.includes('help') || question.includes('stuck')) {
      return `${mamaConfig.expressions[1]}! We do this together, ${mamaConfig.defaultEndearment}!`;
    }
    
    if (question.includes('ingredient') || question.includes('salt') || question.includes('pepper')) {
      return `${mamaConfig.expressions[2]}! Let's check together, ${mamaConfig.defaultEndearment}!`;
    }
    
    if (question.includes('next') || question.includes('step')) {
      return `${mamaConfig.expressions[0]}! Next step, ${mamaConfig.defaultEndearment}!`;
    }
    
    if (question.includes('back') || question.includes('previous')) {
      return `${mamaConfig.expressions[1]}! Going back, ${mamaConfig.defaultEndearment}!`;
    }

    // Default fallback with single cultural expression
    const fallbacks = [
      `${mamaConfig.expressions[0]}! Let's continue, ${mamaConfig.defaultEndearment}!`,
      `${mamaConfig.expressions[1]}! We do this together!`,
      `${mamaConfig.expressions[2]}! Keep going, ${mamaConfig.defaultEndearment}!`,
      `${mamaConfig.expressions[3]}! That's how we do it, ${mamaConfig.defaultEndearment}!`
    ];

    const response = fallbacks[Math.floor(Math.random() * fallbacks.length)];
    console.log('üîÑ General fallback for', mama, ':', response);
    return response;
  }

  // Get contextual cooking advice with optimization
  async getCookingAdvice(situation: 'stuck' | 'confused' | 'timer' | 'ingredient' | 'technique', details?: string): Promise<string> {
    const context = {
      priority: 'cooking' as const,
      maxWords: 15,
      responseMode: 'concise' as const,
      conversationContext: 'cooking' as const,
      isVoice: true
    };
    
    const prompts = {
      stuck: `I'm stuck on this cooking step. ${details || 'Help me continue.'}`,
      confused: `I'm confused about what to do. ${details || 'Please clarify.'}`,
      timer: `My timer went off. ${details || 'What should I do?'}`,
      ingredient: `Question about ingredients. ${details || 'How much to use?'}`,
      technique: `Need help with technique. ${details || 'Show me how.'}`
    };

    return this.askNonna(prompts[situation], context);
  }

  // Get encouragement with optimization
  async getEncouragement(milestone: 'started' | 'halfway' | 'almost_done' | 'completed'): Promise<string> {
    const context = {
      priority: 'conversation' as const,
      maxWords: 8,
      responseMode: 'concise' as const,
      conversationContext: 'cooking' as const,
      isVoice: true
    };
    
    const prompts = {
      started: "I just started cooking!",
      halfway: "I'm halfway through!",
      almost_done: "Almost finished cooking!",
      completed: "I finished cooking!"
    };

    return this.askNonna(prompts[milestone], context);
  }

  // Clear conversation history (for new recipes)
  clearHistory(): void {
    console.log('üóëÔ∏è Clearing conversation history');
    this.conversationHistory = [];
  }

  // Check if service is available
  isAvailable(): boolean {
    const available = !!this.apiKey;
    console.log('üîç Service availability check:', available);
    return available;
  }

  // Get service status for UI
  getServiceStatus(): {
    available: boolean;
    platform: string;
    hasApiKey: boolean;
    optimizationEnabled: boolean;
  } {
    const status = {
      available: this.isAvailable(),
      platform: Platform.OS,
      hasApiKey: !!this.apiKey,
      optimizationEnabled: true
    };
    console.log('üìä Service status:', status);
    return status;
  }
}

export default new ConversationService();
</file>

<file path="services/OptimizedVoiceService.ts/OptimizedVoiceService.ts">
import { Platform } from 'react-native';
import ConversationService from './ConversationService';
import ResponseCacheService from './ResponseCacheService';

export type VoiceState = 'idle' | 'listening' | 'processing' | 'generating_audio' | 'speaking' | 'success' | 'error';
export type ResponseSource = 'instant' | 'cached' | 'ai' | 'fallback';

export interface OptimizedVoiceStatus {
  state: VoiceState;
  message: string;
  action?: string;
  suggestions?: string[];
  isPlaying?: boolean;
  responseSource?: ResponseSource;
  responseTime?: number;
  cacheHit?: boolean;
}

interface AudioQueueItem {
  text: string;
  priority: 'emergency' | 'high' | 'normal' | 'low';
  source: ResponseSource;
  context?: any;
}

class OptimizedVoiceService {
  private apiKey: string;
  private currentAudio: HTMLAudioElement | null = null;
  private statusCallback: ((status: OptimizedVoiceStatus) => void) | null = null;
  private currentState: VoiceState = 'idle';
  private isPlaying: boolean = false;
  private audioQueue: AudioQueueItem[] = [];
  private interruptionEnabled: boolean = true;
  private currentPlaybackId: string | null = null;
  private speechRecognition: any = null;
  private isListening: boolean = false;
  private recognitionRetryCount: number = 0;
  private maxRecognitionRetries: number = 2;
  private recognitionTimeout: NodeJS.Timeout | null = null;
  private silentRetryCount: number = 0;
  private maxSilentRetries: number = 2;
  private audioGenerationTimeout: NodeJS.Timeout | null = null;
  private maxAudioGenerationTime: number = 7000;

  // UPDATED: Mae Malai voice settings added
  private readonly mamaVoiceSettings = {
    nonna_lucia: {
      voiceId: process.env.EXPO_PUBLIC_NONNA_VOICE_ID || '',
      speed: 0.91,
      stability: 0.38,
      similarity_boost: 0.75,
      style: 0.30,
      use_speaker_boost: true
    },
    abuela_rosa: {
      voiceId: 't27dLf9zXLcXi9JNeGUy',
      speed: 0.85,
      stability: 0.37,
      similarity_boost: 0.45,
      style: 0.25,
      use_speaker_boost: true
    },
    mae_malai: {
      voiceId: 'K8U1ZYJslBRvdsJgdCcz',
      speed: 0.88,
      stability: 0.41,
      similarity_boost: 0.80,
      style: 0.18,
      use_speaker_boost: true
    }
  };

  constructor() {
    this.apiKey = process.env.EXPO_PUBLIC_ELEVENLABS_API_KEY || '';
    this.initializeSpeechRecognition();
    
    // ENHANCED API KEY LOGGING
    console.log('üé§ OptimizedVoiceService initialization:');
    
    if (this.apiKey) {
      console.log('‚úÖ ElevenLabs API key is PRESENT');
      console.log('üîë ElevenLabs Key length:', this.apiKey.length);
      console.log('üîë ElevenLabs Key starts with:', this.apiKey.substring(0, 7) + '...');
    } else {
      console.error('‚ùå ElevenLabs API key is MISSING!');
      console.error('üö® Set EXPO_PUBLIC_ELEVENLABS_API_KEY in your .env file');
    }
    
    // UPDATED: Log all mama voice configurations including Mae Malai
    console.log('üéµ Mama voice configurations:');
    Object.entries(this.mamaVoiceSettings).forEach(([mama, settings]) => {
      console.log(`${mama}:`, {
        voiceId: settings.voiceId ? settings.voiceId.substring(0, 8) + '...' : 'MISSING',
        hasVoiceId: !!settings.voiceId,
        speed: settings.speed,
        stability: settings.stability,
        similarity_boost: settings.similarity_boost,
        style: settings.style
      });
    });
    
    console.log('üåê Platform:', Platform.OS);
    console.log('üé§ Speech Recognition Available:', !!this.speechRecognition);
  }

  // Initialize speech recognition with better error handling
  private initializeSpeechRecognition() {
    if (typeof window !== 'undefined' && 'webkitSpeechRecognition' in window) {
      try {
        // @ts-ignore
        this.speechRecognition = new webkitSpeechRecognition();
        this.speechRecognition.continuous = false;
        this.speechRecognition.interimResults = false;
        this.speechRecognition.lang = 'en-US';
        this.speechRecognition.maxAlternatives = 1;
        
        this.speechRecognition.onstart = () => {
          console.log('üé§ Speech recognition started successfully');
          this.isListening = true;
          this.recognitionRetryCount = 0;
          this.silentRetryCount = 0;
          this.updateStatus('listening', 'üé§ Listening...', 'Say your command now');
          
          this.recognitionTimeout = setTimeout(() => {
            if (this.isListening) {
              console.log('‚è∞ Speech recognition timeout, stopping...');
              this.stopListening();
            }
          }, 10000);
        };

        this.speechRecognition.onresult = (event: any) => {
          if (this.recognitionTimeout) {
            clearTimeout(this.recognitionTimeout);
            this.recognitionTimeout = null;
          }
          
          const transcript = event.results[0][0].transcript.toLowerCase().trim();
          console.log('üé§ Speech recognized:', transcript);
          this.isListening = false;
          this.updateStatus('processing', 'ü§î Processing...', 'Understanding your command');
          this.processRecognizedSpeech(transcript);
        };

        this.speechRecognition.onerror = (event: any) => {
          console.error('üé§ Speech recognition error:', event.error);
          
          if (this.recognitionTimeout) {
            clearTimeout(this.recognitionTimeout);
            this.recognitionTimeout = null;
          }
          
          this.isListening = false;
          
          if (event.error === 'no-speech') {
            console.log('üîá No speech detected, will retry silently');
            this.handleNoSpeechError();
          } else {
            this.handleSpeechRecognitionError(event.error);
          }
        };

        this.speechRecognition.onend = () => {
          console.log('üé§ Speech recognition ended');
          
          if (this.recognitionTimeout) {
            clearTimeout(this.recognitionTimeout);
            this.recognitionTimeout = null;
          }
          
          this.isListening = false;
          
          if (this.currentState !== 'error') {
            this.updateStatus('idle', "üí¨ Say 'Hey Nonna' or tap to speak");
          }
        };

        console.log('‚úÖ Speech recognition initialized successfully');
      } catch (error) {
        console.error('‚ùå Failed to initialize speech recognition:', error);
        this.speechRecognition = null;
      }
    } else {
      console.log('‚ùå Speech recognition not supported in this browser');
    }
  }

  // Handle no-speech error more gracefully
  private handleNoSpeechError() {
    if (this.silentRetryCount < this.maxSilentRetries) {
      this.silentRetryCount++;
      console.log(`üîÑ Silent retry after no-speech (${this.silentRetryCount}/${this.maxSilentRetries})`);
      
      setTimeout(() => {
        if (!this.isListening && this.currentState !== 'error') {
          this.startListening();
        }
      }, 1000);
    } else {
      this.updateStatus('idle', "üí¨ Ready to listen", "Tap to try again");
      this.silentRetryCount = 0;
    }
  }

  // Handle speech recognition errors with better recovery
  private handleSpeechRecognitionError(errorType: string) {
    let errorMessage = '';
    let suggestions: string[] = [];
    let shouldRetry = false;

    switch (errorType) {
      case 'not-allowed':
        errorMessage = 'Microphone access denied';
        suggestions = [
          'Allow microphone in browser settings',
          'Refresh page and grant permission',
          'Check browser permissions'
        ];
        shouldRetry = false;
        break;
      
      case 'network':
        errorMessage = 'Network connection issue';
        suggestions = [
          'Check internet connection',
          'Try again in a moment'
        ];
        shouldRetry = this.recognitionRetryCount < this.maxRecognitionRetries;
        break;
      
      case 'audio-capture':
        errorMessage = 'Microphone not available';
        suggestions = [
          'Check if another app is using microphone',
          'Try refreshing the page'
        ];
        shouldRetry = false;
        break;
      
      case 'service-not-allowed':
        errorMessage = 'Speech service not allowed';
        suggestions = [
          'Check browser speech settings',
          'Try refreshing the page'
        ];
        shouldRetry = false;
        break;
      
      default:
        errorMessage = 'Speech recognition error';
        suggestions = [
          'Try speaking again',
          'Tap to retry'
        ];
        shouldRetry = this.recognitionRetryCount < this.maxRecognitionRetries;
    }

    this.updateStatus('error', `‚ùå ${errorMessage}`, 'Speech recognition failed', suggestions);

    if (shouldRetry) {
      this.recognitionRetryCount++;
      console.log(`üîÑ Auto-retrying speech recognition (${this.recognitionRetryCount}/${this.maxRecognitionRetries})`);
      
      setTimeout(() => {
        this.startListening();
      }, 2000);
    }
  }

  // Process recognized speech
  private async processRecognizedSpeech(transcript: string) {
    try {
      if (transcript.includes('hey nonna') || transcript.includes('nonna')) {
        const command = transcript.replace(/hey nonna,?/gi, '').replace(/nonna,?/gi, '').trim();
        await this.processVoiceCommand(command || 'help me', {
          priority: 'conversation',
          maxWords: 15
        });
      } else {
        await this.processVoiceCommand("Say 'Hey Nonna' first, amore!", {
          isDirectMessage: true,
          priority: 'conversation',
          maxWords: 8,
          useExactText: true
        });
      }
    } catch (error) {
      console.error('‚ùå Error processing speech:', error);
      this.updateStatus('error', '‚ùå Processing failed', 'Could not understand command');
    }
  }

  // Start listening for voice commands
  startListening() {
    if (!this.speechRecognition) {
      this.updateStatus('error', '‚ùå Voice not supported', 'Browser does not support speech recognition');
      return;
    }

    if (this.isListening) {
      console.log('üé§ Already listening, ignoring start request');
      return;
    }

    try {
      console.log('üé§ Starting speech recognition...');
      this.speechRecognition.start();
    } catch (error) {
      console.error('‚ùå Failed to start speech recognition:', error);
      this.updateStatus('error', '‚ùå Could not start listening', 'Speech recognition failed to start');
    }
  }

  // Stop listening
  stopListening() {
    if (this.recognitionTimeout) {
      clearTimeout(this.recognitionTimeout);
      this.recognitionTimeout = null;
    }
    
    if (this.speechRecognition && this.isListening) {
      console.log('üîá Stopping speech recognition');
      this.speechRecognition.stop();
    }
    this.isListening = false;
    this.updateStatus('idle', "üí¨ Say 'Hey Nonna' or tap to speak");
  }

  // Set callback for voice status updates
  setStatusCallback(callback: (status: OptimizedVoiceStatus) => void): void {
    this.statusCallback = callback;
    console.log('üìû Voice status callback set');
  }

  // Update voice status with performance metrics
  private updateStatus(
    state: VoiceState, 
    message: string, 
    action?: string, 
    suggestions?: string[],
    responseSource?: ResponseSource,
    responseTime?: number
  ): void {
    this.currentState = state;
    const status: OptimizedVoiceStatus = { 
      state, 
      message, 
      action, 
      suggestions,
      isPlaying: this.isPlaying,
      responseSource,
      responseTime,
      cacheHit: responseSource === 'instant' || responseSource === 'cached'
    };
    
    console.log('üé§ Voice Status Update:', {
      state,
      message: message.substring(0, 50) + '...',
      isPlaying: this.isPlaying,
      responseSource,
      responseTime
    });
    
    if (this.statusCallback) {
      this.statusCallback(status);
    }
  }

  // OPTIMIZED: Smart command processing with instant responses
  async processVoiceCommand(command: string, context?: any): Promise<void> {
    const startTime = Date.now();
    
    console.log('üé§ Processing voice command:', {
      command: command.substring(0, 100) + '...',
      context,
      timestamp: new Date().toISOString()
    });
    
    try {
      // SPECIAL HANDLING: For direct messages (like welcome), use exact text
      if (context?.isDirectMessage || context?.useExactText) {
        console.log('üì¢ Direct message detected - using exact text for audio');
        
        const responseTime = Date.now() - startTime;
        this.updateStatus('success', '‚úì Welcome message ready!', 'Direct message', undefined, 'instant', responseTime);
        
        await this.queueAudio({
          text: command,
          priority: 'high',
          source: 'instant',
          context
        });
        
        return;
      }

      // INSTANT: Check for immediate responses first (< 100ms)
      const instantResponse = ResponseCacheService.getInstantResponse(command, context);
      
      if (instantResponse) {
        const responseTime = Date.now() - startTime;
        console.log(`‚ö° INSTANT response in ${responseTime}ms:`, instantResponse.text);
        
        this.updateStatus('success', '‚úì Got it!', 'Instant response', undefined, 'instant', responseTime);
        
        await this.queueAudio({
          text: instantResponse.text,
          priority: instantResponse.priority,
          source: 'instant',
          context
        });
        
        return;
      }

      // FAST: Check cache for previous AI responses (< 200ms)
      const cachedResponse = ResponseCacheService.getCachedResponse(command, context);
      
      if (cachedResponse) {
        const responseTime = Date.now() - startTime;
        console.log(`üéØ CACHED response in ${responseTime}ms:`, cachedResponse.text);
        
        this.updateStatus('success', '‚úì Got it!', 'Cached response', undefined, 'cached', responseTime);
        
        await this.queueAudio({
          text: cachedResponse.text,
          priority: cachedResponse.priority,
          source: 'cached',
          context
        });
        
        return;
      }

      // NORMAL: Use optimized AI for new responses
      await this.processWithOptimizedAI(command, context, startTime);
      
    } catch (error) {
      console.error('‚ùå Voice command processing error:', error);
      this.clearAudioGenerationTimeout();
      await this.handleProcessingError(command, startTime);
    }
  }

  // Process with optimized AI (shorter responses, faster processing)
  private async processWithOptimizedAI(command: string, context?: any, startTime?: number): Promise<void> {
    const processingStart = startTime || Date.now();
    
    console.log('ü§ñ Processing with AI:', {
      command: command.substring(0, 50) + '...',
      context: context ? Object.keys(context) : 'none'
    });
    
    this.updateStatus('generating_audio', 'üéµ Generating audio...', 'Creating voice response');
    
    this.audioGenerationTimeout = setTimeout(() => {
      console.warn('‚è∞ Audio generation timeout - falling back to cached response');
      this.handleAudioGenerationTimeout(command, processingStart);
    }, this.maxAudioGenerationTime);
    
    try {
      const aiResponse = await this.getOptimizedAIResponse(command, context);
      const responseTime = Date.now() - processingStart;
      
      console.log(`ü§ñ AI response in ${responseTime}ms:`, aiResponse);
      
      this.clearAudioGenerationTimeout();
      
      ResponseCacheService.cacheOptimizedResponse(command, aiResponse, responseTime, undefined, context);
      
      this.updateStatus('success', '‚úì Got it!', 'AI response ready', undefined, 'ai', responseTime);
      
      await this.queueAudio({
        text: aiResponse,
        priority: this.classifyCommandPriority(command),
        source: 'ai',
        context
      });
      
    } catch (error) {
      console.error('‚ùå Optimized AI processing error:', error);
      this.clearAudioGenerationTimeout();
      await this.handleProcessingError(command, processingStart);
    }
  }

  // Handle audio generation timeout
  private handleAudioGenerationTimeout(command: string, startTime: number): void {
    const responseTime = Date.now() - startTime;
    
    console.log('‚è∞ Audio generation timed out, using fallback response');
    
    this.updateStatus('error', '‚ö†Ô∏è Slow connection', 'Using quick response instead', [
      'Network may be slow',
      'Using cached response',
      'Try again if needed'
    ], 'fallback', responseTime);
    
    const fallbackResponse = this.getFallbackResponse(command);
    
    this.queueAudio({
      text: fallbackResponse,
      priority: 'emergency',
      source: 'fallback',
      context: { isTimeout: true }
    });
  }

  // Clear audio generation timeout
  private clearAudioGenerationTimeout(): void {
    if (this.audioGenerationTimeout) {
      clearTimeout(this.audioGenerationTimeout);
      this.audioGenerationTimeout = null;
    }
  }

  // Get optimized AI response with shorter, focused replies
  private async getOptimizedAIResponse(command: string, context?: any): Promise<string> {
    console.log('üß† Getting AI response:', {
      command: command.substring(0, 50) + '...',
      hasConversationService: ConversationService.isAvailable(),
      context: context ? Object.keys(context) : 'none',
      maxWords: context?.maxWords,
      priority: context?.priority,
      isInstruction: context?.isInstruction
    });
    
    if (!ConversationService.isAvailable()) {
      console.log('‚ùå ConversationService not available, using fallback');
      return this.getFallbackResponse(command);
    }

    const optimizedContext = {
      ...context,
      responseMode: 'concise',
      maxWords: context?.isInstruction ? 35 : (context?.maxWords || 20),
      priority: context?.priority || this.classifyCommandPriority(command),
      conversationContext: context?.conversationContext || 'cooking',
      currentMama: context?.currentMama || 'nonna_lucia',
      isVoice: true
    };

    console.log('üìã Optimized context created:', {
      maxWords: optimizedContext.maxWords,
      priority: optimizedContext.priority,
      conversationContext: optimizedContext.conversationContext,
      isInstruction: optimizedContext.isInstruction
    });

    try {
      console.log('üì§ Calling ConversationService.askNonna...');
      const response = await ConversationService.askNonna(command, optimizedContext);
      console.log('üì• ConversationService response:', response);
      
      const optimizedResponse = this.optimizeResponseLength(response, command);
      console.log('‚úÖ Final optimized response:', optimizedResponse);
      
      return optimizedResponse;
      
    } catch (error) {
      console.error('‚ùå AI service error:', error);
      const fallbackResponse = this.getFallbackResponse(command);
      console.log('üîÑ Using fallback response:', fallbackResponse);
      return fallbackResponse;
    }
  }

  // Optimize response length based on command type
  private optimizeResponseLength(response: string, command: string): string {
    const priority = this.classifyCommandPriority(command);
    const maxWords = this.getMaxWordsForPriority(priority);
    
    console.log('üìè Optimizing response length:', {
      originalLength: response.split(' ').length,
      maxWords,
      priority,
      originalResponse: response.substring(0, 100) + '...'
    });
    
    const words = response.split(' ');
    
    if (words.length <= maxWords) {
      console.log('‚úÖ Response within word limit');
      return response;
    }
    
    console.log('‚úÇÔ∏è Truncating response from', words.length, 'to', maxWords, 'words');
    
    const sentences = response.split(/[.!?]+/);
    const firstSentence = sentences[0]?.trim();
    
    if (firstSentence && firstSentence.split(' ').length <= maxWords) {
      const result = firstSentence + (firstSentence.endsWith('.') ? '' : '.');
      console.log('‚úÖ Using first sentence:', result);
      return result;
    }
    
    const result = words.slice(0, maxWords).join(' ') + '.';
    console.log('üîÑ Fallback truncation:', result);
    return result;
  }

  // Get maximum words allowed for different priorities
  private getMaxWordsForPriority(priority: 'emergency' | 'navigation' | 'cooking' | 'conversation'): number {
    switch (priority) {
      case 'emergency': return 8;
      case 'navigation': return 6;
      case 'cooking': return 35;
      case 'conversation': return 25;
      default: return 20;
    }
  }

  // Classify command priority for response optimization
  private classifyCommandPriority(command: string): 'emergency' | 'navigation' | 'cooking' | 'conversation' {
    const cmd = command.toLowerCase();
    
    if (cmd.includes('help') || cmd.includes('stuck') || cmd.includes('emergency') || cmd.includes('stop')) {
      return 'emergency';
    }
    if (cmd.includes('next') || cmd.includes('back') || cmd.includes('repeat') || cmd.includes('previous')) {
      return 'navigation';
    }
    if (cmd.includes('timer') || cmd.includes('ingredient') || cmd.includes('cook') || cmd.includes('step')) {
      return 'cooking';
    }
    return 'conversation';
  }

  // Handle processing errors with fallback responses
  private async handleProcessingError(command: string, startTime: number): Promise<void> {
    const responseTime = Date.now() - startTime;
    
    console.error('üö® Handling processing error for command:', command);
    
    this.updateStatus('error', '‚ùå Sorry, try again', 'Using fallback response', [
      'Try: "Next step"',
      'Try: "Help me"',
      'Try: "Set timer"'
    ], 'fallback', responseTime);
    
    const fallbackResponse = this.getFallbackResponse(command);
    console.log('üîÑ Error fallback response:', fallbackResponse);
    
    await this.queueAudio({
      text: fallbackResponse,
      priority: 'emergency',
      source: 'fallback'
    });
  }

  // Get fallback response for when AI is unavailable
  private getFallbackResponse(command: string): string {
    const cmd = command.toLowerCase();
    
    console.log('üîÑ Getting fallback for command:', cmd);
    
    if (cmd.includes('step') && (cmd.includes('1') || cmd.includes('first'))) {
      return "Ecco! Let's start with the first step, amore!";
    }
    if (cmd.includes('step') && cmd.includes('next')) {
      return "Bene! Moving to the next step, tesoro!";
    }
    if (cmd.includes('instruction') || cmd.includes('cook')) {
      return "Perfetto! Let's continue cooking together, caro!";
    }
    if (cmd.includes('timer')) {
      return "Bene! Timer impostato, amore!";
    }
    if (cmd.includes('next') || cmd.includes('step')) {
      return "Ecco! Andiamo avanti, tesoro!";
    }
    if (cmd.includes('help') || cmd.includes('stuck')) {
      return "Calma, amore! Facciamo insieme!";
    }
    if (cmd.includes('ingredient')) {
      return "Perfetto! Vediamo gli ingredienti!";
    }
    
    return "Bene, bene! Continuiamo, tesoro!";
  }

  // OPTIMIZED: Audio queue management with priority handling
  private async queueAudio(item: AudioQueueItem): Promise<void> {
    console.log('üéµ Queueing audio:', {
      text: item.text.substring(0, 50) + '...',
      priority: item.priority,
      source: item.source,
      currentlyPlaying: this.isPlaying
    });
    
    if (item.priority === 'emergency') {
      console.log('üö® Emergency audio - clearing queue');
      this.clearAudioQueue();
      await this.playAudioImmediately(item);
      return;
    }
    
    if (item.priority === 'high' && this.isPlaying) {
      console.log('‚ö° High priority audio - interrupting current');
      this.interruptCurrentAudio();
    }
    
    if (this.isPlaying) {
      this.audioQueue.push(item);
      console.log('üìã Audio queued, queue length:', this.audioQueue.length);
      return;
    }
    
    await this.playAudioImmediately(item);
  }

  // Play audio immediately with source tracking
  private async playAudioImmediately(item: AudioQueueItem): Promise<void> {
    console.log('‚ñ∂Ô∏è Playing audio immediately:', {
      text: item.text.substring(0, 50) + '...',
      source: item.source,
      priority: item.priority
    });
    
    try {
      this.isPlaying = true;
      this.currentPlaybackId = Date.now().toString();
      const playbackId = this.currentPlaybackId;
      
      this.updateStatus('speaking', 'üó£Ô∏è Nonna is speaking...', `Playing ${item.source} response`);
      
      if (this.isPremiumVoiceAvailable()) {
        console.log('üé§ Using ElevenLabs for audio generation');
        await this.playWithElevenLabs(item.text, playbackId, item.context);
      } else {
        console.log('üîä Using browser TTS for audio generation');
        await this.playWithBrowserTTS(item.text, playbackId);
      }
      
      if (this.currentPlaybackId === playbackId) {
        this.onAudioFinished();
      }
      
    } catch (error) {
      console.error('‚ùå Audio playback error:', error);
      
      try {
        console.log('üîÑ Falling back to browser TTS');
        const playbackId = this.currentPlaybackId;
        await this.playWithBrowserTTS(item.text, playbackId);
        
        if (this.currentPlaybackId === playbackId) {
          this.onAudioFinished();
        }
      } catch (fallbackError) {
        console.error('‚ùå Fallback TTS error:', fallbackError);
        this.onAudioFinished();
      }
    }
  }

  // Handle audio completion and queue processing
  private onAudioFinished(): void {
    console.log('üèÅ Audio finished, queue length:', this.audioQueue.length);
    
    this.isPlaying = false;
    this.currentPlaybackId = null;
    
    if (this.audioQueue.length > 0) {
      const nextItem = this.audioQueue.shift()!;
      console.log('‚è≠Ô∏è Playing next queued audio:', nextItem.text.substring(0, 30) + '...');
      
      setTimeout(() => {
        this.playAudioImmediately(nextItem);
      }, 100);
    } else {
      console.log('üí§ Audio queue empty, returning to idle');
      this.updateStatus('idle', "üí¨ Say 'Hey Nonna' or tap to speak");
    }
  }

  // INTERRUPTION HANDLING: Allow users to interrupt long responses
  interruptCurrentAudio(): void {
    if (!this.interruptionEnabled || !this.isPlaying) return;
    
    console.log('üîá Interrupting current audio');
    
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio.currentTime = 0;
      this.currentAudio = null;
    }
    
    if (Platform.OS === 'web' && 'speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
    
    this.isPlaying = false;
    this.currentPlaybackId = null;
    
    this.updateStatus('idle', "üí¨ Interrupted - ready for new command");
  }

  // Clear entire audio queue
  private clearAudioQueue(): void {
    console.log('üóëÔ∏è Clearing audio queue, had', this.audioQueue.length, 'items');
    this.audioQueue = [];
    this.interruptCurrentAudio();
  }

  // Enable/disable interruption capability
  setInterruptionEnabled(enabled: boolean): void {
    this.interruptionEnabled = enabled;
    console.log('üîá Interruption', enabled ? 'enabled' : 'disabled');
  }

  // EMERGENCY OVERRIDE: Always works regardless of state
  async handleEmergencyCommand(command: string): Promise<void> {
    console.log('üö® Emergency command received:', command);
    
    this.clearAudioQueue();
    
    const emergencyResponse = ResponseCacheService.getInstantResponse(command, { isEmergency: true });
    
    if (emergencyResponse) {
      console.log('‚ö° Using instant emergency response');
      await this.queueAudio({
        text: emergencyResponse.text,
        priority: 'emergency',
        source: 'instant',
        context: { isEmergency: true }
      });
    } else {
      console.log('üîÑ Using fallback emergency response');
      await this.queueAudio({
        text: "Calma, amore! Nonna √® qui per aiutarti!",
        priority: 'emergency',
        source: 'fallback',
        context: { isEmergency: true }
      });
    }
  }

  // UPDATED: Audio generation methods with mama-specific voice settings
  private async playWithElevenLabs(text: string, playbackId?: string, context?: any): Promise<void> {
    console.log('üé§ Generating ElevenLabs audio for:', text.substring(0, 50) + '...');
    const audioUrl = await this.generateElevenLabsAudio(text, context);
    await this.playAudio(audioUrl, playbackId);
  }

  private async playWithBrowserTTS(text: string, playbackId?: string): Promise<void> {
    console.log('üîä Using browser TTS for:', text.substring(0, 50) + '...');
    return new Promise((resolve) => {
      if (Platform.OS === 'web' && 'speechSynthesis' in window) {
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.85;
        utterance.pitch = 1.1;
        utterance.volume = 0.9;
        
        utterance.onend = () => {
          console.log('‚úÖ Browser TTS finished');
          resolve();
        };
        
        utterance.onerror = (error) => {
          if (error.error === 'interrupted') {
            console.log('üîá Browser TTS interrupted (expected)');
            resolve();
          } else {
            console.warn('‚ö†Ô∏è Browser TTS error:', error);
            resolve();
          }
        };
        
        const voices = speechSynthesis.getVoices();
        const italianVoice = voices.find(voice => 
          voice.lang.includes('it') || voice.name.toLowerCase().includes('italian')
        );
        
        if (italianVoice) {
          console.log('üáÆüáπ Using Italian voice:', italianVoice.name);
          utterance.voice = italianVoice;
        } else {
          console.log('üîä Using default voice, no Italian voice found');
        }
        
        if (playbackId && this.currentPlaybackId !== playbackId) {
          console.log('üîá Playback interrupted before TTS start');
          resolve();
          return;
        }
        
        speechSynthesis.speak(utterance);
      } else {
        console.log('‚ùå Browser TTS not available');
        resolve();
      }
    });
  }

  // UPDATED: Generate ElevenLabs audio with Mae Malai settings
  private async generateElevenLabsAudio(text: string, context?: any): Promise<string> {
    if (!this.apiKey) {
      throw new Error('ElevenLabs API key not configured');
    }
    
    // Determine which mama is speaking
    const currentMama = context?.currentMama || 'nonna_lucia';
    const voiceSettings = this.mamaVoiceSettings[currentMama as keyof typeof this.mamaVoiceSettings];
    
    if (!voiceSettings.voiceId) {
      console.warn(`‚ö†Ô∏è No voice ID configured for ${currentMama}, falling back to nonna_lucia`);
      const fallbackSettings = this.mamaVoiceSettings.nonna_lucia;
      if (!fallbackSettings.voiceId) {
        throw new Error('No voice ID configured for any mama');
      }
    }
    
    const finalVoiceId = voiceSettings.voiceId || this.mamaVoiceSettings.nonna_lucia.voiceId;
    
    console.log('üì§ Sending to ElevenLabs:', {
      text: text.substring(0, 100) + '...',
      mama: currentMama,
      voiceId: finalVoiceId.substring(0, 8) + '...',
      hasApiKey: !!this.apiKey,
      voiceSettings: {
        speed: voiceSettings.speed,
        stability: voiceSettings.stability,
        similarity_boost: voiceSettings.similarity_boost,
        style: voiceSettings.style
      }
    });
    
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${finalVoiceId}`, {
      method: 'POST',
      headers: {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': this.apiKey
      },
      body: JSON.stringify({
        text: text,
        model_id: "eleven_multilingual_v2",
        voice_settings: {
          stability: voiceSettings.stability,
          similarity_boost: voiceSettings.similarity_boost,
          style: voiceSettings.style,
          use_speaker_boost: voiceSettings.use_speaker_boost,
          speed: voiceSettings.speed
        }
      })
    });

    console.log('üì• ElevenLabs response:', response.status, response.statusText);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå ElevenLabs API failed:', response.status, errorText);
      throw new Error(`ElevenLabs API failed: ${response.status} - ${errorText}`);
    }
    
    const audioBlob = await response.blob();
    const audioUrl = URL.createObjectURL(audioBlob);
    console.log('‚úÖ ElevenLabs audio generated for', currentMama, ', blob size:', audioBlob.size);
    return audioUrl;
  }

  private async playAudio(audioUrl: string, playbackId?: string): Promise<void> {
    console.log('‚ñ∂Ô∏è Playing audio from URL');
    return new Promise((resolve, reject) => {
      if (Platform.OS === 'web') {
        this.currentAudio = new Audio(audioUrl);
        this.currentAudio.volume = 0.9;
        
        this.currentAudio.onended = () => {
          console.log('‚úÖ Audio playback ended');
          URL.revokeObjectURL(audioUrl);
          this.currentAudio = null;
          resolve();
        };
        
        this.currentAudio.onerror = (error) => {
          console.warn('‚ö†Ô∏è Audio playback error:', error);
          URL.revokeObjectURL(audioUrl);
          this.currentAudio = null;
          resolve();
        };
        
        if (playbackId && this.currentPlaybackId !== playbackId) {
          console.log('üîá Playback interrupted before audio start');
          URL.revokeObjectURL(audioUrl);
          this.currentAudio = null;
          resolve();
          return;
        }
        
        this.currentAudio.play().catch((error) => {
          if (error.name === 'AbortError' || error.message.includes('interrupted')) {
            console.log('üîá Audio play interrupted (expected)');
            URL.revokeObjectURL(audioUrl);
            this.currentAudio = null;
            resolve();
          } else {
            console.warn('‚ö†Ô∏è Audio play failed:', error);
            URL.revokeObjectURL(audioUrl);
            this.currentAudio = null;
            resolve();
          }
        });
      } else {
        console.log('‚ö†Ô∏è Audio playback not supported on this platform');
        resolve();
      }
    });
  }

  // FIXED: Public API methods - Updated speakCookingInstruction to accept currentMama parameter
  async speakCookingInstruction(instruction: string, stepNumber?: number, totalSteps?: number, currentMama?: string): Promise<void> {
    const context = {
      currentStep: stepNumber, 
      totalSteps: totalSteps,
      currentInstruction: instruction,
      isInstruction: true,
      priority: 'cooking' as const,
      maxWords: 35,
      responseMode: 'concise' as const,
      conversationContext: 'cooking' as const,
      isVoice: true,
      currentMama: currentMama || 'nonna_lucia' // FIXED: Use passed currentMama parameter
    };
    
    console.log('üë©‚Äçüç≥ Speaking cooking instruction:', {
      instruction: instruction.substring(0, 50) + '...',
      stepNumber,
      totalSteps,
      currentMama: context.currentMama, // FIXED: Log the correct mama
      context: Object.keys(context)
    });
    
    const cookingPrompt = `Guide me through step ${stepNumber || 1}: ${instruction}`;
    
    await this.processVoiceCommand(cookingPrompt, context);
  }

  async speakEncouragement(): Promise<void> {
    const encouragementCommands = ['good job', 'well done', 'keep going', 'you\'re doing great'];
    const randomCommand = encouragementCommands[Math.floor(Math.random() * encouragementCommands.length)];
    
    console.log('üí™ Speaking encouragement:', randomCommand);
    
    await this.processVoiceCommand(randomCommand, { isEncouragement: true });
  }

  async speakTimerAlert(timerName: string, timeLeft?: number): Promise<void> {
    const context = { 
      timerName, 
      timeLeft,
      isTimer: true 
    };
    
    console.log('‚è∞ Speaking timer alert:', timerName);
    
    await this.processVoiceCommand(`Timer ${timerName} finished`, context);
  }

  // Service status and capabilities
  isPremiumVoiceAvailable(): boolean {
    const available = !!this.apiKey && Object.values(this.mamaVoiceSettings).some(settings => !!settings.voiceId);
    console.log('üíé Premium voice available:', available);
    return available;
  }

  isVoiceAvailable(): boolean {
    const available = this.isPremiumVoiceAvailable() || (Platform.OS === 'web' && 'speechSynthesis' in window);
    console.log('üîä Voice available:', available);
    return available;
  }

  getPerformanceMetrics() {
    return ResponseCacheService.getPerformanceMetrics();
  }

  // Cleanup
  cleanup(): void {
    console.log('üßπ Cleaning up OptimizedVoiceService');
    
    if (this.recognitionTimeout) {
      clearTimeout(this.recognitionTimeout);
      this.recognitionTimeout = null;
    }
    
    this.clearAudioGenerationTimeout();
    this.clearAudioQueue();
    this.stopListening();
    this.statusCallback = null;
    this.currentPlaybackId = null;
  }
}

export default new OptimizedVoiceService();
</file>

<file path="services/ResponseCacheService.ts/ResponseCacheService.ts">
import { Platform } from 'react-native';

interface CachedResponse {
  text: string;
  audioUrl?: string;
  timestamp: number;
  type: 'instant' | 'fast' | 'normal';
  priority: 'emergency' | 'navigation' | 'cooking' | 'conversation';
  expiresAt: number;
  hitCount: number;
}

interface PerformanceMetrics {
  totalRequests: number;
  cacheHits: number;
  cacheMisses: number;
  averageResponseTime: number;
  responseTimesByType: Record<string, number[]>;
  hitRate: number;
  lastUpdated: number;
}

class ResponseCacheService {
  private cache: Map<string, CachedResponse> = new Map();
  private metrics: PerformanceMetrics = {
    totalRequests: 0,
    cacheHits: 0,
    cacheMisses: 0,
    averageResponseTime: 0,
    responseTimesByType: {},
    hitRate: 0,
    lastUpdated: Date.now()
  };

  // OPTIMIZED: Pre-defined Italian cooking responses for instant playback (EXACTLY 1 Italian expression each)
  private readonly INSTANT_RESPONSES = {
    // Acknowledgments (< 50ms) - EXACTLY 1 Italian word each
    acknowledgments: [
      { text: "Bene! Perfect, amore!", audio: null, scenarios: ['good', 'correct', 'yes'] },
      { text: "Perfetto! You got it!", audio: null, scenarios: ['perfect', 'excellent', 'done'] },
      { text: "Ecco! There we go!", audio: null, scenarios: ['completed', 'finished', 'there'] },
      { text: "Bravo! Well done, tesoro!", audio: null, scenarios: ['well done', 'good job', 'praise'] },
      { text: "Bello! That's lovely!", audio: null, scenarios: ['beautiful', 'nice', 'lovely'] },
      { text: "Mamma mia! Amazing work!", audio: null, scenarios: ['surprise', 'wow', 'amazing'] },
    ],

    // Navigation responses (< 100ms) - EXACTLY 1 Italian expression each
    navigation: [
      { text: "Ecco! Next step, tesoro!", audio: null, scenarios: ['next', 'forward', 'continue'] },
      { text: "S√¨! Going back, amore!", audio: null, scenarios: ['back', 'previous', 'return'] },
      { text: "Certo! I'll repeat for you!", audio: null, scenarios: ['repeat', 'again', 'say again'] },
      { text: "Bene! Let's see ingredients!", audio: null, scenarios: ['ingredients', 'list', 'show'] },
    ],

    // Timer responses (< 100ms) - EXACTLY 1 Italian expression each
    timers: [
      { text: "Perfetto! Timer set, amore!", audio: null, scenarios: ['timer set', 'timer started'] },
      { text: "Ecco! Timer finished, tesoro!", audio: null, scenarios: ['timer finished', 'timer done'] },
      { text: "Bene! {time} minutes left!", audio: null, scenarios: ['time left', 'time remaining'] },
      { text: "Attenzione! Timer almost done!", audio: null, scenarios: ['timer warning', 'almost done'] },
    ],

    // Encouragement (< 50ms) - EXACTLY 1 Italian word each
    encouragement: [
      { text: "Bravissimo! Keep going!", audio: null, scenarios: ['encouragement', 'motivation'] },
      { text: "Perfetto! That's how we do it!", audio: null, scenarios: ['that\'s how', 'correct way'] },
      { text: "Bene! Take your time, amore!", audio: null, scenarios: ['slowly', 'take time', 'patience'] },
      { text: "Coraggio! You're doing great!", audio: null, scenarios: ['courage', 'keep going', 'don\'t worry'] },
    ],

    // Safety/Emergency (< 50ms) - EXACTLY 1 Italian word each
    emergency: [
      { text: "Calma! Take a breath, caro!", audio: null, scenarios: ['careful', 'attention', 'safety'] },
      { text: "Tranquillo! Help is here, amore!", audio: null, scenarios: ['help', 'stuck', 'confused'] },
      { text: "Respira! We do this together!", audio: null, scenarios: ['overwhelmed', 'stressed', 'panic'] },
    ]
  };

  // OPTIMIZED: Command patterns for instant recognition
  private readonly INSTANT_COMMANDS = {
    navigation: [
      /^(next|avanti|forward|continue|vai)/i,
      /^(back|previous|indietro|torna)/i,
      /^(repeat|again|ripeti|ancora)/i,
      /^(ingredients|ingredienti|lista)/i,
    ],
    timers: [
      /^(set timer|timer|imposta|cronometro)/i,
      /^(time left|quanto tempo|how much time)/i,
      /^(timer done|timer finished|finito)/i,
    ],
    emergency: [
      /^(help|aiuto|stuck|confuso|confused)/i,
      /^(stop|basta|ferma|pause)/i,
      /^(emergency|emergenza|problema)/i,
    ]
  };

  constructor() {
    this.loadCacheFromStorage();
    this.preloadInstantResponses();
  }

  // Get instant response for common commands (< 100ms)
  getInstantResponse(command: string, context?: any): CachedResponse | null {
    const startTime = Date.now();
    this.metrics.totalRequests++;

    const normalizedCommand = command.toLowerCase().trim();
    
    // Check for navigation commands
    for (const pattern of this.INSTANT_COMMANDS.navigation) {
      if (pattern.test(normalizedCommand)) {
        const response = this.selectBestResponse('navigation', normalizedCommand, context);
        if (response) {
          this.recordCacheHit(startTime, 'instant');
          return response;
        }
      }
    }

    // Check for timer commands
    for (const pattern of this.INSTANT_COMMANDS.timers) {
      if (pattern.test(normalizedCommand)) {
        const response = this.selectBestResponse('timers', normalizedCommand, context);
        if (response) {
          this.recordCacheHit(startTime, 'instant');
          return response;
        }
      }
    }

    // Check for emergency commands
    for (const pattern of this.INSTANT_COMMANDS.emergency) {
      if (pattern.test(normalizedCommand)) {
        const response = this.selectBestResponse('emergency', normalizedCommand, context);
        if (response) {
          this.recordCacheHit(startTime, 'instant');
          return response;
        }
      }
    }

    // Check for acknowledgment scenarios
    if (this.isAcknowledgmentNeeded(normalizedCommand)) {
      const response = this.selectBestResponse('acknowledgments', normalizedCommand, context);
      if (response) {
        this.recordCacheHit(startTime, 'instant');
        return response;
      }
    }

    this.recordCacheMiss(startTime);
    return null;
  }

  // Select best response based on context and scenario matching
  private selectBestResponse(category: string, command: string, context?: any): CachedResponse | null {
    const responses = this.INSTANT_RESPONSES[category as keyof typeof this.INSTANT_RESPONSES];
    if (!responses) return null;

    // Find best matching response based on scenarios
    let bestMatch = responses[0]; // Default fallback
    let bestScore = 0;

    for (const response of responses) {
      const score = this.calculateMatchScore(command, response.scenarios, context);
      if (score > bestScore) {
        bestScore = score;
        bestMatch = response;
      }
    }

    // Apply context-specific modifications
    let finalText = bestMatch.text;
    if (context?.timerTime) {
      finalText = finalText.replace('{time}', context.timerTime.toString());
    }
    if (context?.userName) {
      finalText = finalText.replace(/amore|tesoro|caro/g, context.userName);
    }

    return {
      text: finalText,
      audioUrl: bestMatch.audio,
      timestamp: Date.now(),
      type: 'instant',
      priority: this.determinePriority(category),
      expiresAt: Date.now() + (24 * 60 * 60 * 1000), // 24 hours
      hitCount: 1
    };
  }

  // Calculate match score for response selection
  private calculateMatchScore(command: string, scenarios: string[], context?: any): number {
    let score = 0;
    
    for (const scenario of scenarios) {
      if (command.includes(scenario.toLowerCase())) {
        score += 10;
      }
    }

    // Context bonuses
    if (context?.isEmergency && scenarios.includes('help')) score += 20;
    if (context?.isTimer && scenarios.includes('timer')) score += 15;
    if (context?.isNavigation && scenarios.includes('next')) score += 15;

    return score;
  }

  // Check if command needs acknowledgment
  private isAcknowledgmentNeeded(command: string): boolean {
    const acknowledgmentTriggers = [
      'good', 'great', 'perfect', 'done', 'finished', 'completed',
      'bene', 'perfetto', 'fatto', 'finito'
    ];
    
    return acknowledgmentTriggers.some(trigger => command.includes(trigger));
  }

  // Determine response priority
  private determinePriority(category: string): 'emergency' | 'navigation' | 'cooking' | 'conversation' {
    switch (category) {
      case 'emergency': return 'emergency';
      case 'navigation': return 'navigation';
      case 'timers': return 'cooking';
      default: return 'conversation';
    }
  }

  // Cache optimized AI responses for fast retrieval
  cacheOptimizedResponse(
    command: string, 
    response: string, 
    responseTime: number,
    audioUrl?: string,
    context?: any
  ): void {
    const key = this.generateCacheKey(command, context);
    const type = responseTime < 200 ? 'fast' : 'normal';
    
    const cached: CachedResponse = {
      text: response,
      audioUrl,
      timestamp: Date.now(),
      type,
      priority: this.classifyPriority(command),
      expiresAt: Date.now() + this.getExpirationTime(type),
      hitCount: 0
    };

    this.cache.set(key, cached);
    this.saveCacheToStorage();
  }

  // Get cached response if available
  getCachedResponse(command: string, context?: any): CachedResponse | null {
    const startTime = Date.now();
    this.metrics.totalRequests++;

    const key = this.generateCacheKey(command, context);
    const cached = this.cache.get(key);

    if (cached && this.isValidCache(cached)) {
      cached.hitCount++;
      this.recordCacheHit(startTime, cached.type);
      return cached;
    }

    this.recordCacheMiss(startTime);
    return null;
  }

  // Pre-load instant responses for immediate access
  private preloadInstantResponses(): void {
    console.log('üöÄ Pre-loading instant Italian responses...');
    
    let loadedCount = 0;
    
    Object.entries(this.INSTANT_RESPONSES).forEach(([category, responses]) => {
      responses.forEach((response, index) => {
        const key = `instant_${category}_${index}`;
        
        const cached: CachedResponse = {
          text: response.text,
          audioUrl: response.audio,
          timestamp: Date.now(),
          type: 'instant',
          priority: this.determinePriority(category),
          expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days
          hitCount: 0
        };

        this.cache.set(key, cached);
        loadedCount++;
      });
    });

    console.log(`‚úÖ Pre-loaded ${loadedCount} instant responses with controlled Italian usage`);
  }

  // Performance metrics tracking
  private recordCacheHit(startTime: number, type: string): void {
    const responseTime = Date.now() - startTime;
    this.metrics.cacheHits++;
    this.updateResponseTime(type, responseTime);
    this.updateMetrics();
  }

  private recordCacheMiss(startTime: number): void {
    const responseTime = Date.now() - startTime;
    this.metrics.cacheMisses++;
    this.updateResponseTime('miss', responseTime);
    this.updateMetrics();
  }

  private updateResponseTime(type: string, time: number): void {
    if (!this.metrics.responseTimesByType[type]) {
      this.metrics.responseTimesByType[type] = [];
    }
    
    this.metrics.responseTimesByType[type].push(time);
    
    // Keep only last 100 measurements per type
    if (this.metrics.responseTimesByType[type].length > 100) {
      this.metrics.responseTimesByType[type] = this.metrics.responseTimesByType[type].slice(-100);
    }
  }

  private updateMetrics(): void {
    this.metrics.hitRate = this.metrics.totalRequests > 0 
      ? (this.metrics.cacheHits / this.metrics.totalRequests) * 100 
      : 0;

    // Calculate average response time across all types
    const allTimes = Object.values(this.metrics.responseTimesByType).flat();
    this.metrics.averageResponseTime = allTimes.length > 0
      ? allTimes.reduce((sum, time) => sum + time, 0) / allTimes.length
      : 0;

    this.metrics.lastUpdated = Date.now();
  }

  // Utility methods
  private generateCacheKey(command: string, context?: any): string {
    const contextStr = context ? JSON.stringify(context) : '';
    return `${command.toLowerCase().trim()}:${contextStr}`.replace(/\s+/g, '_');
  }

  private isValidCache(cached: CachedResponse): boolean {
    return Date.now() < cached.expiresAt;
  }

  private classifyPriority(command: string): 'emergency' | 'navigation' | 'cooking' | 'conversation' {
    const cmd = command.toLowerCase();
    
    if (cmd.includes('help') || cmd.includes('stuck') || cmd.includes('emergency')) {
      return 'emergency';
    }
    if (cmd.includes('next') || cmd.includes('back') || cmd.includes('repeat')) {
      return 'navigation';
    }
    if (cmd.includes('timer') || cmd.includes('ingredient') || cmd.includes('cook')) {
      return 'cooking';
    }
    return 'conversation';
  }

  private getExpirationTime(type: 'instant' | 'fast' | 'normal'): number {
    switch (type) {
      case 'instant': return 7 * 24 * 60 * 60 * 1000; // 7 days
      case 'fast': return 24 * 60 * 60 * 1000; // 24 hours
      case 'normal': return 12 * 60 * 60 * 1000; // 12 hours
      default: return 24 * 60 * 60 * 1000;
    }
  }

  // Storage management
  private loadCacheFromStorage(): void {
    try {
      if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
        const cached = localStorage.getItem('mamia_response_cache');
        if (cached) {
          const data = JSON.parse(cached);
          
          // Restore cache entries
          for (const [key, value] of Object.entries(data.cache || {})) {
            const cached = value as CachedResponse;
            if (this.isValidCache(cached)) {
              this.cache.set(key, cached);
            }
          }
          
          // Restore metrics
          if (data.metrics) {
            this.metrics = { ...this.metrics, ...data.metrics };
          }
          
          console.log('üìÇ Loaded', this.cache.size, 'cached responses from storage');
        }
      }
    } catch (error) {
      console.warn('Failed to load cache from storage:', error);
    }
  }

  private saveCacheToStorage(): void {
    try {
      if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
        const data = {
          cache: Object.fromEntries(this.cache.entries()),
          metrics: this.metrics,
          timestamp: Date.now()
        };
        
        localStorage.setItem('mamia_response_cache', JSON.stringify(data));
      }
    } catch (error) {
      console.warn('Failed to save cache to storage:', error);
    }
  }

  // Public API methods
  getPerformanceMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  getCacheSize(): number {
    return this.cache.size;
  }

  clearCache(): void {
    this.cache.clear();
    this.metrics = {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0,
      averageResponseTime: 0,
      responseTimesByType: {},
      hitRate: 0,
      lastUpdated: Date.now()
    };
    
    if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
      localStorage.removeItem('mamia_response_cache');
    }
    
    console.log('üóëÔ∏è Response cache cleared');
  }

  // Get response time target for command type
  getResponseTimeTarget(command: string): number {
    const priority = this.classifyPriority(command);
    
    switch (priority) {
      case 'emergency': return 50; // < 50ms
      case 'navigation': return 100; // < 100ms
      case 'cooking': return 200; // < 200ms
      case 'conversation': return 500; // < 500ms
      default: return 500;
    }
  }

  // Check if command should use instant response
  shouldUseInstantResponse(command: string): boolean {
    const target = this.getResponseTimeTarget(command);
    return target <= 100; // Use instant for emergency and navigation
  }
}

export default new ResponseCacheService();
</file>

<file path="services/UnifiedConversationService.ts/UnifiedConversationService.ts">
import { Platform } from 'react-native';
import ConversationService from './ConversationService';

export type ConversationContext = 'pre_cooking' | 'cooking' | 'post_cooking';
export type MamaPersonality = 'nonna_lucia' | 'abuela_rosa' | 'mae_malai';

interface ConversationState {
  currentMama: MamaPersonality;
  context: ConversationContext;
  currentRecipe?: {
    id: number;
    name: string;
    currentStep?: number;
    totalSteps?: number;
  };
  conversationHistory: Array<{
    role: 'user' | 'assistant';
    content: string;
    timestamp: Date;
    isVoice: boolean;
  }>;
}

interface TemplateResponse {
  text: string;
  priority: 'instant' | 'fast' | 'normal';
  confidence: number;
  category: 'greeting' | 'cooking' | 'encouragement' | 'navigation' | 'help';
}

class UnifiedConversationService {
  private state: ConversationState = {
    currentMama: 'nonna_lucia',
    context: 'pre_cooking',
    conversationHistory: []
  };

  private templates = new TemplateSystem();

  constructor() {
    console.log('ü§ñ UnifiedConversationService initialized');
  }

  // MAIN CHAT METHOD - Handles both text and voice
  async chat(userInput: string, options?: {
    isVoice?: boolean;
    priority?: 'emergency' | 'normal' | 'low';
    maxWords?: number;
    context?: any;
  }): Promise<string> {
    const isVoice = options?.isVoice || false;
    const startTime = Date.now();

    console.log('üí¨ Unified chat request:', {
      input: userInput.substring(0, 50) + '...',
      isVoice,
      context: this.state.context,
      mama: this.state.currentMama
    });

    // Add user message to history
    this.addToHistory('user', userInput, isVoice);

    try {
      // STEP 1: Try smart templates first (< 100ms)
      const templateResponse = this.templates.tryMatch(
        userInput, 
        this.state.context, 
        this.state.currentMama,
        options
      );

      if (templateResponse && templateResponse.confidence > 0.8) {
        const responseTime = Date.now() - startTime;
        console.log(`‚ö° Template response in ${responseTime}ms:`, templateResponse.text);
        
        this.addToHistory('assistant', templateResponse.text, isVoice);
        return templateResponse.text;
      }

      // STEP 2: Use GPT for complex conversations
      const gptResponse = await this.gptChat(userInput, options);
      const responseTime = Date.now() - startTime;
      
      console.log(`ü§ñ GPT response in ${responseTime}ms:`, gptResponse);
      
      this.addToHistory('assistant', gptResponse, isVoice);
      return gptResponse;

    } catch (error) {
      console.error('‚ùå Unified chat error:', error);
      const fallback = this.getFallbackResponse(userInput, isVoice);
      this.addToHistory('assistant', fallback, isVoice);
      return fallback;
    }
  }

  // GPT Chat with context awareness
  private async gptChat(userInput: string, options?: any): Promise<string> {
    const context = {
      ...options,
      conversationContext: this.state.context,
      currentMama: this.state.currentMama,
      currentRecipe: this.state.currentRecipe,
      recentHistory: this.getRecentHistory(3), // Last 3 exchanges
      isVoice: options?.isVoice || false,
      maxWords: options?.maxWords || (options?.isVoice ? 15 : 30)
    };

    return ConversationService.askNonna(userInput, context);
  }

  // Set conversation context
  setContext(context: ConversationContext, recipe?: any): void {
    console.log('üéØ Setting conversation context:', context, recipe?.name);
    
    this.state.context = context;
    if (recipe) {
      this.state.currentRecipe = {
        id: recipe.id,
        name: recipe.name,
        currentStep: recipe.currentStep,
        totalSteps: recipe.totalSteps
      };
    }

    // Clear history when switching contexts to avoid confusion
    if (context === 'cooking' && this.state.conversationHistory.length > 0) {
      console.log('üóëÔ∏è Clearing pre-cooking history for cooking mode');
      this.state.conversationHistory = [];
    }
  }

  // Set current mama personality
  setMama(mama: MamaPersonality): void {
    console.log('üëµ Setting mama personality:', mama);
    this.state.currentMama = mama;
    
    // Clear history when switching mamas
    this.state.conversationHistory = [];
  }

  // Update recipe progress
  updateRecipeProgress(currentStep: number, totalSteps: number): void {
    if (this.state.currentRecipe) {
      this.state.currentRecipe.currentStep = currentStep;
      this.state.currentRecipe.totalSteps = totalSteps;
    }
  }

  // Get conversation history for UI
  getHistory(): typeof this.state.conversationHistory {
    return [...this.state.conversationHistory];
  }

  // Clear conversation history
  clearHistory(): void {
    console.log('üóëÔ∏è Clearing conversation history');
    this.state.conversationHistory = [];
  }

  // Private helper methods
  private addToHistory(role: 'user' | 'assistant', content: string, isVoice: boolean): void {
    this.state.conversationHistory.push({
      role,
      content,
      timestamp: new Date(),
      isVoice
    });

    // Keep only last 10 exchanges to manage memory
    if (this.state.conversationHistory.length > 20) {
      this.state.conversationHistory = this.state.conversationHistory.slice(-20);
    }
  }

  private getRecentHistory(count: number): Array<{role: string, content: string}> {
    return this.state.conversationHistory
      .slice(-count * 2) // Get last N exchanges (user + assistant pairs)
      .map(h => ({ role: h.role, content: h.content }));
  }

  private getFallbackResponse(userInput: string, isVoice: boolean): string {
    const mama = this.getMamaConfig(this.state.currentMama);
    
    if (isVoice) {
      return `${mama.acknowledgment} Non ho capito, tesoro!`;
    } else {
      return `${mama.acknowledgment} I didn't quite understand that, amore. Could you ask me something else about cooking?`;
    }
  }

  private getMamaConfig(mama: MamaPersonality) {
    const configs = {
      nonna_lucia: {
        acknowledgment: 'Bene!',
        personality: 'warm Italian grandmother',
        expressions: ['amore', 'tesoro', 'caro', 'bambino']
      },
      abuela_rosa: {
        acknowledgment: '¬°S√≠!',
        personality: 'loving Mexican grandmother',
        expressions: ['mijo', 'coraz√≥n', 'amor', 'ni√±o']
      },
      mae_malai: {
        acknowledgment: 'Chai!',
        personality: 'gentle Thai grandmother',
        expressions: ['dear', 'sweetheart', 'little one']
      }
    };

    return configs[mama];
  }

  // Public API methods
  isAvailable(): boolean {
    return ConversationService.isAvailable();
  }

  getServiceStatus() {
    return {
      ...ConversationService.getServiceStatus(),
      currentMama: this.state.currentMama,
      context: this.state.context,
      historyLength: this.state.conversationHistory.length
    };
  }
}

// SMART TEMPLATE SYSTEM
class TemplateSystem {
  private templates: Map<string, TemplateResponse[]> = new Map();

  constructor() {
    this.initializeTemplates();
  }

  tryMatch(
    userInput: string, 
    context: ConversationContext, 
    mama: MamaPersonality,
    options?: any
  ): TemplateResponse | null {
    const normalizedInput = userInput.toLowerCase().trim();
    const contextKey = `${context}_${mama}`;
    
    console.log('üéØ Template matching:', {
      input: normalizedInput.substring(0, 30) + '...',
      context,
      mama
    });

    // Get templates for current context and mama
    const contextTemplates = this.templates.get(contextKey) || [];
    const globalTemplates = this.templates.get('global') || [];
    const allTemplates = [...contextTemplates, ...globalTemplates];

    let bestMatch: TemplateResponse | null = null;
    let bestScore = 0;

    for (const template of allTemplates) {
      const score = this.calculateMatchScore(normalizedInput, template, options);
      if (score > bestScore && score > 0.5) { // Minimum confidence threshold
        bestScore = score;
        bestMatch = { ...template, confidence: score };
      }
    }

    if (bestMatch) {
      console.log('‚úÖ Template match found:', bestMatch.text, 'confidence:', bestMatch.confidence);
    } else {
      console.log('‚ùå No template match found');
    }

    return bestMatch;
  }

  private calculateMatchScore(input: string, template: TemplateResponse, options?: any): number {
    let score = 0;

    // Keyword matching
    const keywords = this.extractKeywords(template);
    for (const keyword of keywords) {
      if (input.includes(keyword)) {
        score += 0.3;
      }
    }

    // Category-specific matching
    switch (template.category) {
      case 'greeting':
        if (input.includes('hello') || input.includes('hi') || input.includes('ciao') || 
            input.includes('welcome') || input.includes('start')) {
          score += 0.4;
        }
        break;
      
      case 'navigation':
        if (input.includes('next') || input.includes('back') || input.includes('previous') || 
            input.includes('repeat') || input.includes('again')) {
          score += 0.5;
        }
        break;
      
      case 'cooking':
        if (input.includes('timer') || input.includes('ingredient') || input.includes('cook') || 
            input.includes('recipe') || input.includes('step')) {
          score += 0.4;
        }
        break;
      
      case 'help':
        if (input.includes('help') || input.includes('stuck') || input.includes('confused') || 
            input.includes('problem') || input.includes('wrong')) {
          score += 0.5;
        }
        break;
      
      case 'encouragement':
        if (input.includes('good') || input.includes('great') || input.includes('done') || 
            input.includes('finished') || input.includes('complete')) {
          score += 0.4;
        }
        break;
    }

    // Boost score for voice commands if this is a voice template
    if (options?.isVoice && (template.category === 'navigation' || template.category === 'help')) {
      score += 0.2;
    }

    return Math.min(score, 1.0);
  }

  private extractKeywords(template: TemplateResponse): string[] {
    const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
    return template.text.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 2 && !commonWords.includes(word))
      .slice(0, 5); // Top 5 keywords
  }

  private initializeTemplates(): void {
    console.log('üöÄ Initializing conversation templates...');

    // NONNA LUCIA TEMPLATES
    this.templates.set('pre_cooking_nonna_lucia', [
      {
        text: "Ciao amore! Welcome to my kitchen! What would you like to cook today?",
        priority: 'instant',
        confidence: 0.9,
        category: 'greeting'
      },
      {
        text: "Bene! That's a wonderful choice, tesoro. Do you have all the ingredients ready?",
        priority: 'instant',
        confidence: 0.8,
        category: 'cooking'
      },
      {
        text: "Perfetto! Don't worry, amore, I'll guide you through every step. We cook with love!",
        priority: 'instant',
        confidence: 0.9,
        category: 'encouragement'
      },
      {
        text: "Che bello! That recipe is one of my favorites, caro. Let me tell you the secret...",
        priority: 'instant',
        confidence: 0.8,
        category: 'cooking'
      },
      {
        text: "Mamma mia! You're asking all the right questions, tesoro!",
        priority: 'instant',
        confidence: 0.7,
        category: 'encouragement'
      }
    ]);

    this.templates.set('cooking_nonna_lucia', [
      {
        text: "Ecco! Next step, tesoro!",
        priority: 'instant',
        confidence: 0.95,
        category: 'navigation'
      },
      {
        text: "Bene! Going back, amore!",
        priority: 'instant',
        confidence: 0.95,
        category: 'navigation'
      },
      {
        text: "Perfetto! Timer set, caro!",
        priority: 'instant',
        confidence: 0.9,
        category: 'cooking'
      },
      {
        text: "Calma, tesoro! Let's figure this out together!",
        priority: 'instant',
        confidence: 0.9,
        category: 'help'
      },
      {
        text: "Bravo! You're doing magnifico!",
        priority: 'instant',
        confidence: 0.8,
        category: 'encouragement'
      }
    ]);

    // ABUELA ROSA TEMPLATES
    this.templates.set('pre_cooking_abuela_rosa', [
      {
        text: "¬°Hola mijo! Welcome to Abuela's cocina! What delicious meal shall we make?",
        priority: 'instant',
        confidence: 0.9,
        category: 'greeting'
      },
      {
        text: "¬°Qu√© bueno! That's my favorite recipe, coraz√≥n. Let's cook with amor!",
        priority: 'instant',
        confidence: 0.8,
        category: 'cooking'
      },
      {
        text: "¬°Perfecto! Don't worry, amor, Abuela will teach you everything!",
        priority: 'instant',
        confidence: 0.9,
        category: 'encouragement'
      }
    ]);

    this.templates.set('cooking_abuela_rosa', [
      {
        text: "¬°√ìrale! Next step, mijo!",
        priority: 'instant',
        confidence: 0.95,
        category: 'navigation'
      },
      {
        text: "S√≠ s√≠! Going back, amor!",
        priority: 'instant',
        confidence: 0.95,
        category: 'navigation'
      },
      {
        text: "¬°Bueno! Timer ready, coraz√≥n!",
        priority: 'instant',
        confidence: 0.9,
        category: 'cooking'
      },
      {
        text: "Tranquilo, mijo! We solve this together!",
        priority: 'instant',
        confidence: 0.9,
        category: 'help'
      }
    ]);

    // MAE MALAI TEMPLATES
    this.templates.set('pre_cooking_mae_malai', [
      {
        text: "Sawasdee ka! Welcome to Mae's kitchen! What Thai dish would you like to learn?",
        priority: 'instant',
        confidence: 0.9,
        category: 'greeting'
      },
      {
        text: "Chai laew! That's a wonderful choice, dear. This dish is special to my family.",
        priority: 'instant',
        confidence: 0.8,
        category: 'cooking'
      },
      {
        text: "Sabai sabai, don't worry, little one. Mae will teach you with patience and love.",
        priority: 'instant',
        confidence: 0.9,
        category: 'encouragement'
      },
      {
        text: "Aroi mak! That recipe brings back memories of my grandmother's kitchen.",
        priority: 'instant',
        confidence: 0.8,
        category: 'cooking'
      },
      {
        text: "Mai pen rai! You're asking wonderful questions about Thai cooking!",
        priority: 'instant',
        confidence: 0.7,
        category: 'encouragement'
      }
    ]);

    this.templates.set('cooking_mae_malai', [
      {
        text: "Chai! Next step, sweetheart!",
        priority: 'instant',
        confidence: 0.95,
        category: 'navigation'
      },
      {
        text: "Good! Going back, dear!",
        priority: 'instant',
        confidence: 0.95,
        category: 'navigation'
      },
      {
        text: "Perfect! Timer is set, little one!",
        priority: 'instant',
        confidence: 0.9,
        category: 'cooking'
      },
      {
        text: "Jai yen yen, take breath, dear. Mae help you step by step.",
        priority: 'instant',
        confidence: 0.9,
        category: 'help'
      },
      {
        text: "Aroi! You're doing beautifully!",
        priority: 'instant',
        confidence: 0.8,
        category: 'encouragement'
      }
    ]);

    // GLOBAL TEMPLATES (work for all mamas)
    this.templates.set('global', [
      {
        text: "I'm here to help you cook, dear! What would you like to know?",
        priority: 'fast',
        confidence: 0.7,
        category: 'help'
      },
      {
        text: "You're doing wonderfully! Keep going!",
        priority: 'instant',
        confidence: 0.8,
        category: 'encouragement'
      },
      {
        text: "That's a great question about cooking!",
        priority: 'fast',
        confidence: 0.6,
        category: 'cooking'
      }
    ]);

    const totalTemplates = Array.from(this.templates.values()).reduce((sum, arr) => sum + arr.length, 0);
    console.log(`‚úÖ Initialized ${totalTemplates} conversation templates including Mae Malai`);
  }
}

export default new UnifiedConversationService();
</file>

<file path="services/VoiceCacheService.ts/VoiceCacheService.ts">
import { Platform } from 'react-native';

interface CachedResponse {
  text: string;
  audioUrl?: string;
  timestamp: number;
  type: 'instruction' | 'encouragement' | 'emergency' | 'timer';
  expiresAt: number;
}

interface CacheStats {
  hits: number;
  misses: number;
  totalRequests: number;
  cacheSize: number;
  hitRate: number;
}

class VoiceCacheService {
  private cache: Map<string, CachedResponse> = new Map();
  private stats: CacheStats = {
    hits: 0,
    misses: 0,
    totalRequests: 0,
    cacheSize: 0,
    hitRate: 0
  };
  
  // Cache expiration times (in milliseconds)
  private readonly CACHE_EXPIRY = {
    instruction: 24 * 60 * 60 * 1000, // 24 hours
    encouragement: 12 * 60 * 60 * 1000, // 12 hours
    emergency: 7 * 24 * 60 * 60 * 1000, // 7 days (rarely change)
    timer: 12 * 60 * 60 * 1000, // 12 hours
  };

  // Pre-defined templates for instant responses
  private readonly INSTRUCTION_TEMPLATES = [
    "Now we do this together: {instruction}",
    "Next, amore: {instruction}",
    "This is important, tesoro: {instruction}",
    "Just like my nonna taught me: {instruction}",
    "Together we: {instruction}",
    "Ecco, caro: {instruction}",
    "Bene, now we: {instruction}"
  ];

  private readonly ENCOURAGEMENT_CACHE = [
    "Bravissimo! You're doing beautifully, tesoro!",
    "Che bello! Just like we do it in the family!",
    "Perfetto! You have nonna's touch, amore!",
    "Mamma mia, you're a natural, caro!",
    "Bellissimo! The family would be so proud!",
    "Ecco! You're getting the hang of this, amore!",
    "Bello! Keep going, you're doing wonderful!",
    "Tesoro! This is exactly how nonna would do it!"
  ];

  private readonly EMERGENCY_RESPONSES = [
    "Don't worry, tesoro! We take it one step at a time.",
    "Calma, amore! Every great cook has moments like this.",
    "Bene bene! Let's figure this out together, caro.",
    "Ecco! No stress in nonna's kitchen, we fix everything!",
    "Perfetto! This is how we learn, step by step.",
    "Amore! Trust yourself, you're doing better than you think!"
  ];

  private readonly TIMER_RESPONSES = [
    "Attenzione! Our {timerName} is ready, amore!",
    "Ecco! Time is up for our {timerName}, tesoro!",
    "Bene bene! Let's check our {timerName} together!",
    "Perfetto timing! Our {timerName} is done, caro!",
    "Mamma mia! The {timerName} timer finished, amore!"
  ];

  constructor() {
    this.loadCacheFromStorage();
    this.preloadCommonResponses();
  }

  // Generate cache key for consistent lookups
  private generateCacheKey(text: string, type: string, context?: any): string {
    const contextStr = context ? JSON.stringify(context) : '';
    return `${type}:${text}:${contextStr}`.toLowerCase().replace(/\s+/g, '_');
  }

  // Check if cached response is still valid
  private isValidCache(cached: CachedResponse): boolean {
    return Date.now() < cached.expiresAt;
  }

  // Get cached response if available and valid
  getCachedResponse(text: string, type: 'instruction' | 'encouragement' | 'emergency' | 'timer', context?: any): CachedResponse | null {
    this.stats.totalRequests++;
    
    const key = this.generateCacheKey(text, type, context);
    const cached = this.cache.get(key);
    
    if (cached && this.isValidCache(cached)) {
      this.stats.hits++;
      this.updateStats();
      console.log('üéØ Cache HIT:', key.substring(0, 50) + '...');
      return cached;
    }
    
    this.stats.misses++;
    this.updateStats();
    console.log('‚ùå Cache MISS:', key.substring(0, 50) + '...');
    return null;
  }

  // Cache a response with audio URL
  cacheResponse(text: string, type: 'instruction' | 'encouragement' | 'emergency' | 'timer', audioUrl?: string, context?: any): void {
    const key = this.generateCacheKey(text, type, context);
    const expiresAt = Date.now() + this.CACHE_EXPIRY[type];
    
    const cached: CachedResponse = {
      text,
      audioUrl,
      timestamp: Date.now(),
      type,
      expiresAt
    };
    
    this.cache.set(key, cached);
    this.stats.cacheSize = this.cache.size;
    
    console.log('üíæ Cached response:', key.substring(0, 50) + '...', audioUrl ? 'with audio' : 'text only');
    
    // Persist to storage
    this.saveCacheToStorage();
    
    // Clean up expired entries periodically
    if (this.cache.size % 10 === 0) {
      this.cleanupExpiredEntries();
    }
  }

  // Get instant template-based instruction
  getInstantInstruction(instruction: string, stepNumber?: number, totalSteps?: number): string {
    const template = this.INSTRUCTION_TEMPLATES[Math.floor(Math.random() * this.INSTRUCTION_TEMPLATES.length)];
    let response = template.replace('{instruction}', instruction);
    
    // Add progress context
    if (stepNumber && totalSteps) {
      const progress = stepNumber / totalSteps;
      if (progress > 0.8) {
        response = `Almost finished, amore! ${response}`;
      } else if (progress > 0.5) {
        response = `Bravissimo! ${response}`;
      }
    }
    
    // Cache this template response
    this.cacheResponse(instruction, 'instruction', undefined, { stepNumber, totalSteps });
    
    return response;
  }

  // Get instant encouragement
  getInstantEncouragement(): string {
    const encouragement = this.ENCOURAGEMENT_CACHE[Math.floor(Math.random() * this.ENCOURAGEMENT_CACHE.length)];
    
    // Cache this encouragement
    this.cacheResponse(encouragement, 'encouragement');
    
    return encouragement;
  }

  // Get instant emergency response
  getInstantEmergencyResponse(situation?: string): string {
    const response = this.EMERGENCY_RESPONSES[Math.floor(Math.random() * this.EMERGENCY_RESPONSES.length)];
    
    // Cache this emergency response
    this.cacheResponse(situation || 'help', 'emergency');
    
    return response;
  }

  // Get instant timer response
  getInstantTimerResponse(timerName: string): string {
    const template = this.TIMER_RESPONSES[Math.floor(Math.random() * this.TIMER_RESPONSES.length)];
    const response = template.replace('{timerName}', timerName);
    
    // Cache this timer response
    this.cacheResponse(timerName, 'timer');
    
    return response;
  }

  // Pre-load common responses for instant access
  private preloadCommonResponses(): void {
    console.log('üöÄ Pre-loading common voice responses...');
    
    // Pre-load common cooking instructions
    const commonInstructions = [
      'Heat oil in a large pan',
      'Add garlic and cook until fragrant',
      'Season with salt and pepper',
      'Stir gently and cook for 2 minutes',
      'Add pasta to boiling water',
      'Drain pasta and reserve pasta water',
      'Combine ingredients and mix well',
      'Serve immediately while hot'
    ];
    
    commonInstructions.forEach(instruction => {
      const response = this.getInstantInstruction(instruction);
      // Pre-cache without audio URL (will be generated on first use)
      this.cacheResponse(instruction, 'instruction');
    });
    
    // Pre-load encouragements
    this.ENCOURAGEMENT_CACHE.forEach(encouragement => {
      this.cacheResponse(encouragement, 'encouragement');
    });
    
    // Pre-load emergency responses
    this.EMERGENCY_RESPONSES.forEach(response => {
      this.cacheResponse('help', 'emergency');
    });
    
    console.log('‚úÖ Pre-loaded', this.cache.size, 'common responses');
  }

  // Clean up expired cache entries
  private cleanupExpiredEntries(): void {
    const now = Date.now();
    let cleanedCount = 0;
    
    for (const [key, cached] of this.cache.entries()) {
      if (now >= cached.expiresAt) {
        // Clean up audio URL if it exists
        if (cached.audioUrl && cached.audioUrl.startsWith('blob:')) {
          URL.revokeObjectURL(cached.audioUrl);
        }
        this.cache.delete(key);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      console.log('üßπ Cleaned up', cleanedCount, 'expired cache entries');
      this.stats.cacheSize = this.cache.size;
      this.saveCacheToStorage();
    }
  }

  // Update cache statistics
  private updateStats(): void {
    this.stats.hitRate = this.stats.totalRequests > 0 
      ? (this.stats.hits / this.stats.totalRequests) * 100 
      : 0;
  }

  // Get cache performance statistics
  getStats(): CacheStats {
    return { ...this.stats };
  }

  // Load cache from localStorage (web) or AsyncStorage (native)
  private loadCacheFromStorage(): void {
    try {
      if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
        const cached = localStorage.getItem('mamia_voice_cache');
        if (cached) {
          const data = JSON.parse(cached);
          
          // Restore cache entries
          for (const [key, value] of Object.entries(data.cache || {})) {
            const cached = value as CachedResponse;
            if (this.isValidCache(cached)) {
              this.cache.set(key, cached);
            }
          }
          
          // Restore stats
          if (data.stats) {
            this.stats = { ...this.stats, ...data.stats };
          }
          
          console.log('üìÇ Loaded', this.cache.size, 'cached responses from storage');
        }
      }
    } catch (error) {
      console.warn('Failed to load cache from storage:', error);
    }
  }

  // Save cache to localStorage (web) or AsyncStorage (native)
  private saveCacheToStorage(): void {
    try {
      if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
        const data = {
          cache: Object.fromEntries(this.cache.entries()),
          stats: this.stats,
          timestamp: Date.now()
        };
        
        localStorage.setItem('mamia_voice_cache', JSON.stringify(data));
      }
    } catch (error) {
      console.warn('Failed to save cache to storage:', error);
    }
  }

  // Clear all cache (for testing or reset)
  clearCache(): void {
    // Clean up audio URLs
    for (const cached of this.cache.values()) {
      if (cached.audioUrl && cached.audioUrl.startsWith('blob:')) {
        URL.revokeObjectURL(cached.audioUrl);
      }
    }
    
    this.cache.clear();
    this.stats = {
      hits: 0,
      misses: 0,
      totalRequests: 0,
      cacheSize: 0,
      hitRate: 0
    };
    
    // Clear storage
    if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
      localStorage.removeItem('mamia_voice_cache');
    }
    
    console.log('üóëÔ∏è Cache cleared');
  }

  // Get cache size in MB (approximate)
  getCacheSizeEstimate(): number {
    let totalSize = 0;
    
    for (const cached of this.cache.values()) {
      totalSize += JSON.stringify(cached).length;
    }
    
    return totalSize / (1024 * 1024); // Convert to MB
  }

  // Classify response type for optimal caching
  classifyResponseType(text: string, context?: any): 'instruction' | 'encouragement' | 'emergency' | 'timer' {
    const lowerText = text.toLowerCase();
    
    if (lowerText.includes('timer') || lowerText.includes('time') || context?.timerName) {
      return 'timer';
    }
    
    if (lowerText.includes('help') || lowerText.includes('stuck') || lowerText.includes('confused')) {
      return 'emergency';
    }
    
    if (lowerText.includes('good') || lowerText.includes('great') || lowerText.includes('perfect') || 
        lowerText.includes('bravissimo') || lowerText.includes('bello')) {
      return 'encouragement';
    }
    
    return 'instruction';
  }

  // Pre-cache audio for a recipe when it starts
  async precacheRecipeAudio(recipeSteps: string[], apiKey?: string): Promise<void> {
    if (!apiKey) {
      console.log('üéµ No API key, skipping audio pre-caching');
      return;
    }
    
    console.log('üéµ Pre-caching audio for', recipeSteps.length, 'recipe steps...');
    
    // Pre-cache first 3 steps immediately for instant playback
    const prioritySteps = recipeSteps.slice(0, 3);
    
    for (let i = 0; i < prioritySteps.length; i++) {
      const instruction = prioritySteps[i];
      const template = this.getInstantInstruction(instruction, i + 1, recipeSteps.length);
      
      try {
        // This would generate and cache the audio
        // Implementation would depend on your audio generation service
        console.log('üéµ Pre-cached audio for step', i + 1);
      } catch (error) {
        console.warn('Failed to pre-cache audio for step', i + 1, error);
      }
      
      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log('‚úÖ Pre-cached priority audio for first 3 steps');
  }
}

export default new VoiceCacheService();
</file>

<file path="services/VoiceCommandService.ts/VoiceCommandService.ts">
class VoiceCommandService {
  private isListening = false;
  private recognition: any = null;
  private statusCallback: ((status: any) => void) | null = null;
  private commandCallback: ((command: string, type: string) => void) | null = null;
  private currentState: string = 'idle';

  constructor() {
    this.initializeSpeechRecognition();
  }

  private initializeSpeechRecognition() {
    if (typeof window !== 'undefined' && 'webkitSpeechRecognition' in window) {
      // @ts-ignore
      this.recognition = new webkitSpeechRecognition();
      this.recognition.continuous = false;
      this.recognition.interimResults = false;
      this.recognition.lang = 'en-US';
      
      this.recognition.onstart = () => {
        console.log('üé§ Speech recognition started');
        this.updateStatus('listening', 'üî¥ Listening...', 'Say your command now');
      };

      this.recognition.onresult = (event: any) => {
        const transcript = event.results[0][0].transcript.toLowerCase().trim();
        console.log('üé§ Heard:', transcript);
        this.processVoiceCommand(transcript);
      };

      this.recognition.onerror = (event: any) => {
        console.error('üé§ Speech recognition error:', event.error);
        this.updateStatus('error', '‚ùå Sorry, try again', 'Could not understand', [
          'Try: "Hey Nonna, next step"',
          'Try: "Hey Nonna, set timer 5 minutes"',
          'Try: "Hey Nonna, help"'
        ]);
        // Don't immediately reset the service state - let the error message persist
        this.isListening = false;
      };

      this.recognition.onend = () => {
        console.log('üé§ Speech recognition ended');
        this.isListening = false;
        // Only reset to idle if we're not currently showing an error
        if (this.currentState !== 'error') {
          this.updateStatus('idle', "üí¨ Say 'Hey Nonna' or tap to speak");
        }
      };
    }
  }

  setStatusCallback(callback: (status: any) => void) {
    this.statusCallback = callback;
  }

  setCommandCallback(callback: (command: string, type: string) => void) {
    this.commandCallback = callback;
  }

  private updateStatus(state: string, message: string, action?: string, suggestions?: string[]) {
    this.currentState = state;
    if (this.statusCallback) {
      this.statusCallback({ state, message, action, suggestions });
    }
  }

  startListening() {
    if (!this.recognition) {
      this.updateStatus('error', '‚ùå Voice not supported', 'Browser does not support voice recognition');
      return;
    }

    if (this.isListening) {
      return;
    }

    // Reset any previous error state when starting a new session
    this.currentState = 'idle';
    this.isListening = true;
    this.updateStatus('listening', 'üî¥ Listening...', 'Say "Hey Nonna" followed by your command');
    
    try {
      this.recognition.start();
    } catch (error) {
      console.error('üé§ Failed to start recognition:', error);
      this.updateStatus('error', '‚ùå Voice error', 'Could not start listening');
      this.isListening = false;
    }
  }

  stopListening() {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
      this.isListening = false;
    }
    // Always reset to idle when manually stopping
    this.updateStatus('idle', "üí¨ Say 'Hey Nonna' or tap to speak");
  }

  private processVoiceCommand(transcript: string) {
    this.updateStatus('processing', 'ü§î Nonna is thinking...', 'Processing your command');

    // Check for wake phrase
    if (!transcript.includes('hey nonna') && !transcript.includes('nonna')) {
      this.updateStatus('error', '‚ùå Say "Hey Nonna" first', 'Wake phrase not detected', [
        'Try: "Hey Nonna, next step"',
        'Try: "Hey Nonna, help me"'
      ]);
      return;
    }

    // Remove wake phrase and clean up command
    let command = transcript
      .replace(/hey nonna,?/gi, '')
      .replace(/nonna,?/gi, '')
      .trim();

    const commandType = this.classifyCommand(command);
    const normalizedCommand = this.normalizeCommand(command, commandType);

    if (commandType === 'unknown') {
      this.updateStatus('error', '‚ùå Command not recognized', 'Try one of these commands', [
        '"Next step" - Move forward',
        '"Previous step" - Go back',
        '"Set timer 5 minutes" - Start timer',
        '"Help" - Get assistance'
      ]);
      return;
    }

    // Show success feedback
    this.updateStatus('success', '‚úì Got it!', `Command: ${this.getCommandDescription(commandType)}`);

    // Execute command after brief success display
    setTimeout(() => {
      if (this.commandCallback) {
        this.commandCallback(normalizedCommand, commandType);
      }
      this.updateStatus('idle', "üí¨ Say 'Hey Nonna' or tap to speak");
    }, 1500);
  }

  private classifyCommand(command: string): string {
    const cmd = command.toLowerCase();

    // Navigation commands
    if (cmd.includes('next') || cmd.includes('forward') || cmd.includes('continue')) {
      return 'navigation_next';
    }
    if (cmd.includes('previous') || cmd.includes('back') || cmd.includes('last')) {
      return 'navigation_previous';
    }
    if (cmd.includes('repeat') || cmd.includes('again') || cmd.includes('say that again')) {
      return 'navigation_repeat';
    }

    // Timer commands
    if (cmd.includes('timer') || cmd.includes('set timer')) {
      return 'timer_set';
    }
    if (cmd.includes('time left') || cmd.includes('how much time') || cmd.includes('timer status')) {
      return 'timer_check';
    }

    // Information commands
    if (cmd.includes('what\'s next') || cmd.includes('whats next') || cmd.includes('preview')) {
      return 'info_preview';
    }
    if (cmd.includes('ingredients') || cmd.includes('ingredient list')) {
      return 'info_ingredients';
    }
    if (cmd.includes('how much') && (cmd.includes('salt') || cmd.includes('pepper') || cmd.includes('oil'))) {
      return 'info_ingredient_amount';
    }

    // Control commands
    if (cmd.includes('help') || cmd.includes('stuck') || cmd.includes('confused')) {
      return 'control_help';
    }
    if (cmd.includes('pause') || cmd.includes('stop cooking')) {
      return 'control_pause';
    }

    return 'unknown';
  }

  private normalizeCommand(command: string, type: string): string {
    switch (type) {
      case 'navigation_next':
        return 'next_step';
      case 'navigation_previous':
        return 'previous_step';
      case 'navigation_repeat':
        return 'repeat_step';
      case 'timer_set':
        return this.extractTimerCommand(command);
      case 'timer_check':
        return 'check_timers';
      case 'info_preview':
        return 'preview_next';
      case 'info_ingredients':
        return 'show_ingredients';
      case 'info_ingredient_amount':
        return this.extractIngredientQuery(command);
      case 'control_help':
        return 'emergency_help';
      case 'control_pause':
        return 'pause_cooking';
      default:
        return command;
    }
  }

  private extractTimerCommand(command: string): string {
    // Extract timer duration from command
    const timeMatch = command.match(/(\d+)\s*(minute|minutes|min|second|seconds|sec)/i);
    if (timeMatch) {
      const duration = parseInt(timeMatch[1]);
      const unit = timeMatch[2].toLowerCase();
      const seconds = unit.startsWith('min') ? duration * 60 : duration;
      return `set_timer_${seconds}`;
    }
    return 'set_timer_300'; // Default 5 minutes
  }

  private extractIngredientQuery(command: string): string {
    if (command.includes('salt')) return 'ingredient_salt';
    if (command.includes('pepper')) return 'ingredient_pepper';
    if (command.includes('oil')) return 'ingredient_oil';
    if (command.includes('garlic')) return 'ingredient_garlic';
    return 'ingredient_general';
  }

  private getCommandDescription(type: string): string {
    switch (type) {
      case 'navigation_next':
        return 'Moving to next step';
      case 'navigation_previous':
        return 'Going to previous step';
      case 'navigation_repeat':
        return 'Repeating current step';
      case 'timer_set':
        return 'Setting timer';
      case 'timer_check':
        return 'Checking timers';
      case 'info_preview':
        return 'Previewing next step';
      case 'info_ingredients':
        return 'Showing ingredients';
      case 'info_ingredient_amount':
        return 'Checking ingredient amount';
      case 'control_help':
        return 'Getting help';
      case 'control_pause':
        return 'Pausing cooking';
      default:
        return 'Processing command';
    }
  }

  // Check if speech recognition is available
  isAvailable(): boolean {
    return typeof window !== 'undefined' && 'webkitSpeechRecognition' in window;
  }

  // Get current listening state
  getListeningState(): boolean {
    return this.isListening;
  }
}

export default new VoiceCommandService();
</file>

<file path="tsconfig.json/tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "nativewind-env.d.ts"
  ]
}
</file>

<file path="types/env.d.ts/env.d.ts">
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      EXPO_PUBLIC_ELEVENLABS_API_KEY: string;
      EXPO_PUBLIC_NONNA_VOICE_ID: string;
      EXPO_PUBLIC_OPENAI_API_KEY: string;
    }
  }
}

// Ensure this file is treated as a module
export {};
</file>

</files>
